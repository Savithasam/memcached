        -:    0:Source:memcached.c
        -:    0:Graph:memcached.gcno
        -:    0:Data:memcached.gcda
        -:    0:Runs:119
        -:    0:Programs:1
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:/*
        -:    3: *  memcached - memory caching daemon
        -:    4: *
        -:    5: *       http://www.memcached.org/
        -:    6: *
        -:    7: *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.
        -:    8: *
        -:    9: *  Use and distribution licensed under the BSD license.  See
        -:   10: *  the LICENSE file for full text.
        -:   11: *
        -:   12: *  Authors:
        -:   13: *      Anatoly Vorobey <mellon@pobox.com>
        -:   14: *      Brad Fitzpatrick <brad@danga.com>
        -:   15: */
        -:   16:#include "memcached.h"
        -:   17:#ifdef EXTSTORE
        -:   18:#include "storage.h"
        -:   19:#endif
        -:   20:#include <sys/stat.h>
        -:   21:#include <sys/socket.h>
        -:   22:#include <sys/un.h>
        -:   23:#include <signal.h>
        -:   24:#include <sys/param.h>
        -:   25:#include <sys/resource.h>
        -:   26:#include <sys/uio.h>
        -:   27:#include <ctype.h>
        -:   28:#include <stdarg.h>
        -:   29:
        -:   30:/* some POSIX systems need the following definition
        -:   31: * to get mlockall flags out of sys/mman.h.  */
        -:   32:#ifndef _P1003_1B_VISIBLE
        -:   33:#define _P1003_1B_VISIBLE
        -:   34:#endif
        -:   35:/* need this to get IOV_MAX on some platforms. */
        -:   36:#ifndef __need_IOV_MAX
        -:   37:#define __need_IOV_MAX
        -:   38:#endif
        -:   39:#include <pwd.h>
        -:   40:#include <sys/mman.h>
        -:   41:#include <fcntl.h>
        -:   42:#include <netinet/tcp.h>
        -:   43:#include <arpa/inet.h>
        -:   44:#include <errno.h>
        -:   45:#include <stdlib.h>
        -:   46:#include <stdio.h>
        -:   47:#include <string.h>
        -:   48:#include <time.h>
        -:   49:#include <assert.h>
        -:   50:#include <limits.h>
        -:   51:#include <sysexits.h>
        -:   52:#include <stddef.h>
        -:   53:
        -:   54:#ifdef HAVE_GETOPT_LONG
        -:   55:#include <getopt.h>
        -:   56:#endif
        -:   57:
        -:   58:/* FreeBSD 4.x doesn't have IOV_MAX exposed. */
        -:   59:#ifndef IOV_MAX
        -:   60:#if defined(__FreeBSD__) || defined(__APPLE__) || defined(__GNU__)
        -:   61:# define IOV_MAX 1024
        -:   62:/* GNU/Hurd don't set MAXPATHLEN
        -:   63: * http://www.gnu.org/software/hurd/hurd/porting/guidelines.html#PATH_MAX_tt_MAX_PATH_tt_MAXPATHL */
        -:   64:#ifndef MAXPATHLEN
        -:   65:#define MAXPATHLEN 4096
        -:   66:#endif
        -:   67:#endif
        -:   68:#endif
        -:   69:
        -:   70:/*
        -:   71: * forward declarations
        -:   72: */
        -:   73:static void drive_machine(conn *c);
        -:   74:static int new_socket(struct addrinfo *ai);
        -:   75:static int try_read_command(conn *c);
        -:   76:
        -:   77:enum try_read_result {
        -:   78:    READ_DATA_RECEIVED,
        -:   79:    READ_NO_DATA_RECEIVED,
        -:   80:    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */
        -:   81:    READ_MEMORY_ERROR      /** failed to allocate more memory */
        -:   82:};
        -:   83:
        -:   84:static enum try_read_result try_read_network(conn *c);
        -:   85:static enum try_read_result try_read_udp(conn *c);
        -:   86:
        -:   87:static void conn_set_state(conn *c, enum conn_states state);
        -:   88:static int start_conn_timeout_thread();
        -:   89:
        -:   90:/* stats */
        -:   91:static void stats_init(void);
        -:   92:static void server_stats(ADD_STAT add_stats, conn *c);
        -:   93:static void process_stat_settings(ADD_STAT add_stats, void *c);
        -:   94:static void conn_to_str(const conn *c, char *buf);
        -:   95:
        -:   96:
        -:   97:/* defaults */
        -:   98:static void settings_init(void);
        -:   99:
        -:  100:/* event handling, network IO */
        -:  101:static void event_handler(const int fd, const short which, void *arg);
        -:  102:static void conn_close(conn *c);
        -:  103:static void conn_init(void);
        -:  104:static bool update_event(conn *c, const int new_flags);
        -:  105:static void complete_nread(conn *c);
        -:  106:static void process_command(conn *c, char *command);
        -:  107:static void write_and_free(conn *c, char *buf, int bytes);
        -:  108:static int ensure_iov_space(conn *c);
        -:  109:static int add_iov(conn *c, const void *buf, int len);
        -:  110:static int add_chunked_item_iovs(conn *c, item *it, int len);
        -:  111:static int add_msghdr(conn *c);
        -:  112:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -:  113:                            const char *errstr, int swallow);
        -:  114:static void write_bin_miss_response(conn *c, char *key, size_t nkey);
        -:  115:
        -:  116:#ifdef EXTSTORE
        -:  117:static void _get_extstore_cb(void *e, obj_io *io, int ret);
        -:  118:static inline int _get_extstore(conn *c, item *it, int iovst, int iovcnt);
        -:  119:#endif
        -:  120:static void conn_free(conn *c);
        -:  121:
        -:  122:/** exported globals **/
        -:  123:struct stats stats;
        -:  124:struct stats_state stats_state;
        -:  125:struct settings settings;
        -:  126:time_t process_started;     /* when the process was started */
        -:  127:conn **conns;
        -:  128:
        -:  129:struct slab_rebalance slab_rebal;
        -:  130:volatile int slab_rebalance_signal;
        -:  131:#ifdef EXTSTORE
        -:  132:/* hoping this is temporary; I'd prefer to cut globals, but will complete this
        -:  133: * battle another day.
        -:  134: */
        -:  135:void *ext_storage;
        -:  136:#endif
        -:  137:/** file scope variables **/
        -:  138:static conn *listen_conn = NULL;
        -:  139:static int max_fds;
        -:  140:static struct event_base *main_base;
        -:  141:
        -:  142:enum transmit_result {
        -:  143:    TRANSMIT_COMPLETE,   /** All done writing. */
        -:  144:    TRANSMIT_INCOMPLETE, /** More data remaining to write. */
        -:  145:    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */
        -:  146:    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */
        -:  147:};
        -:  148:
        -:  149:static enum transmit_result transmit(conn *c);
        -:  150:
        -:  151:/* This reduces the latency without adding lots of extra wiring to be able to
        -:  152: * notify the listener thread of when to listen again.
        -:  153: * Also, the clock timer could be broken out into its own thread and we
        -:  154: * can block the listener via a condition.
        -:  155: */
        -:  156:static volatile bool allow_new_conns = true;
        -:  157:static struct event maxconnsevent;
    #####:  158:static void maxconns_handler(const int fd, const short which, void *arg) {
    #####:  159:    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};
        -:  160:
    #####:  161:    if (fd == -42 || allow_new_conns == false) {
        -:  162:        /* reschedule in 10ms if we need to keep polling */
    #####:  163:        evtimer_set(&maxconnsevent, maxconns_handler, 0);
    #####:  164:        event_base_set(main_base, &maxconnsevent);
    #####:  165:        evtimer_add(&maxconnsevent, &t);
        -:  166:    } else {
    #####:  167:        evtimer_del(&maxconnsevent);
    #####:  168:        accept_new_conns(true);
        -:  169:    }
    #####:  170:}
        -:  171:
        -:  172:#define REALTIME_MAXDELTA 60*60*24*30
        -:  173:
        -:  174:/*
        -:  175: * given time value that's either unix time or delta from current unix time, return
        -:  176: * unix time. Use the fact that delta can't exceed one month (and real time value can't
        -:  177: * be that low).
        -:  178: */
        -:  179:static rel_time_t realtime(const time_t exptime) {
        -:  180:    /* no. of seconds in 30 days - largest possible delta exptime */
        -:  181:
   102982:  182:    if (exptime == 0) return 0; /* 0 means never expire */
        -:  183:
      433:  184:    if (exptime > REALTIME_MAXDELTA) {
        -:  185:        /* if item expiration is at/before the server started, give it an
        -:  186:           expiration time of 1 second after the server started.
        -:  187:           (because 0 means don't expire).  without this, we'd
        -:  188:           underflow and wrap around to some large value way in the
        -:  189:           future, effectively making items expiring in the past
        -:  190:           really expiring never */
        6:  191:        if (exptime <= process_started)
        -:  192:            return (rel_time_t)1;
        4:  193:        return (rel_time_t)(exptime - process_started);
        -:  194:    } else {
      427:  195:        return (rel_time_t)(exptime + current_time);
        -:  196:    }
        -:  197:}
        -:  198:
       95:  199:static void stats_init(void) {
       95:  200:    memset(&stats, 0, sizeof(struct stats));
       95:  201:    memset(&stats_state, 0, sizeof(struct stats_state));
       95:  202:    stats_state.accepting_conns = true; /* assuming we start in this state. */
        -:  203:
        -:  204:    /* make the time we started always be 2 seconds before we really
        -:  205:       did, so time(0) - time.started is never zero.  if so, things
        -:  206:       like 'settings.oldest_live' which act as booleans as well as
        -:  207:       values are now false in boolean context... */
       95:  208:    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
       95:  209:    stats_prefix_init();
       95:  210:}
        -:  211:
        3:  212:static void stats_reset(void) {
        3:  213:    STATS_LOCK();
        3:  214:    memset(&stats, 0, sizeof(struct stats));
        3:  215:    stats_prefix_clear();
        3:  216:    STATS_UNLOCK();
        3:  217:    threadlocal_stats_reset();
        3:  218:    item_stats_reset();
        3:  219:}
        -:  220:
      119:  221:static void settings_init(void) {
      119:  222:    settings.use_cas = true;
      119:  223:    settings.access = 0700;
      119:  224:    settings.port = 11211;
      119:  225:    settings.udpport = 0;
        -:  226:    /* By default this string should be NULL for getaddrinfo() */
      119:  227:    settings.inter = NULL;
      119:  228:    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
      119:  229:    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
      119:  230:    settings.verbose = 0;
      119:  231:    settings.oldest_live = 0;
      119:  232:    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */
      119:  233:    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
      119:  234:    settings.socketpath = NULL;       /* by default, not using a unix socket */
      119:  235:    settings.factor = 1.25;
      119:  236:    settings.chunk_size = 48;         /* space for a modest key and value */
      119:  237:    settings.num_threads = 4;         /* N workers */
      119:  238:    settings.num_threads_per_udp = 0;
      119:  239:    settings.prefix_delimiter = ':';
      119:  240:    settings.detail_enabled = 0;
      119:  241:    settings.reqs_per_event = 20;
      119:  242:    settings.backlog = 1024;
      119:  243:    settings.binding_protocol = negotiating_prot;
      119:  244:    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
      119:  245:    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */
      119:  246:    settings.slab_chunk_size_max = settings.slab_page_size / 2;
      119:  247:    settings.sasl = false;
      119:  248:    settings.maxconns_fast = true;
      119:  249:    settings.lru_crawler = false;
      119:  250:    settings.lru_crawler_sleep = 100;
      119:  251:    settings.lru_crawler_tocrawl = 0;
      119:  252:    settings.lru_maintainer_thread = false;
      119:  253:    settings.lru_segmented = true;
      119:  254:    settings.hot_lru_pct = 20;
      119:  255:    settings.warm_lru_pct = 40;
      119:  256:    settings.hot_max_factor = 0.2;
      119:  257:    settings.warm_max_factor = 2.0;
      119:  258:    settings.inline_ascii_response = false;
      119:  259:    settings.temp_lru = false;
      119:  260:    settings.temporary_ttl = 61;
      119:  261:    settings.idle_timeout = 0; /* disabled */
      119:  262:    settings.hashpower_init = 0;
      119:  263:    settings.slab_reassign = true;
      119:  264:    settings.slab_automove = 1;
      119:  265:    settings.slab_automove_ratio = 0.8;
      119:  266:    settings.slab_automove_window = 30;
      119:  267:    settings.shutdown_command = false;
      119:  268:    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;
      119:  269:    settings.flush_enabled = true;
      119:  270:    settings.dump_enabled = true;
      119:  271:    settings.crawls_persleep = 1000;
      119:  272:    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;
      119:  273:    settings.logger_buf_size = LOGGER_BUF_SIZE;
      119:  274:    settings.drop_privileges = false;
        -:  275:#ifdef MEMCACHED_DEBUG
      119:  276:    settings.relaxed_privileges = false;
        -:  277:#endif
      119:  278:}
        -:  279:
        -:  280:/*
        -:  281: * Adds a message header to a connection.
        -:  282: *
        -:  283: * Returns 0 on success, -1 on out-of-memory.
        -:  284: */
   250149:  285:static int add_msghdr(conn *c)
        -:  286:{
        -:  287:    struct msghdr *msg;
        -:  288:
   250149:  289:    assert(c != NULL);
        -:  290:
   250149:  291:    if (c->msgsize == c->msgused) {
    #####:  292:        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
    #####:  293:        if (! msg) {
    #####:  294:            STATS_LOCK();
    #####:  295:            stats.malloc_fails++;
    #####:  296:            STATS_UNLOCK();
    #####:  297:            return -1;
        -:  298:        }
    #####:  299:        c->msglist = msg;
    #####:  300:        c->msgsize *= 2;
        -:  301:    }
        -:  302:
   250149:  303:    msg = c->msglist + c->msgused;
        -:  304:
        -:  305:    /* this wipes msg_iovlen, msg_control, msg_controllen, and
        -:  306:       msg_flags, the last 3 of which aren't defined on solaris: */
   250149:  307:    memset(msg, 0, sizeof(struct msghdr));
        -:  308:
   250149:  309:    msg->msg_iov = &c->iov[c->iovused];
        -:  310:
   250149:  311:    if (IS_UDP(c->transport) && c->request_addr_size > 0) {
       29:  312:        msg->msg_name = &c->request_addr;
       29:  313:        msg->msg_namelen = c->request_addr_size;
        -:  314:    }
        -:  315:
   250149:  316:    c->msgbytes = 0;
   250149:  317:    c->msgused++;
        -:  318:
   250149:  319:    if (IS_UDP(c->transport)) {
        -:  320:        /* Leave room for the UDP header, which we'll fill in later. */
       29:  321:        return add_iov(c, NULL, UDP_HEADER_SIZE);
        -:  322:    }
        -:  323:
        -:  324:    return 0;
        -:  325:}
        -:  326:
        -:  327:extern pthread_mutex_t conn_lock;
        -:  328:
        -:  329:/* Connection timeout thread bits */
        -:  330:static pthread_t conn_timeout_tid;
        -:  331:
        -:  332:#define CONNS_PER_SLICE 100
        -:  333:#define TIMEOUT_MSG_SIZE (1 + sizeof(int))
        1:  334:static void *conn_timeout_thread(void *arg) {
        -:  335:    int i;
        -:  336:    conn *c;
        -:  337:    char buf[TIMEOUT_MSG_SIZE];
        -:  338:    rel_time_t oldest_last_cmd;
        -:  339:    int sleep_time;
        1:  340:    useconds_t timeslice = 1000000 / (max_fds / CONNS_PER_SLICE);
        -:  341:
        -:  342:    while(1) {
        2:  343:        if (settings.verbose > 2)
    #####:  344:            fprintf(stderr, "idle timeout thread at top of connection list\n");
        -:  345:
        2:  346:        oldest_last_cmd = current_time;
        -:  347:
     2050:  348:        for (i = 0; i < max_fds; i++) {
     2048:  349:            if ((i % CONNS_PER_SLICE) == 0) {
       22:  350:                if (settings.verbose > 2)
    #####:  351:                    fprintf(stderr, "idle timeout thread sleeping for %ulus\n",
        -:  352:                        (unsigned int)timeslice);
       22:  353:                usleep(timeslice);
        -:  354:            }
        -:  355:
     2048:  356:            if (!conns[i])
     2036:  357:                continue;
        -:  358:
       12:  359:            c = conns[i];
        -:  360:
       12:  361:            if (!IS_TCP(c->transport))
        8:  362:                continue;
        -:  363:
        4:  364:            if (c->state != conn_new_cmd && c->state != conn_read)
        2:  365:                continue;
        -:  366:
        2:  367:            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
        1:  368:                buf[0] = 't';
        1:  369:                memcpy(&buf[1], &i, sizeof(int));
        1:  370:                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)
        -:  371:                    != TIMEOUT_MSG_SIZE)
    #####:  372:                    perror("Failed to write timeout to notify pipe");
        -:  373:            } else {
        1:  374:                if (c->last_cmd_time < oldest_last_cmd)
    #####:  375:                    oldest_last_cmd = c->last_cmd_time;
        -:  376:            }
        -:  377:        }
        -:  378:
        -:  379:        /* This is the soonest we could have another connection time out */
        2:  380:        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;
        2:  381:        if (sleep_time <= 0)
    #####:  382:            sleep_time = 1;
        -:  383:
        2:  384:        if (settings.verbose > 2)
    #####:  385:            fprintf(stderr,
        -:  386:                    "idle timeout thread finished pass, sleeping for %ds\n",
        -:  387:                    sleep_time);
        2:  388:        usleep((useconds_t) sleep_time * 1000000);
        1:  389:    }
        -:  390:
        -:  391:    return NULL;
        -:  392:}
        -:  393:
        1:  394:static int start_conn_timeout_thread() {
        -:  395:    int ret;
        -:  396:
        1:  397:    if (settings.idle_timeout == 0)
        -:  398:        return -1;
        -:  399:
        1:  400:    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        -:  401:        conn_timeout_thread, NULL)) != 0) {
    #####:  402:        fprintf(stderr, "Can't create idle connection timeout thread: %s\n",
        -:  403:            strerror(ret));
    #####:  404:        return -1;
        -:  405:    }
        -:  406:
        -:  407:    return 0;
        -:  408:}
        -:  409:
        -:  410:/*
        -:  411: * Initializes the connections array. We don't actually allocate connection
        -:  412: * structures until they're needed, so as to avoid wasting memory when the
        -:  413: * maximum connection count is much higher than the actual number of
        -:  414: * connections.
        -:  415: *
        -:  416: * This does end up wasting a few pointers' worth of memory for FDs that are
        -:  417: * used for things other than connections, but that's worth it in exchange for
        -:  418: * being able to directly index the conns array by FD.
        -:  419: */
       95:  420:static void conn_init(void) {
        -:  421:    /* We're unlikely to see an FD much higher than maxconns. */
       95:  422:    int next_fd = dup(1);
       95:  423:    int headroom = 10;      /* account for extra unexpected open FDs */
        -:  424:    struct rlimit rl;
        -:  425:
       95:  426:    max_fds = settings.maxconns + headroom + next_fd;
        -:  427:
        -:  428:    /* But if possible, get the actual highest FD we can possibly ever see. */
       95:  429:    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
       95:  430:        max_fds = rl.rlim_max;
        -:  431:    } else {
    #####:  432:        fprintf(stderr, "Failed to query maximum file descriptor; "
        -:  433:                        "falling back to maxconns\n");
        -:  434:    }
        -:  435:
       95:  436:    close(next_fd);
        -:  437:
       95:  438:    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
    #####:  439:        fprintf(stderr, "Failed to allocate connection structures\n");
        -:  440:        /* This is unrecoverable so bail out early. */
    #####:  441:        exit(1);
        -:  442:    }
       95:  443:}
        -:  444:
        -:  445:static const char *prot_text(enum protocol prot) {
       20:  446:    char *rv = "unknown";
        -:  447:    switch(prot) {
        -:  448:        case ascii_prot:
        -:  449:            rv = "ascii";
        -:  450:            break;
        -:  451:        case binary_prot:
        -:  452:            rv = "binary";
        -:  453:            break;
        -:  454:        case negotiating_prot:
        -:  455:            rv = "auto-negotiate";
        -:  456:            break;
        -:  457:    }
        -:  458:    return rv;
        -:  459:}
        -:  460:
        1:  461:void conn_close_idle(conn *c) {
        2:  462:    if (settings.idle_timeout > 0 &&
        1:  463:        (current_time - c->last_cmd_time) > settings.idle_timeout) {
        1:  464:        if (c->state != conn_new_cmd && c->state != conn_read) {
    #####:  465:            if (settings.verbose > 1)
    #####:  466:                fprintf(stderr,
        -:  467:                    "fd %d wants to timeout, but isn't in read state", c->sfd);
        -:  468:            return;
        -:  469:        }
        -:  470:
        1:  471:        if (settings.verbose > 1)
    #####:  472:            fprintf(stderr, "Closing idle fd %d\n", c->sfd);
        -:  473:
        1:  474:        c->thread->stats.idle_kicks++;
        -:  475:
        1:  476:        conn_set_state(c, conn_closing);
        1:  477:        drive_machine(c);
        -:  478:    }
        -:  479:}
        -:  480:
        -:  481:/* bring conn back from a sidethread. could have had its event base moved. */
        1:  482:void conn_worker_readd(conn *c) {
        1:  483:    c->ev_flags = EV_READ | EV_PERSIST;
        1:  484:    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
        1:  485:    event_base_set(c->thread->base, &c->event);
        1:  486:    c->state = conn_new_cmd;
        -:  487:
        -:  488:    // TODO: call conn_cleanup/fail/etc
        1:  489:    if (event_add(&c->event, 0) == -1) {
    #####:  490:        perror("event_add");
        -:  491:    }
        -:  492:#ifdef EXTSTORE
        -:  493:    // If we had IO objects, process
        -:  494:    if (c->io_wraplist) {
        -:  495:        //assert(c->io_wrapleft == 0); // assert no more to process
        -:  496:        conn_set_state(c, conn_mwrite);
        -:  497:        drive_machine(c);
        -:  498:    }
        -:  499:#endif
        1:  500:}
        -:  501:
      286:  502:conn *conn_new(const int sfd, enum conn_states init_state,
        -:  503:                const int event_flags,
        -:  504:                const int read_buffer_size, enum network_transport transport,
        -:  505:                struct event_base *base) {
        -:  506:    conn *c;
        -:  507:
      286:  508:    assert(sfd >= 0 && sfd < max_fds);
      287:  509:    c = conns[sfd];
        -:  510:
      287:  511:    if (NULL == c) {
      277:  512:        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
    #####:  513:            STATS_LOCK();
    #####:  514:            stats.malloc_fails++;
    #####:  515:            STATS_UNLOCK();
    #####:  516:            fprintf(stderr, "Failed to allocate connection object\n");
    #####:  517:            return NULL;
        -:  518:        }
        -:  519:        MEMCACHED_CONN_CREATE(c);
        -:  520:
      277:  521:        c->rbuf = c->wbuf = 0;
      277:  522:        c->ilist = 0;
      277:  523:        c->suffixlist = 0;
      277:  524:        c->iov = 0;
      277:  525:        c->msglist = 0;
      277:  526:        c->hdrbuf = 0;
        -:  527:
      277:  528:        c->rsize = read_buffer_size;
      277:  529:        c->wsize = DATA_BUFFER_SIZE;
      277:  530:        c->isize = ITEM_LIST_INITIAL;
      277:  531:        c->suffixsize = SUFFIX_LIST_INITIAL;
      277:  532:        c->iovsize = IOV_LIST_INITIAL;
      277:  533:        c->msgsize = MSG_LIST_INITIAL;
      277:  534:        c->hdrsize = 0;
        -:  535:
      277:  536:        c->rbuf = (char *)malloc((size_t)c->rsize);
      277:  537:        c->wbuf = (char *)malloc((size_t)c->wsize);
      277:  538:        c->ilist = (item **)malloc(sizeof(item *) * c->isize);
      277:  539:        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);
      277:  540:        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);
      277:  541:        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);
        -:  542:
      277:  543:        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
      281:  544:                c->msglist == 0 || c->suffixlist == 0) {
       -4:  545:            conn_free(c);
    #####:  546:            STATS_LOCK();
    #####:  547:            stats.malloc_fails++;
    #####:  548:            STATS_UNLOCK();
    #####:  549:            fprintf(stderr, "Failed to allocate buffers for connection\n");
    #####:  550:            return NULL;
        -:  551:        }
        -:  552:
      281:  553:        STATS_LOCK();
      281:  554:        stats_state.conn_structs++;
      281:  555:        STATS_UNLOCK();
        -:  556:
      281:  557:        c->sfd = sfd;
      281:  558:        conns[sfd] = c;
        -:  559:    }
        -:  560:
      291:  561:    c->transport = transport;
      291:  562:    c->protocol = settings.binding_protocol;
        -:  563:
        -:  564:    /* unix socket mode doesn't need this, so zeroed out.  but why
        -:  565:     * is this done for every command?  presumably for UDP
        -:  566:     * mode.  */
      291:  567:    if (!settings.socketpath) {
      126:  568:        c->request_addr_size = sizeof(c->request_addr);
        -:  569:    } else {
      165:  570:        c->request_addr_size = 0;
        -:  571:    }
        -:  572:
      291:  573:    if (transport == tcp_transport && init_state == conn_new_cmd) {
       20:  574:        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
        -:  575:                        &c->request_addr_size)) {
    #####:  576:            perror("getpeername");
    #####:  577:            memset(&c->request_addr, 0, sizeof(c->request_addr));
        -:  578:        }
        -:  579:    }
        -:  580:
      291:  581:    if (settings.verbose > 1) {
        6:  582:        if (init_state == conn_listening) {
        6:  583:            fprintf(stderr, "<%d server listening (%s)\n", sfd,
        -:  584:                prot_text(c->protocol));
        3:  585:        } else if (IS_UDP(transport)) {
    #####:  586:            fprintf(stderr, "<%d server listening (udp)\n", sfd);
        3:  587:        } else if (c->protocol == negotiating_prot) {
        1:  588:            fprintf(stderr, "<%d new auto-negotiating client connection\n",
        -:  589:                    sfd);
        2:  590:        } else if (c->protocol == ascii_prot) {
        1:  591:            fprintf(stderr, "<%d new ascii client connection.\n", sfd);
        1:  592:        } else if (c->protocol == binary_prot) {
        1:  593:            fprintf(stderr, "<%d new binary client connection.\n", sfd);
        -:  594:        } else {
    #####:  595:            fprintf(stderr, "<%d new unknown (%d) client connection\n",
        -:  596:                sfd, c->protocol);
    #####:  597:            assert(false);
        -:  598:        }
        -:  599:    }
        -:  600:
      291:  601:    c->state = init_state;
      291:  602:    c->rlbytes = 0;
      291:  603:    c->cmd = -1;
      291:  604:    c->rbytes = c->wbytes = 0;
      291:  605:    c->wcurr = c->wbuf;
      291:  606:    c->rcurr = c->rbuf;
      291:  607:    c->ritem = 0;
      291:  608:    c->icurr = c->ilist;
      291:  609:    c->suffixcurr = c->suffixlist;
      291:  610:    c->ileft = 0;
      291:  611:    c->suffixleft = 0;
      291:  612:    c->iovused = 0;
      291:  613:    c->msgcurr = 0;
      291:  614:    c->msgused = 0;
      291:  615:    c->sasl_started = false;
      291:  616:    c->authenticated = false;
      291:  617:    c->last_cmd_time = current_time; /* initialize for idle kicker */
        -:  618:#ifdef EXTSTORE
        -:  619:    c->io_wraplist = NULL;
        -:  620:    c->io_wrapleft = 0;
        -:  621:#endif
        -:  622:
      291:  623:    c->write_and_go = init_state;
      291:  624:    c->write_and_free = 0;
      291:  625:    c->item = 0;
        -:  626:
      291:  627:    c->noreply = false;
        -:  628:
      291:  629:    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
      291:  630:    event_base_set(base, &c->event);
      291:  631:    c->ev_flags = event_flags;
        -:  632:
      291:  633:    if (event_add(&c->event, 0) == -1) {
    #####:  634:        perror("event_add");
    #####:  635:        return NULL;
        -:  636:    }
        -:  637:
      289:  638:    STATS_LOCK();
      291:  639:    stats_state.curr_conns++;
      291:  640:    stats.total_conns++;
      291:  641:    STATS_UNLOCK();
        -:  642:
        -:  643:    MEMCACHED_CONN_ALLOCATE(c->sfd);
        -:  644:
      291:  645:    return c;
        -:  646:}
        -:  647:#ifdef EXTSTORE
        -:  648:static void recache_or_free(conn *c, io_wrap *wrap) {
        -:  649:    item *it;
        -:  650:    it = (item *)wrap->io.buf;
        -:  651:    bool do_free = true;
        -:  652:    if (wrap->active) {
        -:  653:        // If request never dispatched, free the read buffer but leave the
        -:  654:        // item header alone.
        -:  655:        do_free = false;
        -:  656:        size_t ntotal = ITEM_ntotal(wrap->hdr_it);
        -:  657:        slabs_free(it, ntotal, slabs_clsid(ntotal));
        -:  658:        c->io_wrapleft--;
        -:  659:        assert(c->io_wrapleft >= 0);
        -:  660:        pthread_mutex_lock(&c->thread->stats.mutex);
        -:  661:        c->thread->stats.get_aborted_extstore++;
        -:  662:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  663:    } else if (wrap->miss) {
        -:  664:        // If request was ultimately a miss, unlink the header.
        -:  665:        do_free = false;
        -:  666:        size_t ntotal = ITEM_ntotal(wrap->hdr_it);
        -:  667:        item_unlink(wrap->hdr_it);
        -:  668:        slabs_free(it, ntotal, slabs_clsid(ntotal));
        -:  669:        pthread_mutex_lock(&c->thread->stats.mutex);
        -:  670:        c->thread->stats.miss_from_extstore++;
        -:  671:        if (wrap->badcrc)
        -:  672:            c->thread->stats.badcrc_from_extstore++;
        -:  673:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  674:    } else if (settings.ext_recache_rate) {
        -:  675:        // hashvalue is cuddled during store
        -:  676:        uint32_t hv = (uint32_t)it->time;
        -:  677:        // opt to throw away rather than wait on a lock.
        -:  678:        void *hold_lock = item_trylock(hv);
        -:  679:        if (hold_lock != NULL) {
        -:  680:            item *h_it = wrap->hdr_it;
        -:  681:            uint8_t flags = ITEM_LINKED|ITEM_FETCHED|ITEM_ACTIVE;
        -:  682:            // Item must be recently hit at least twice to recache.
        -:  683:            if (((h_it->it_flags & flags) == flags) &&
        -:  684:                    h_it->time > current_time - ITEM_UPDATE_INTERVAL &&
        -:  685:                    c->recache_counter++ % settings.ext_recache_rate == 0) {
        -:  686:                do_free = false;
        -:  687:                // In case it's been updated.
        -:  688:                it->exptime = h_it->exptime;
        -:  689:                it->it_flags &= ~ITEM_LINKED;
        -:  690:                it->refcount = 0;
        -:  691:                it->h_next = NULL; // might not be necessary.
        -:  692:                STORAGE_delete(c->thread->storage, h_it);
        -:  693:                item_replace(h_it, it, hv);
        -:  694:                pthread_mutex_lock(&c->thread->stats.mutex);
        -:  695:                c->thread->stats.recache_from_extstore++;
        -:  696:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  697:            }
        -:  698:        }
        -:  699:        if (hold_lock)
        -:  700:            item_trylock_unlock(hold_lock);
        -:  701:    }
        -:  702:    if (do_free)
        -:  703:        slabs_free(it, ITEM_ntotal(it), ITEM_clsid(it));
        -:  704:
        -:  705:    wrap->io.buf = NULL; // sanity.
        -:  706:    wrap->io.next = NULL;
        -:  707:    wrap->next = NULL;
        -:  708:    wrap->active = false;
        -:  709:
        -:  710:    // TODO: reuse lock and/or hv.
        -:  711:    item_remove(wrap->hdr_it);
        -:  712:}
        -:  713:#endif
   117261:  714:static void conn_release_items(conn *c) {
   117261:  715:    assert(c != NULL);
        -:  716:
   117261:  717:    if (c->item) {
      788:  718:        item_remove(c->item);
      788:  719:        c->item = 0;
        -:  720:    }
        -:  721:
   148699:  722:    while (c->ileft > 0) {
    31438:  723:        item *it = *(c->icurr);
    31438:  724:        assert((it->it_flags & ITEM_SLABBED) == 0);
    31438:  725:        item_remove(it);
    31438:  726:        c->icurr++;
    31438:  727:        c->ileft--;
        -:  728:    }
        -:  729:
   117261:  730:    if (c->suffixleft != 0) {
    31371:  731:        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
    31371:  732:            do_cache_free(c->thread->suffix_cache, *(c->suffixcurr));
        -:  733:        }
        -:  734:    }
        -:  735:#ifdef EXTSTORE
        -:  736:    if (c->io_wraplist) {
        -:  737:        io_wrap *tmp = c->io_wraplist;
        -:  738:        while (tmp) {
        -:  739:            io_wrap *next = tmp->next;
        -:  740:            recache_or_free(c, tmp);
        -:  741:            do_cache_free(c->thread->io_cache, tmp); // lockless
        -:  742:            tmp = next;
        -:  743:        }
        -:  744:        c->io_wraplist = NULL;
        -:  745:    }
        -:  746:#endif
   117261:  747:    c->icurr = c->ilist;
   117261:  748:    c->suffixcurr = c->suffixlist;
   117261:  749:}
        -:  750:
       98:  751:static void conn_cleanup(conn *c) {
       98:  752:    assert(c != NULL);
        -:  753:
       98:  754:    conn_release_items(c);
        -:  755:
       98:  756:    if (c->write_and_free) {
        2:  757:        free(c->write_and_free);
        2:  758:        c->write_and_free = 0;
        -:  759:    }
        -:  760:
       98:  761:    if (c->sasl_conn) {
    #####:  762:        assert(settings.sasl);
        -:  763:        sasl_dispose(&c->sasl_conn);
    #####:  764:        c->sasl_conn = NULL;
        -:  765:    }
        -:  766:
       98:  767:    if (IS_UDP(c->transport)) {
    #####:  768:        conn_set_state(c, conn_read);
        -:  769:    }
       98:  770:}
        -:  771:
        -:  772:/*
        -:  773: * Frees a connection.
        -:  774: */
    #####:  775:void conn_free(conn *c) {
    #####:  776:    if (c) {
    #####:  777:        assert(c != NULL);
    #####:  778:        assert(c->sfd >= 0 && c->sfd < max_fds);
        -:  779:
        -:  780:        MEMCACHED_CONN_DESTROY(c);
    #####:  781:        conns[c->sfd] = NULL;
    #####:  782:        if (c->hdrbuf)
    #####:  783:            free(c->hdrbuf);
    #####:  784:        if (c->msglist)
    #####:  785:            free(c->msglist);
    #####:  786:        if (c->rbuf)
    #####:  787:            free(c->rbuf);
    #####:  788:        if (c->wbuf)
    #####:  789:            free(c->wbuf);
    #####:  790:        if (c->ilist)
    #####:  791:            free(c->ilist);
    #####:  792:        if (c->suffixlist)
    #####:  793:            free(c->suffixlist);
    #####:  794:        if (c->iov)
    #####:  795:            free(c->iov);
    #####:  796:        free(c);
        -:  797:    }
    #####:  798:}
        -:  799:
       98:  800:static void conn_close(conn *c) {
       98:  801:    assert(c != NULL);
        -:  802:
        -:  803:    /* delete the event, the socket and the conn */
       98:  804:    event_del(&c->event);
        -:  805:
       98:  806:    if (settings.verbose > 1)
        3:  807:        fprintf(stderr, "<%d connection closed.\n", c->sfd);
        -:  808:
       98:  809:    conn_cleanup(c);
        -:  810:
        -:  811:    MEMCACHED_CONN_RELEASE(c->sfd);
       98:  812:    conn_set_state(c, conn_closed);
       98:  813:    close(c->sfd);
        -:  814:
       98:  815:    pthread_mutex_lock(&conn_lock);
       98:  816:    allow_new_conns = true;
       98:  817:    pthread_mutex_unlock(&conn_lock);
        -:  818:
       98:  819:    STATS_LOCK();
       98:  820:    stats_state.curr_conns--;
       98:  821:    STATS_UNLOCK();
        -:  822:
       98:  823:    return;
        -:  824:}
        -:  825:
        -:  826:/*
        -:  827: * Shrinks a connection's buffers if they're too big.  This prevents
        -:  828: * periodic large "get" requests from permanently chewing lots of server
        -:  829: * memory.
        -:  830: *
        -:  831: * This should only be called in between requests since it can wipe output
        -:  832: * buffers!
        -:  833: */
   225565:  834:static void conn_shrink(conn *c) {
   225565:  835:    assert(c != NULL);
        -:  836:
   225565:  837:    if (IS_UDP(c->transport))
        -:  838:        return;
        -:  839:
   225548:  840:    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
        -:  841:        char *newbuf;
        -:  842:
    12675:  843:        if (c->rcurr != c->rbuf)
    12675:  844:            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);
        -:  845:
    12675:  846:        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);
        -:  847:
    12675:  848:        if (newbuf) {
    12675:  849:            c->rbuf = newbuf;
    12675:  850:            c->rsize = DATA_BUFFER_SIZE;
        -:  851:        }
        -:  852:        /* TODO check other branch... */
    12675:  853:        c->rcurr = c->rbuf;
        -:  854:    }
        -:  855:
   225548:  856:    if (c->isize > ITEM_LIST_HIGHWAT) {
    #####:  857:        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
    #####:  858:        if (newbuf) {
    #####:  859:            c->ilist = newbuf;
    #####:  860:            c->isize = ITEM_LIST_INITIAL;
        -:  861:        }
        -:  862:    /* TODO check error condition? */
        -:  863:    }
        -:  864:
   225548:  865:    if (c->msgsize > MSG_LIST_HIGHWAT) {
    #####:  866:        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
    #####:  867:        if (newbuf) {
    #####:  868:            c->msglist = newbuf;
    #####:  869:            c->msgsize = MSG_LIST_INITIAL;
        -:  870:        }
        -:  871:    /* TODO check error condition? */
        -:  872:    }
        -:  873:
   225548:  874:    if (c->iovsize > IOV_LIST_HIGHWAT) {
    #####:  875:        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
    #####:  876:        if (newbuf) {
    #####:  877:            c->iov = newbuf;
    #####:  878:            c->iovsize = IOV_LIST_INITIAL;
        -:  879:        }
        -:  880:    /* TODO check return value */
        -:  881:    }
        -:  882:}
        -:  883:
        -:  884:/**
        -:  885: * Convert a state name to a human readable form.
        -:  886: */
        -:  887:static const char *state_text(enum conn_states state) {
       10:  888:    const char* const statenames[] = { "conn_listening",
        -:  889:                                       "conn_new_cmd",
        -:  890:                                       "conn_waiting",
        -:  891:                                       "conn_read",
        -:  892:                                       "conn_parse_cmd",
        -:  893:                                       "conn_write",
        -:  894:                                       "conn_nread",
        -:  895:                                       "conn_swallow",
        -:  896:                                       "conn_closing",
        -:  897:                                       "conn_mwrite",
        -:  898:                                       "conn_closed",
        -:  899:                                       "conn_watch" };
       10:  900:    return statenames[state];
        -:  901:}
        -:  902:
        -:  903:/*
        -:  904: * Sets a connection's current state in the state machine. Any special
        -:  905: * processing that needs to happen on certain state transitions can
        -:  906: * happen here.
        -:  907: */
  1028222:  908:static void conn_set_state(conn *c, enum conn_states state) {
  1028222:  909:    assert(c != NULL);
  1028222:  910:    assert(state >= conn_listening && state < conn_max_state);
        -:  911:
  1028222:  912:    if (state != c->state) {
  1007916:  913:        if (settings.verbose > 2) {
    #####:  914:            fprintf(stderr, "%d: going from %s to %s\n",
        -:  915:                    c->sfd, state_text(c->state),
        -:  916:                    state_text(state));
        -:  917:        }
        -:  918:
        -:  919:        if (state == conn_write || state == conn_mwrite) {
        -:  920:            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
        -:  921:        }
  1007916:  922:        c->state = state;
        -:  923:    }
  1028222:  924:}
        -:  925:
        -:  926:/*
        -:  927: * Ensures that there is room for another struct iovec in a connection's
        -:  928: * iov list.
        -:  929: *
        -:  930: * Returns 0 on success, -1 on out-of-memory.
        -:  931: */
   389199:  932:static int ensure_iov_space(conn *c) {
   389199:  933:    assert(c != NULL);
        -:  934:
   389199:  935:    if (c->iovused >= c->iovsize) {
        -:  936:        int i, iovnum;
    #####:  937:        struct iovec *new_iov = (struct iovec *)realloc(c->iov,
    #####:  938:                                (c->iovsize * 2) * sizeof(struct iovec));
    #####:  939:        if (! new_iov) {
    #####:  940:            STATS_LOCK();
    #####:  941:            stats.malloc_fails++;
    #####:  942:            STATS_UNLOCK();
    #####:  943:            return -1;
        -:  944:        }
    #####:  945:        c->iov = new_iov;
    #####:  946:        c->iovsize *= 2;
        -:  947:
        -:  948:        /* Point all the msghdr structures at the new list. */
    #####:  949:        for (i = 0, iovnum = 0; i < c->msgused; i++) {
    #####:  950:            c->msglist[i].msg_iov = &c->iov[iovnum];
    #####:  951:            iovnum += c->msglist[i].msg_iovlen;
        -:  952:        }
        -:  953:    }
        -:  954:
        -:  955:    return 0;
        -:  956:}
        -:  957:
        -:  958:
        -:  959:/*
        -:  960: * Adds data to the list of pending data that will be written out to a
        -:  961: * connection.
        -:  962: *
        -:  963: * Returns 0 on success, -1 on out-of-memory.
        -:  964: * Note: This is a hot path for at least ASCII protocol. While there is
        -:  965: * redundant code in splitting TCP/UDP handling, any reduction in steps has a
        -:  966: * large impact for TCP connections.
        -:  967: */
        -:  968:
   389199:  969:static int add_iov(conn *c, const void *buf, int len) {
        -:  970:    struct msghdr *m;
        -:  971:    int leftover;
        -:  972:
   389199:  973:    assert(c != NULL);
        -:  974:
   389199:  975:    if (IS_UDP(c->transport)) {
        -:  976:        do {
       67:  977:            m = &c->msglist[c->msgused - 1];
        -:  978:
        -:  979:            /*
        -:  980:             * Limit UDP packets to UDP_MAX_PAYLOAD_SIZE bytes.
        -:  981:             */
        -:  982:
        -:  983:            /* We may need to start a new msghdr if this one is full. */
      134:  984:            if (m->msg_iovlen == IOV_MAX ||
       67:  985:                (c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {
    #####:  986:                add_msghdr(c);
    #####:  987:                m = &c->msglist[c->msgused - 1];
        -:  988:            }
        -:  989:
       67:  990:            if (ensure_iov_space(c) != 0)
        -:  991:                return -1;
        -:  992:
        -:  993:            /* If the fragment is too big to fit in the datagram, split it up */
       67:  994:            if (len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
    #####:  995:                leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
    #####:  996:                len -= leftover;
        -:  997:            } else {
        -:  998:                leftover = 0;
        -:  999:            }
        -: 1000:
       67: 1001:            m = &c->msglist[c->msgused - 1];
       67: 1002:            m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
       67: 1003:            m->msg_iov[m->msg_iovlen].iov_len = len;
        -: 1004:
       67: 1005:            c->msgbytes += len;
       67: 1006:            c->iovused++;
       67: 1007:            m->msg_iovlen++;
        -: 1008:
       67: 1009:            buf = ((char *)buf) + len;
       67: 1010:            len = leftover;
       67: 1011:        } while (leftover > 0);
        -: 1012:    } else {
        -: 1013:        /* Optimized path for TCP connections */
   389132: 1014:        m = &c->msglist[c->msgused - 1];
   389132: 1015:        if (m->msg_iovlen == IOV_MAX) {
    #####: 1016:            add_msghdr(c);
    #####: 1017:            m = &c->msglist[c->msgused - 1];
        -: 1018:        }
        -: 1019:
   389132: 1020:        if (ensure_iov_space(c) != 0)
        -: 1021:            return -1;
        -: 1022:
   389132: 1023:        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
   389132: 1024:        m->msg_iov[m->msg_iovlen].iov_len = len;
   389132: 1025:        c->msgbytes += len;
   389132: 1026:        c->iovused++;
   389132: 1027:        m->msg_iovlen++;
        -: 1028:    }
        -: 1029:
        -: 1030:    return 0;
        -: 1031:}
        -: 1032:
    18597: 1033:static int add_chunked_item_iovs(conn *c, item *it, int len) {
    18597: 1034:    assert(it->it_flags & ITEM_CHUNKED);
    18597: 1035:    item_chunk *ch = (item_chunk *) ITEM_schunk(it);
   174277: 1036:    while (ch) {
   137083: 1037:        int todo = (len > ch->used) ? ch->used : len;
   137083: 1038:        if (add_iov(c, ch->data, todo) != 0) {
        -: 1039:            return -1;
        -: 1040:        }
   137083: 1041:        ch = ch->next;
   137083: 1042:        len -= todo;
        -: 1043:    }
        -: 1044:    return 0;
        -: 1045:}
        -: 1046:
        -: 1047:/*
        -: 1048: * Constructs a set of UDP headers and attaches them to the outgoing messages.
        -: 1049: */
       39: 1050:static int build_udp_headers(conn *c) {
        -: 1051:    int i;
        -: 1052:    unsigned char *hdr;
        -: 1053:
       39: 1054:    assert(c != NULL);
        -: 1055:
       39: 1056:    if (c->msgused > c->hdrsize) {
        -: 1057:        void *new_hdrbuf;
        3: 1058:        if (c->hdrbuf) {
    #####: 1059:            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1060:        } else {
        3: 1061:            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1062:        }
        -: 1063:
        3: 1064:        if (! new_hdrbuf) {
    #####: 1065:            STATS_LOCK();
    #####: 1066:            stats.malloc_fails++;
    #####: 1067:            STATS_UNLOCK();
    #####: 1068:            return -1;
        -: 1069:        }
        3: 1070:        c->hdrbuf = (unsigned char *)new_hdrbuf;
        3: 1071:        c->hdrsize = c->msgused * 2;
        -: 1072:    }
        -: 1073:
       39: 1074:    hdr = c->hdrbuf;
       78: 1075:    for (i = 0; i < c->msgused; i++) {
       39: 1076:        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;
       39: 1077:        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;
       39: 1078:        *hdr++ = c->request_id / 256;
       39: 1079:        *hdr++ = c->request_id % 256;
       39: 1080:        *hdr++ = i / 256;
       39: 1081:        *hdr++ = i % 256;
       39: 1082:        *hdr++ = c->msgused / 256;
       39: 1083:        *hdr++ = c->msgused % 256;
       39: 1084:        *hdr++ = 0;
       39: 1085:        *hdr++ = 0;
       39: 1086:        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);
        -: 1087:    }
        -: 1088:
        -: 1089:    return 0;
        -: 1090:}
        -: 1091:
        -: 1092:
    85527: 1093:static void out_string(conn *c, const char *str) {
        -: 1094:    size_t len;
        -: 1095:
    85527: 1096:    assert(c != NULL);
        -: 1097:
    85527: 1098:    if (c->noreply) {
    65717: 1099:        if (settings.verbose > 1)
    #####: 1100:            fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
    65717: 1101:        c->noreply = false;
    65717: 1102:        conn_set_state(c, conn_new_cmd);
    65717: 1103:        return;
        -: 1104:    }
        -: 1105:
    19810: 1106:    if (settings.verbose > 1)
    #####: 1107:        fprintf(stderr, ">%d %s\n", c->sfd, str);
        -: 1108:
        -: 1109:    /* Nuke a partial output... */
    19810: 1110:    c->msgcurr = 0;
    19810: 1111:    c->msgused = 0;
    19810: 1112:    c->iovused = 0;
    19810: 1113:    add_msghdr(c);
        -: 1114:
    19810: 1115:    len = strlen(str);
    19810: 1116:    if ((len + 2) > c->wsize) {
        -: 1117:        /* ought to be always enough. just fail for simplicity */
    #####: 1118:        str = "SERVER_ERROR output line too long";
    #####: 1119:        len = strlen(str);
        -: 1120:    }
        -: 1121:
    39620: 1122:    memcpy(c->wbuf, str, len);
    39620: 1123:    memcpy(c->wbuf + len, "\r\n", 2);
    19810: 1124:    c->wbytes = len + 2;
    19810: 1125:    c->wcurr = c->wbuf;
        -: 1126:
    19810: 1127:    conn_set_state(c, conn_write);
    19810: 1128:    c->write_and_go = conn_new_cmd;
    19810: 1129:    return;
        -: 1130:}
        -: 1131:
        -: 1132:/*
        -: 1133: * Outputs a protocol-specific "out of memory" error. For ASCII clients,
        -: 1134: * this is equivalent to out_string().
        -: 1135: */
        5: 1136:static void out_of_memory(conn *c, char *ascii_error) {
        -: 1137:    const static char error_prefix[] = "SERVER_ERROR ";
        -: 1138:    const static int error_prefix_len = sizeof(error_prefix) - 1;
        -: 1139:
        5: 1140:    if (c->protocol == binary_prot) {
        -: 1141:        /* Strip off the generic error prefix; it's irrelevant in binary */
    #####: 1142:        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
    #####: 1143:            ascii_error += error_prefix_len;
        -: 1144:        }
    #####: 1145:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
        -: 1146:    } else {
        5: 1147:        out_string(c, ascii_error);
        -: 1148:    }
        5: 1149:}
        -: 1150:
        -: 1151:/*
        -: 1152: * we get here after reading the value in set/add/replace commands. The command
        -: 1153: * has been stored in c->cmd, and the item is ready in c->item.
        -: 1154: */
    82525: 1155:static void complete_nread_ascii(conn *c) {
    82525: 1156:    assert(c != NULL);
        -: 1157:
    82525: 1158:    item *it = c->item;
    82525: 1159:    int comm = c->cmd;
        -: 1160:    enum store_item_type ret;
    82525: 1161:    bool is_valid = false;
        -: 1162:
    82525: 1163:    pthread_mutex_lock(&c->thread->stats.mutex);
    82525: 1164:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    82525: 1165:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1166:
    82525: 1167:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    76609: 1168:        if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) == 0) {
    76609: 1169:            is_valid = true;
        -: 1170:        }
        -: 1171:    } else {
        -: 1172:        char buf[2];
        -: 1173:        /* should point to the final item chunk */
     5916: 1174:        item_chunk *ch = (item_chunk *) c->ritem;
     5916: 1175:        assert(ch->used != 0);
        -: 1176:        /* :( We need to look at the last two bytes. This could span two
        -: 1177:         * chunks.
        -: 1178:         */
     5916: 1179:        if (ch->used > 1) {
     5916: 1180:            buf[0] = ch->data[ch->used - 2];
     5916: 1181:            buf[1] = ch->data[ch->used - 1];
        -: 1182:        } else {
    #####: 1183:            assert(ch->prev);
    #####: 1184:            assert(ch->used == 1);
    #####: 1185:            buf[0] = ch->prev->data[ch->prev->used - 1];
    #####: 1186:            buf[1] = ch->data[ch->used - 1];
        -: 1187:        }
     5916: 1188:        if (strncmp(buf, "\r\n", 2) == 0) {
     5916: 1189:            is_valid = true;
        -: 1190:        } else {
    #####: 1191:            assert(1 == 0);
        -: 1192:        }
        -: 1193:    }
        -: 1194:
    82525: 1195:    if (!is_valid) {
    #####: 1196:        out_string(c, "CLIENT_ERROR bad data chunk");
        -: 1197:    } else {
    82525: 1198:      ret = store_item(it, comm, c);
        -: 1199:
        -: 1200:#ifdef ENABLE_DTRACE
        -: 1201:      uint64_t cas = ITEM_get_cas(it);
        -: 1202:      switch (c->cmd) {
        -: 1203:      case NREAD_ADD:
        -: 1204:          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1205:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1206:          break;
        -: 1207:      case NREAD_REPLACE:
        -: 1208:          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1209:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1210:          break;
        -: 1211:      case NREAD_APPEND:
        -: 1212:          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1213:                                   (ret == 1) ? it->nbytes : -1, cas);
        -: 1214:          break;
        -: 1215:      case NREAD_PREPEND:
        -: 1216:          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1217:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1218:          break;
        -: 1219:      case NREAD_SET:
        -: 1220:          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1221:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1222:          break;
        -: 1223:      case NREAD_CAS:
        -: 1224:          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
        -: 1225:                                cas);
        -: 1226:          break;
        -: 1227:      }
        -: 1228:#endif
        -: 1229:
    82525: 1230:      switch (ret) {
        -: 1231:      case STORED:
    82514: 1232:          out_string(c, "STORED");
    82514: 1233:          break;
        -: 1234:      case EXISTS:
        5: 1235:          out_string(c, "EXISTS");
        5: 1236:          break;
        -: 1237:      case NOT_FOUND:
        2: 1238:          out_string(c, "NOT_FOUND");
        2: 1239:          break;
        -: 1240:      case NOT_STORED:
        4: 1241:          out_string(c, "NOT_STORED");
        4: 1242:          break;
        -: 1243:      default:
    #####: 1244:          out_string(c, "SERVER_ERROR Unhandled storage type.");
        -: 1245:      }
        -: 1246:
        -: 1247:    }
        -: 1248:
    82525: 1249:    item_remove(c->item);       /* release the c->item reference */
    82525: 1250:    c->item = 0;
    82525: 1251:}
        -: 1252:
        -: 1253:/**
        -: 1254: * get a pointer to the start of the request struct for the current command
        -: 1255: */
    20584: 1256:static void* binary_get_request(conn *c) {
    20584: 1257:    char *ret = c->rcurr;
    41168: 1258:    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +
    20584: 1259:            c->binary_header.request.extlen);
        -: 1260:
    20584: 1261:    assert(ret >= c->rbuf);
    20584: 1262:    return ret;
        -: 1263:}
        -: 1264:
        -: 1265:/**
        -: 1266: * get a pointer to the key in this request
        -: 1267: */
        -: 1268:static char* binary_get_key(conn *c) {
    21467: 1269:    return c->rcurr - (c->binary_header.request.keylen);
        -: 1270:}
        -: 1271:
     4869: 1272:static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
        -: 1273:    protocol_binary_response_header* header;
        -: 1274:
     4869: 1275:    assert(c);
        -: 1276:
     4869: 1277:    c->msgcurr = 0;
     4869: 1278:    c->msgused = 0;
     4869: 1279:    c->iovused = 0;
     4869: 1280:    if (add_msghdr(c) != 0) {
        -: 1281:        /* This should never run out of memory because iov and msg lists
        -: 1282:         * have minimum sizes big enough to hold an error response.
        -: 1283:         */
    #####: 1284:        out_of_memory(c, "SERVER_ERROR out of memory adding binary header");
    #####: 1285:        return;
        -: 1286:    }
        -: 1287:
     4869: 1288:    header = (protocol_binary_response_header *)c->wbuf;
        -: 1289:
     4869: 1290:    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
     4869: 1291:    header->response.opcode = c->binary_header.request.opcode;
     4869: 1292:    header->response.keylen = (uint16_t)htons(key_len);
        -: 1293:
     4869: 1294:    header->response.extlen = (uint8_t)hdr_len;
     4869: 1295:    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
     4869: 1296:    header->response.status = (uint16_t)htons(err);
        -: 1297:
     4869: 1298:    header->response.bodylen = htonl(body_len);
     4869: 1299:    header->response.opaque = c->opaque;
     4869: 1300:    header->response.cas = htonll(c->cas);
        -: 1301:
     4869: 1302:    if (settings.verbose > 1) {
        -: 1303:        int ii;
    #####: 1304:        fprintf(stderr, ">%d Writing bin response:", c->sfd);
    #####: 1305:        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
    #####: 1306:            if (ii % 4 == 0) {
    #####: 1307:                fprintf(stderr, "\n>%d  ", c->sfd);
        -: 1308:            }
    #####: 1309:            fprintf(stderr, " 0x%02x", header->bytes[ii]);
        -: 1310:        }
    #####: 1311:        fprintf(stderr, "\n");
        -: 1312:    }
        -: 1313:
     4869: 1314:    add_iov(c, c->wbuf, sizeof(header->response));
        -: 1315:}
        -: 1316:
        -: 1317:/**
        -: 1318: * Writes a binary error response. If errstr is supplied, it is used as the
        -: 1319: * error text; otherwise a generic description of the error status code is
        -: 1320: * included.
        -: 1321: */
     3596: 1322:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -: 1323:                            const char *errstr, int swallow) {
        -: 1324:    size_t len;
        -: 1325:
     3596: 1326:    if (!errstr) {
     3596: 1327:        switch (err) {
        -: 1328:        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
        -: 1329:            errstr = "Out of memory";
        -: 1330:            break;
        -: 1331:        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
     3386: 1332:            errstr = "Unknown command";
     3386: 1333:            break;
        -: 1334:        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
      135: 1335:            errstr = "Not found";
      135: 1336:            break;
        -: 1337:        case PROTOCOL_BINARY_RESPONSE_EINVAL:
        1: 1338:            errstr = "Invalid arguments";
        1: 1339:            break;
        -: 1340:        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
       22: 1341:            errstr = "Data exists for key.";
       22: 1342:            break;
        -: 1343:        case PROTOCOL_BINARY_RESPONSE_E2BIG:
        2: 1344:            errstr = "Too large.";
        2: 1345:            break;
        -: 1346:        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
        3: 1347:            errstr = "Non-numeric server-side value for incr or decr";
        3: 1348:            break;
        -: 1349:        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
       47: 1350:            errstr = "Not stored.";
       47: 1351:            break;
        -: 1352:        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
    #####: 1353:            errstr = "Auth failure.";
    #####: 1354:            break;
        -: 1355:        default:
    #####: 1356:            assert(false);
        -: 1357:            errstr = "UNHANDLED ERROR";
        -: 1358:            fprintf(stderr, ">%d UNHANDLED ERROR: %d\n", c->sfd, err);
        -: 1359:        }
        -: 1360:    }
        -: 1361:
     3596: 1362:    if (settings.verbose > 1) {
    #####: 1363:        fprintf(stderr, ">%d Writing an error: %s\n", c->sfd, errstr);
        -: 1364:    }
        -: 1365:
     3596: 1366:    len = strlen(errstr);
     3596: 1367:    add_bin_header(c, err, 0, 0, len);
     3596: 1368:    if (len > 0) {
     3596: 1369:        add_iov(c, errstr, len);
        -: 1370:    }
     3596: 1371:    conn_set_state(c, conn_mwrite);
     3596: 1372:    if(swallow > 0) {
        1: 1373:        c->sbytes = swallow;
        1: 1374:        c->write_and_go = conn_swallow;
        -: 1375:    } else {
     3595: 1376:        c->write_and_go = conn_new_cmd;
        -: 1377:    }
     3596: 1378:}
        -: 1379:
        -: 1380:/* Form and send a response to a command over the binary protocol */
    20438: 1381:static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    20438: 1382:    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        -: 1383:        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
      449: 1384:        add_bin_header(c, 0, hlen, keylen, dlen);
      449: 1385:        if(dlen > 0) {
       84: 1386:            add_iov(c, d, dlen);
        -: 1387:        }
      449: 1388:        conn_set_state(c, conn_mwrite);
      449: 1389:        c->write_and_go = conn_new_cmd;
        -: 1390:    } else {
    19989: 1391:        conn_set_state(c, conn_new_cmd);
        -: 1392:    }
    20438: 1393:}
        -: 1394:
      131: 1395:static void complete_incr_bin(conn *c) {
        -: 1396:    item *it;
        -: 1397:    char *key;
        -: 1398:    size_t nkey;
        -: 1399:    /* Weird magic in add_delta forces me to pad here */
        -: 1400:    char tmpbuf[INCR_MAX_STORAGE_LEN];
      131: 1401:    uint64_t cas = 0;
        -: 1402:
      131: 1403:    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;
      131: 1404:    protocol_binary_request_incr* req = binary_get_request(c);
        -: 1405:
      131: 1406:    assert(c != NULL);
      131: 1407:    assert(c->wsize >= sizeof(*rsp));
        -: 1408:
        -: 1409:    /* fix byteorder in the request */
      131: 1410:    req->message.body.delta = ntohll(req->message.body.delta);
      131: 1411:    req->message.body.initial = ntohll(req->message.body.initial);
      262: 1412:    req->message.body.expiration = ntohl(req->message.body.expiration);
      262: 1413:    key = binary_get_key(c);
      131: 1414:    nkey = c->binary_header.request.keylen;
        -: 1415:
      131: 1416:    if (settings.verbose > 1) {
        -: 1417:        int i;
    #####: 1418:        fprintf(stderr, "incr ");
        -: 1419:
    #####: 1420:        for (i = 0; i < nkey; i++) {
    #####: 1421:            fprintf(stderr, "%c", key[i]);
        -: 1422:        }
    #####: 1423:        fprintf(stderr, " %lld, %llu, %d\n",
    #####: 1424:                (long long)req->message.body.delta,
    #####: 1425:                (long long)req->message.body.initial,
        -: 1426:                req->message.body.expiration);
        -: 1427:    }
        -: 1428:
      131: 1429:    if (c->binary_header.request.cas != 0) {
    #####: 1430:        cas = c->binary_header.request.cas;
        -: 1431:    }
      131: 1432:    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,
      131: 1433:                     req->message.body.delta, tmpbuf,
        -: 1434:                     &cas)) {
        -: 1435:    case OK:
       57: 1436:        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
       57: 1437:        if (cas) {
       57: 1438:            c->cas = cas;
        -: 1439:        }
       57: 1440:        write_bin_response(c, &rsp->message.body, 0, 0,
        -: 1441:                           sizeof(rsp->message.body.value));
       57: 1442:        break;
        -: 1443:    case NON_NUMERIC:
        3: 1444:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);
        3: 1445:        break;
        -: 1446:    case EOM:
    #####: 1447:        out_of_memory(c, "SERVER_ERROR Out of memory incrementing value");
    #####: 1448:        break;
        -: 1449:    case DELTA_ITEM_NOT_FOUND:
       71: 1450:        if (req->message.body.expiration != 0xffffffff) {
        -: 1451:            /* Save some room for the response */
       71: 1452:            rsp->message.body.value = htonll(req->message.body.initial);
        -: 1453:
       71: 1454:            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, "%llu",
       71: 1455:                (unsigned long long)req->message.body.initial);
       71: 1456:            int res = strlen(tmpbuf);
      142: 1457:            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
        -: 1458:                            res + 2);
        -: 1459:
       71: 1460:            if (it != NULL) {
      142: 1461:                memcpy(ITEM_data(it), tmpbuf, res);
      142: 1462:                memcpy(ITEM_data(it) + res, "\r\n", 2);
        -: 1463:
       71: 1464:                if (store_item(it, NREAD_ADD, c)) {
       71: 1465:                    c->cas = ITEM_get_cas(it);
       71: 1466:                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
        -: 1467:                } else {
    #####: 1468:                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
        -: 1469:                                    NULL, 0);
        -: 1470:                }
       71: 1471:                item_remove(it);         /* release our reference */
        -: 1472:            } else {
    #####: 1473:                out_of_memory(c,
        -: 1474:                        "SERVER_ERROR Out of memory allocating new item");
        -: 1475:            }
        -: 1476:        } else {
    #####: 1477:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1478:            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
    #####: 1479:                c->thread->stats.incr_misses++;
        -: 1480:            } else {
    #####: 1481:                c->thread->stats.decr_misses++;
        -: 1482:            }
    #####: 1483:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1484:
    #####: 1485:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1486:        }
        -: 1487:        break;
        -: 1488:    case DELTA_ITEM_CAS_MISMATCH:
    #####: 1489:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1490:        break;
        -: 1491:    }
      131: 1492:}
        -: 1493:
    20306: 1494:static void complete_update_bin(conn *c) {
    20306: 1495:    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
    20306: 1496:    enum store_item_type ret = NOT_STORED;
    20306: 1497:    assert(c != NULL);
        -: 1498:
    20306: 1499:    item *it = c->item;
        -: 1500:
    20306: 1501:    pthread_mutex_lock(&c->thread->stats.mutex);
    20306: 1502:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    20306: 1503:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1504:
        -: 1505:    /* We don't actually receive the trailing two characters in the bin
        -: 1506:     * protocol, so we're going to just set them here */
    20306: 1507:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    20105: 1508:        *(ITEM_data(it) + it->nbytes - 2) = '\r';
    20105: 1509:        *(ITEM_data(it) + it->nbytes - 1) = '\n';
        -: 1510:    } else {
      201: 1511:        assert(c->ritem);
      201: 1512:        item_chunk *ch = (item_chunk *) c->ritem;
      201: 1513:        if (ch->size == ch->used)
    #####: 1514:            ch = ch->next;
      201: 1515:        assert(ch->size - ch->used >= 2);
      201: 1516:        ch->data[ch->used] = '\r';
      201: 1517:        ch->data[ch->used + 1] = '\n';
      201: 1518:        ch->used += 2;
        -: 1519:    }
        -: 1520:
    20306: 1521:    ret = store_item(it, c->cmd, c);
        -: 1522:
        -: 1523:#ifdef ENABLE_DTRACE
        -: 1524:    uint64_t cas = ITEM_get_cas(it);
        -: 1525:    switch (c->cmd) {
        -: 1526:    case NREAD_ADD:
        -: 1527:        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1528:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1529:        break;
        -: 1530:    case NREAD_REPLACE:
        -: 1531:        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1532:                                  (ret == STORED) ? it->nbytes : -1, cas);
        -: 1533:        break;
        -: 1534:    case NREAD_APPEND:
        -: 1535:        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1536:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1537:        break;
        -: 1538:    case NREAD_PREPEND:
        -: 1539:        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1540:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1541:        break;
        -: 1542:    case NREAD_SET:
        -: 1543:        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1544:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1545:        break;
        -: 1546:    }
        -: 1547:#endif
        -: 1548:
    20306: 1549:    switch (ret) {
        -: 1550:    case STORED:
        -: 1551:        /* Stored */
    20208: 1552:        write_bin_response(c, NULL, 0, 0, 0);
    20208: 1553:        break;
        -: 1554:    case EXISTS:
        2: 1555:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        2: 1556:        break;
        -: 1557:    case NOT_FOUND:
        1: 1558:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        1: 1559:        break;
        -: 1560:    case NOT_STORED:
        -: 1561:    case TOO_LARGE:
        -: 1562:    case NO_MEMORY:
       95: 1563:        if (c->cmd == NREAD_ADD) {
        -: 1564:            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
       75: 1565:        } else if(c->cmd == NREAD_REPLACE) {
        -: 1566:            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        -: 1567:        } else {
       47: 1568:            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        -: 1569:        }
       95: 1570:        write_bin_error(c, eno, NULL, 0);
        -: 1571:    }
        -: 1572:
    20306: 1573:    item_remove(c->item);       /* release the c->item reference */
    20306: 1574:    c->item = 0;
    20306: 1575:}
        -: 1576:
       37: 1577:static void write_bin_miss_response(conn *c, char *key, size_t nkey) {
       37: 1578:    if (nkey) {
       37: 1579:        char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
       37: 1580:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1581:                0, nkey, nkey);
       37: 1582:        memcpy(ofs, key, nkey);
       37: 1583:        add_iov(c, ofs, nkey);
       37: 1584:        conn_set_state(c, conn_mwrite);
       37: 1585:        c->write_and_go = conn_new_cmd;
        -: 1586:    } else {
       71: 1587:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1588:                        NULL, 0);
        -: 1589:    }
       37: 1590:}
        -: 1591:
      965: 1592:static void process_bin_get_or_touch(conn *c) {
        -: 1593:    item *it;
        -: 1594:
      965: 1595:    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
     1930: 1596:    char* key = binary_get_key(c);
      965: 1597:    size_t nkey = c->binary_header.request.keylen;
     1930: 1598:    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
      965: 1599:                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
        -: 1600:                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
      965: 1601:    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
        -: 1602:                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
      965: 1603:    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
      965: 1604:    bool failed = false;
        -: 1605:
      965: 1606:    if (settings.verbose > 1) {
    #####: 1607:        fprintf(stderr, "<%d %s ", c->sfd, should_touch ? "TOUCH" : "GET");
    #####: 1608:        if (fwrite(key, 1, nkey, stderr)) {}
    #####: 1609:        fputc('\n', stderr);
        -: 1610:    }
        -: 1611:
      965: 1612:    if (should_touch) {
      115: 1613:        protocol_binary_request_touch *t = binary_get_request(c);
      230: 1614:        time_t exptime = ntohl(t->message.body.expiration);
        -: 1615:
      115: 1616:        it = item_touch(key, nkey, realtime(exptime), c);
        -: 1617:    } else {
      850: 1618:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 1619:    }
        -: 1620:
      965: 1621:    if (it) {
        -: 1622:        /* the length has two unnecessary bytes ("\r\n") */
      787: 1623:        uint16_t keylen = 0;
      787: 1624:        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);
        -: 1625:
      787: 1626:        pthread_mutex_lock(&c->thread->stats.mutex);
      787: 1627:        if (should_touch) {
       25: 1628:            c->thread->stats.touch_cmds++;
       25: 1629:            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 1630:        } else {
      762: 1631:            c->thread->stats.get_cmds++;
      762: 1632:            c->thread->stats.lru_hits[it->slabs_clsid]++;
        -: 1633:        }
      787: 1634:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1635:
        -: 1636:        if (should_touch) {
        -: 1637:            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
        -: 1638:                                    it->nbytes, ITEM_get_cas(it));
        -: 1639:        } else {
        -: 1640:            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
        -: 1641:                                  it->nbytes, ITEM_get_cas(it));
        -: 1642:        }
        -: 1643:
      787: 1644:        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
        2: 1645:            bodylen -= it->nbytes - 2;
      785: 1646:        } else if (should_return_key) {
       26: 1647:            bodylen += nkey;
       26: 1648:            keylen = nkey;
        -: 1649:        }
        -: 1650:
      787: 1651:        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
      787: 1652:        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));
        -: 1653:
        -: 1654:        // add the flags
      787: 1655:        FLAGS_CONV(settings.inline_ascii_response, it, rsp->message.body.flags);
     1574: 1656:        rsp->message.body.flags = htonl(rsp->message.body.flags);
      787: 1657:        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));
        -: 1658:
      787: 1659:        if (should_return_key) {
       26: 1660:            add_iov(c, ITEM_key(it), nkey);
        -: 1661:        }
        -: 1662:
      787: 1663:        if (should_return_value) {
        -: 1664:            /* Add the data minus the CRLF */
        -: 1665:#ifdef EXTSTORE
        -: 1666:            if (it->it_flags & ITEM_HDR) {
        -: 1667:                int iovcnt = 4;
        -: 1668:                int iovst = c->iovused - 3;
        -: 1669:                if (!should_return_key) {
        -: 1670:                    iovcnt = 3;
        -: 1671:                    iovst = c->iovused - 2;
        -: 1672:                }
        -: 1673:
        -: 1674:                if (_get_extstore(c, it, iovst, iovcnt) != 0) {
        -: 1675:                    pthread_mutex_lock(&c->thread->stats.mutex);
        -: 1676:                    c->thread->stats.get_oom_extstore++;
        -: 1677:                    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1678:
        -: 1679:                    failed = true;
        -: 1680:                }
        -: 1681:            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 1682:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1683:            } else {
        -: 1684:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1685:            }
        -: 1686:#else
      785: 1687:            if ((it->it_flags & ITEM_CHUNKED) == 0) {
      584: 1688:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1689:            } else {
      201: 1690:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1691:            }
        -: 1692:#endif
        -: 1693:        }
        -: 1694:
        -: 1695:        if (!failed) {
      787: 1696:            conn_set_state(c, conn_mwrite);
      787: 1697:            c->write_and_go = conn_new_cmd;
        -: 1698:            /* Remember this command so we can garbage collect it later */
        -: 1699:#ifdef EXTSTORE
        -: 1700:            if ((it->it_flags & ITEM_HDR) != 0 && should_return_value) {
        -: 1701:                // Only have extstore clean if header and returning value.
        -: 1702:                c->item = NULL;
        -: 1703:            } else {
        -: 1704:                c->item = it;
        -: 1705:            }
        -: 1706:#else
      787: 1707:            c->item = it;
        -: 1708:#endif
        -: 1709:        } else {
        -: 1710:            item_remove(it);
        -: 1711:        }
        -: 1712:    } else {
        -: 1713:        failed = true;
        -: 1714:    }
        -: 1715:
      965: 1716:    if (failed) {
      178: 1717:        pthread_mutex_lock(&c->thread->stats.mutex);
      178: 1718:        if (should_touch) {
       90: 1719:            c->thread->stats.touch_cmds++;
       90: 1720:            c->thread->stats.touch_misses++;
        -: 1721:        } else {
       88: 1722:            c->thread->stats.get_cmds++;
       88: 1723:            c->thread->stats.get_misses++;
        -: 1724:        }
      178: 1725:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1726:
        -: 1727:        if (should_touch) {
        -: 1728:            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        -: 1729:        } else {
        -: 1730:            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 1731:        }
        -: 1732:
      178: 1733:        if (c->noreply) {
       70: 1734:            conn_set_state(c, conn_new_cmd);
        -: 1735:        } else {
      108: 1736:            if (should_return_key) {
       37: 1737:                write_bin_miss_response(c, key, nkey);
        -: 1738:            } else {
        -: 1739:                write_bin_miss_response(c, NULL, 0);
        -: 1740:            }
        -: 1741:        }
        -: 1742:    }
        -: 1743:
      965: 1744:    if (settings.detail_enabled) {
      554: 1745:        stats_prefix_record_get(key, nkey, NULL != it);
        -: 1746:    }
      965: 1747:}
        -: 1748:
     1581: 1749:static void append_bin_stats(const char *key, const uint16_t klen,
        -: 1750:                             const char *val, const uint32_t vlen,
        -: 1751:                             conn *c) {
     1581: 1752:    char *buf = c->stats.buffer + c->stats.offset;
     1581: 1753:    uint32_t bodylen = klen + vlen;
     6324: 1754:    protocol_binary_response_header header = {
        -: 1755:        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        -: 1756:        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
     1581: 1757:        .response.keylen = (uint16_t)htons(klen),
        -: 1758:        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
     1581: 1759:        .response.bodylen = htonl(bodylen),
     1581: 1760:        .response.opaque = c->opaque
        -: 1761:    };
        -: 1762:
     1581: 1763:    memcpy(buf, header.bytes, sizeof(header.response));
     1581: 1764:    buf += sizeof(header.response);
        -: 1765:
     1581: 1766:    if (klen > 0) {
     3116: 1767:        memcpy(buf, key, klen);
     1558: 1768:        buf += klen;
        -: 1769:
     1558: 1770:        if (vlen > 0) {
     1558: 1771:            memcpy(buf, val, vlen);
        -: 1772:        }
        -: 1773:    }
        -: 1774:
     1581: 1775:    c->stats.offset += sizeof(header.response) + bodylen;
     1581: 1776:}
        -: 1777:
   212258: 1778:static void append_ascii_stats(const char *key, const uint16_t klen,
        -: 1779:                               const char *val, const uint32_t vlen,
        -: 1780:                               conn *c) {
   212258: 1781:    char *pos = c->stats.buffer + c->stats.offset;
   212258: 1782:    uint32_t nbytes = 0;
   212258: 1783:    int remaining = c->stats.size - c->stats.offset;
   212258: 1784:    int room = remaining - 1;
        -: 1785:
   212258: 1786:    if (klen == 0 && vlen == 0) {
     5358: 1787:        nbytes = snprintf(pos, room, "END\r\n");
   209579: 1788:    } else if (vlen == 0) {
    #####: 1789:        nbytes = snprintf(pos, room, "STAT %s\r\n", key);
        -: 1790:    } else {
   419158: 1791:        nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
        -: 1792:    }
        -: 1793:
   212258: 1794:    c->stats.offset += nbytes;
   212258: 1795:}
        -: 1796:
   213839: 1797:static bool grow_stats_buf(conn *c, size_t needed) {
   213839: 1798:    size_t nsize = c->stats.size;
   213839: 1799:    size_t available = nsize - c->stats.offset;
   213839: 1800:    bool rv = true;
        -: 1801:
        -: 1802:    /* Special case: No buffer -- need to allocate fresh */
   213839: 1803:    if (c->stats.buffer == NULL) {
     2702: 1804:        nsize = 1024;
     2702: 1805:        available = c->stats.size = c->stats.offset = 0;
        -: 1806:    }
        -: 1807:
   216564: 1808:    while (needed > available) {
     2725: 1809:        assert(nsize > 0);
     2725: 1810:        nsize = nsize << 1;
     2725: 1811:        available = nsize - c->stats.offset;
        -: 1812:    }
        -: 1813:
   213839: 1814:    if (nsize != c->stats.size) {
     2725: 1815:        char *ptr = realloc(c->stats.buffer, nsize);
     2725: 1816:        if (ptr) {
     2725: 1817:            c->stats.buffer = ptr;
     2725: 1818:            c->stats.size = nsize;
        -: 1819:        } else {
    #####: 1820:            STATS_LOCK();
    #####: 1821:            stats.malloc_fails++;
    #####: 1822:            STATS_UNLOCK();
    #####: 1823:            rv = false;
        -: 1824:        }
        -: 1825:    }
        -: 1826:
   213839: 1827:    return rv;
        -: 1828:}
        -: 1829:
   213839: 1830:static void append_stats(const char *key, const uint16_t klen,
        -: 1831:                  const char *val, const uint32_t vlen,
        -: 1832:                  const void *cookie)
        -: 1833:{
        -: 1834:    /* value without a key is invalid */
   213839: 1835:    if (klen == 0 && vlen > 0) {
        -: 1836:        return ;
        -: 1837:    }
        -: 1838:
   213839: 1839:    conn *c = (conn*)cookie;
        -: 1840:
   213839: 1841:    if (c->protocol == binary_prot) {
     1581: 1842:        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
     1581: 1843:        if (!grow_stats_buf(c, needed)) {
        -: 1844:            return ;
        -: 1845:        }
     1581: 1846:        append_bin_stats(key, klen, val, vlen, c);
        -: 1847:    } else {
   212258: 1848:        size_t needed = vlen + klen + 10; // 10 == "STAT = \r\n"
   212258: 1849:        if (!grow_stats_buf(c, needed)) {
        -: 1850:            return ;
        -: 1851:        }
   212258: 1852:        append_ascii_stats(key, klen, val, vlen, c);
        -: 1853:    }
        -: 1854:
   213839: 1855:    assert(c->stats.offset <= c->stats.size);
        -: 1856:}
        -: 1857:
       23: 1858:static void process_bin_stat(conn *c) {
       46: 1859:    char *subcommand = binary_get_key(c);
       23: 1860:    size_t nkey = c->binary_header.request.keylen;
        -: 1861:
       23: 1862:    if (settings.verbose > 1) {
        -: 1863:        int ii;
    #####: 1864:        fprintf(stderr, "<%d STATS ", c->sfd);
    #####: 1865:        for (ii = 0; ii < nkey; ++ii) {
    #####: 1866:            fprintf(stderr, "%c", subcommand[ii]);
        -: 1867:        }
    #####: 1868:        fprintf(stderr, "\n");
        -: 1869:    }
        -: 1870:
       23: 1871:    if (nkey == 0) {
        -: 1872:        /* request all statistics */
       20: 1873:        server_stats(&append_stats, c);
       20: 1874:        (void)get_stats(NULL, 0, &append_stats, c);
        3: 1875:    } else if (strncmp(subcommand, "reset", 5) == 0) {
    #####: 1876:        stats_reset();
        3: 1877:    } else if (strncmp(subcommand, "settings", 8) == 0) {
        1: 1878:        process_stat_settings(&append_stats, c);
        2: 1879:    } else if (strncmp(subcommand, "detail", 6) == 0) {
        2: 1880:        char *subcmd_pos = subcommand + 6;
        2: 1881:        if (strncmp(subcmd_pos, " dump", 5) == 0) {
        -: 1882:            int len;
        1: 1883:            char *dump_buf = stats_prefix_dump(&len);
        1: 1884:            if (dump_buf == NULL || len <= 0) {
    #####: 1885:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
    #####: 1886:                if (dump_buf != NULL)
    #####: 1887:                    free(dump_buf);
    #####: 1888:                return;
        -: 1889:            } else {
        1: 1890:                append_stats("detailed", strlen("detailed"), dump_buf, len, c);
        1: 1891:                free(dump_buf);
        -: 1892:            }
        1: 1893:        } else if (strncmp(subcmd_pos, " on", 3) == 0) {
        1: 1894:            settings.detail_enabled = 1;
    #####: 1895:        } else if (strncmp(subcmd_pos, " off", 4) == 0) {
    #####: 1896:            settings.detail_enabled = 0;
        -: 1897:        } else {
    #####: 1898:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 1899:            return;
        -: 1900:        }
        -: 1901:    } else {
    #####: 1902:        if (get_stats(subcommand, nkey, &append_stats, c)) {
    #####: 1903:            if (c->stats.buffer == NULL) {
    #####: 1904:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
        -: 1905:            } else {
    #####: 1906:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 1907:                c->stats.buffer = NULL;
        -: 1908:            }
        -: 1909:        } else {
    #####: 1910:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1911:        }
        -: 1912:
        -: 1913:        return;
        -: 1914:    }
        -: 1915:
        -: 1916:    /* Append termination package and start the transfer */
       23: 1917:    append_stats(NULL, 0, NULL, 0, c);
       23: 1918:    if (c->stats.buffer == NULL) {
    #####: 1919:        out_of_memory(c, "SERVER_ERROR Out of memory preparing to send stats");
        -: 1920:    } else {
       23: 1921:        write_and_free(c, c->stats.buffer, c->stats.offset);
       23: 1922:        c->stats.buffer = NULL;
        -: 1923:    }
        -: 1924:}
        -: 1925:
    21512: 1926:static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {
    21512: 1927:    assert(c);
    21512: 1928:    c->substate = next_substate;
    21512: 1929:    c->rlbytes = c->keylen + extra;
        -: 1930:
        -: 1931:    /* Ok... do we have room for the extras and the key in the input buffer? */
    21512: 1932:    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;
    21512: 1933:    if (c->rlbytes > c->rsize - offset) {
    #####: 1934:        size_t nsize = c->rsize;
    #####: 1935:        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);
        -: 1936:
    #####: 1937:        while (size > nsize) {
    #####: 1938:            nsize *= 2;
        -: 1939:        }
        -: 1940:
    #####: 1941:        if (nsize != c->rsize) {
    #####: 1942:            if (settings.verbose > 1) {
    #####: 1943:                fprintf(stderr, "%d: Need to grow buffer from %lu to %lu\n",
        -: 1944:                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);
        -: 1945:            }
    #####: 1946:            char *newm = realloc(c->rbuf, nsize);
    #####: 1947:            if (newm == NULL) {
    #####: 1948:                STATS_LOCK();
    #####: 1949:                stats.malloc_fails++;
    #####: 1950:                STATS_UNLOCK();
    #####: 1951:                if (settings.verbose) {
    #####: 1952:                    fprintf(stderr, "%d: Failed to grow buffer.. closing connection\n",
        -: 1953:                            c->sfd);
        -: 1954:                }
    #####: 1955:                conn_set_state(c, conn_closing);
    #####: 1956:                return;
        -: 1957:            }
        -: 1958:
    #####: 1959:            c->rbuf= newm;
        -: 1960:            /* rcurr should point to the same offset in the packet */
    #####: 1961:            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);
    #####: 1962:            c->rsize = nsize;
        -: 1963:        }
    #####: 1964:        if (c->rbuf != c->rcurr) {
    #####: 1965:            memmove(c->rbuf, c->rcurr, c->rbytes);
    #####: 1966:            c->rcurr = c->rbuf;
    #####: 1967:            if (settings.verbose > 1) {
    #####: 1968:                fprintf(stderr, "%d: Repack input buffer\n", c->sfd);
        -: 1969:            }
        -: 1970:        }
        -: 1971:    }
        -: 1972:
        -: 1973:    /* preserve the header in the buffer.. */
    21512: 1974:    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);
    21512: 1975:    conn_set_state(c, conn_nread);
        -: 1976:}
        -: 1977:
        -: 1978:/* Just write an error message and disconnect the client */
        1: 1979:static void handle_binary_protocol_error(conn *c) {
        1: 1980:    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
        1: 1981:    if (settings.verbose) {
    #####: 1982:        fprintf(stderr, "Protocol error (opcode %02x), close connection %d\n",
    #####: 1983:                c->binary_header.request.opcode, c->sfd);
        -: 1984:    }
        1: 1985:    c->write_and_go = conn_closing;
        1: 1986:}
        -: 1987:
    #####: 1988:static void init_sasl_conn(conn *c) {
    #####: 1989:    assert(c);
        -: 1990:    /* should something else be returned? */
    #####: 1991:    if (!settings.sasl)
        -: 1992:        return;
        -: 1993:
    #####: 1994:    c->authenticated = false;
        -: 1995:
    #####: 1996:    if (!c->sasl_conn) {
    #####: 1997:        int result=sasl_server_new("memcached",
        -: 1998:                                   NULL,
        -: 1999:                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
        -: 2000:                                   NULL, NULL,
        -: 2001:                                   NULL, 0, &c->sasl_conn);
        -: 2002:        if (result != SASL_OK) {
    #####: 2003:            if (settings.verbose) {
    #####: 2004:                fprintf(stderr, "Failed to initialize SASL conn.\n");
        -: 2005:            }
    #####: 2006:            c->sasl_conn = NULL;
        -: 2007:        }
        -: 2008:    }
        -: 2009:}
        -: 2010:
    #####: 2011:static void bin_list_sasl_mechs(conn *c) {
        -: 2012:    // Guard against a disabled SASL.
    #####: 2013:    if (!settings.sasl) {
    #####: 2014:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2015:                        c->binary_header.request.bodylen
    #####: 2016:                        - c->binary_header.request.keylen);
    #####: 2017:        return;
        -: 2018:    }
        -: 2019:
    #####: 2020:    init_sasl_conn(c);
    #####: 2021:    const char *result_string = NULL;
    #####: 2022:    unsigned int string_length = 0;
    #####: 2023:    int result=sasl_listmech(c->sasl_conn, NULL,
        -: 2024:                             "",   /* What to prepend the string with */
        -: 2025:                             " ",  /* What to separate mechanisms with */
        -: 2026:                             "",   /* What to append to the string */
        -: 2027:                             &result_string, &string_length,
        -: 2028:                             NULL);
        -: 2029:    if (result != SASL_OK) {
        -: 2030:        /* Perhaps there's a better error for this... */
    #####: 2031:        if (settings.verbose) {
    #####: 2032:            fprintf(stderr, "Failed to list SASL mechanisms.\n");
        -: 2033:        }
    #####: 2034:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2035:        return;
        -: 2036:    }
        -: 2037:    write_bin_response(c, (char*)result_string, 0, 0, string_length);
        -: 2038:}
        -: 2039:
    #####: 2040:static void process_bin_sasl_auth(conn *c) {
        -: 2041:    // Guard for handling disabled SASL on the server.
    #####: 2042:    if (!settings.sasl) {
    #####: 2043:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2044:                        c->binary_header.request.bodylen
    #####: 2045:                        - c->binary_header.request.keylen);
    #####: 2046:        return;
        -: 2047:    }
        -: 2048:
    #####: 2049:    assert(c->binary_header.request.extlen == 0);
        -: 2050:
    #####: 2051:    int nkey = c->binary_header.request.keylen;
    #####: 2052:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2053:
    #####: 2054:    if (nkey > MAX_SASL_MECH_LEN) {
    #####: 2055:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2056:        c->write_and_go = conn_swallow;
    #####: 2057:        return;
        -: 2058:    }
        -: 2059:
    #####: 2060:    char *key = binary_get_key(c);
    #####: 2061:    assert(key);
        -: 2062:
    #####: 2063:    item *it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2064:
        -: 2065:    /* Can't use a chunked item for SASL authentication. */
    #####: 2066:    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
    #####: 2067:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
    #####: 2068:        c->write_and_go = conn_swallow;
    #####: 2069:        return;
        -: 2070:    }
        -: 2071:
    #####: 2072:    c->item = it;
    #####: 2073:    c->ritem = ITEM_data(it);
    #####: 2074:    c->rlbytes = vlen;
    #####: 2075:    conn_set_state(c, conn_nread);
    #####: 2076:    c->substate = bin_reading_sasl_auth_data;
        -: 2077:}
        -: 2078:
    #####: 2079:static void process_bin_complete_sasl_auth(conn *c) {
    #####: 2080:    assert(settings.sasl);
    #####: 2081:    const char *out = NULL;
    #####: 2082:    unsigned int outlen = 0;
        -: 2083:
    #####: 2084:    assert(c->item);
    #####: 2085:    init_sasl_conn(c);
        -: 2086:
    #####: 2087:    int nkey = c->binary_header.request.keylen;
    #####: 2088:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2089:
    #####: 2090:    if (nkey > ((item*) c->item)->nkey) {
    #####: 2091:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2092:        c->write_and_go = conn_swallow;
    #####: 2093:        item_unlink(c->item);
    #####: 2094:        return;
        -: 2095:    }
        -: 2096:
    #####: 2097:    char mech[nkey+1];
    #####: 2098:    memcpy(mech, ITEM_key((item*)c->item), nkey);
    #####: 2099:    mech[nkey] = 0x00;
        -: 2100:
    #####: 2101:    if (settings.verbose)
    #####: 2102:        fprintf(stderr, "mech:  ``%s'' with %d bytes of data\n", mech, vlen);
        -: 2103:
    #####: 2104:    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);
        -: 2105:
    #####: 2106:    if (vlen > ((item*) c->item)->nbytes) {
    #####: 2107:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2108:        c->write_and_go = conn_swallow;
    #####: 2109:        item_unlink(c->item);
    #####: 2110:        return;
        -: 2111:    }
        -: 2112:
    #####: 2113:    int result=-1;
        -: 2114:
    #####: 2115:    switch (c->cmd) {
        -: 2116:    case PROTOCOL_BINARY_CMD_SASL_AUTH:
    #####: 2117:        result = sasl_server_start(c->sasl_conn, mech,
        -: 2118:                                   challenge, vlen,
        -: 2119:                                   &out, &outlen);
    #####: 2120:        c->sasl_started = (result == SASL_OK || result == SASL_CONTINUE);
    #####: 2121:        break;
        -: 2122:    case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2123:        if (!c->sasl_started) {
    #####: 2124:            if (settings.verbose) {
    #####: 2125:                fprintf(stderr, "%d: SASL_STEP called but sasl_server_start "
        -: 2126:                        "not called for this connection!\n", c->sfd);
        -: 2127:            }
        -: 2128:            break;
        -: 2129:        }
        -: 2130:        result = sasl_server_step(c->sasl_conn,
        -: 2131:                                  challenge, vlen,
        -: 2132:                                  &out, &outlen);
        -: 2133:        break;
        -: 2134:    default:
    #####: 2135:        assert(false); /* CMD should be one of the above */
        -: 2136:        /* This code is pretty much impossible, but makes the compiler
        -: 2137:           happier */
        -: 2138:        if (settings.verbose) {
        -: 2139:            fprintf(stderr, "Unhandled command %d with challenge %s\n",
        -: 2140:                    c->cmd, challenge);
        -: 2141:        }
        -: 2142:        break;
        -: 2143:    }
        -: 2144:
    #####: 2145:    item_unlink(c->item);
        -: 2146:
    #####: 2147:    if (settings.verbose) {
    #####: 2148:        fprintf(stderr, "sasl result code:  %d\n", result);
        -: 2149:    }
        -: 2150:
    #####: 2151:    switch(result) {
        -: 2152:    case SASL_OK:
    #####: 2153:        c->authenticated = true;
    #####: 2154:        write_bin_response(c, "Authenticated", 0, 0, strlen("Authenticated"));
    #####: 2155:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2156:        c->thread->stats.auth_cmds++;
    #####: 2157:        pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2158:        break;
        -: 2159:    case SASL_CONTINUE:
    #####: 2160:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);
        -: 2161:        if(outlen > 0) {
        -: 2162:            add_iov(c, out, outlen);
        -: 2163:        }
    #####: 2164:        conn_set_state(c, conn_mwrite);
    #####: 2165:        c->write_and_go = conn_new_cmd;
    #####: 2166:        break;
        -: 2167:    default:
    #####: 2168:        if (settings.verbose)
    #####: 2169:            fprintf(stderr, "Unknown sasl response:  %d\n", result);
    #####: 2170:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2171:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2172:        c->thread->stats.auth_cmds++;
    #####: 2173:        c->thread->stats.auth_errors++;
    #####: 2174:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2175:    }
        -: 2176:}
        -: 2177:
    #####: 2178:static bool authenticated(conn *c) {
    #####: 2179:    assert(settings.sasl);
    #####: 2180:    bool rv = false;
        -: 2181:
    #####: 2182:    switch (c->cmd) {
        -: 2183:    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
        -: 2184:    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
        -: 2185:    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
        -: 2186:    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        -: 2187:        rv = true;
        -: 2188:        break;
        -: 2189:    default:
    #####: 2190:        rv = c->authenticated;
        -: 2191:    }
        -: 2192:
    #####: 2193:    if (settings.verbose > 1) {
    #####: 2194:        fprintf(stderr, "authenticated() in cmd 0x%02x is %s\n",
        -: 2195:                c->cmd, rv ? "true" : "false");
        -: 2196:    }
        -: 2197:
    #####: 2198:    return rv;
        -: 2199:}
        -: 2200:
    24951: 2201:static void dispatch_bin_command(conn *c) {
    24951: 2202:    int protocol_error = 0;
        -: 2203:
    24951: 2204:    uint8_t extlen = c->binary_header.request.extlen;
    24951: 2205:    uint16_t keylen = c->binary_header.request.keylen;
    24951: 2206:    uint32_t bodylen = c->binary_header.request.bodylen;
        -: 2207:
    24951: 2208:    if (keylen > bodylen || keylen + extlen > bodylen) {
    #####: 2209:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
    #####: 2210:        c->write_and_go = conn_closing;
    #####: 2211:        return;
        -: 2212:    }
        -: 2213:
    24951: 2214:    if (settings.sasl && !authenticated(c)) {
    #####: 2215:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2216:        c->write_and_go = conn_closing;
    #####: 2217:        return;
        -: 2218:    }
        -: 2219:
        -: 2220:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
    24951: 2221:    c->noreply = true;
        -: 2222:
        -: 2223:    /* binprot supports 16bit keys, but internals are still 8bit */
    24951: 2224:    if (keylen > KEY_MAX_LENGTH) {
        1: 2225:        handle_binary_protocol_error(c);
        1: 2226:        return;
        -: 2227:    }
        -: 2228:
    24950: 2229:    switch (c->cmd) {
        -: 2230:    case PROTOCOL_BINARY_CMD_SETQ:
    19879: 2231:        c->cmd = PROTOCOL_BINARY_CMD_SET;
    19879: 2232:        break;
        -: 2233:    case PROTOCOL_BINARY_CMD_ADDQ:
       21: 2234:        c->cmd = PROTOCOL_BINARY_CMD_ADD;
       21: 2235:        break;
        -: 2236:    case PROTOCOL_BINARY_CMD_REPLACEQ:
       34: 2237:        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;
       34: 2238:        break;
        -: 2239:    case PROTOCOL_BINARY_CMD_DELETEQ:
       21: 2240:        c->cmd = PROTOCOL_BINARY_CMD_DELETE;
       21: 2241:        break;
        -: 2242:    case PROTOCOL_BINARY_CMD_INCREMENTQ:
       29: 2243:        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;
       29: 2244:        break;
        -: 2245:    case PROTOCOL_BINARY_CMD_DECREMENTQ:
       29: 2246:        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;
       29: 2247:        break;
        -: 2248:    case PROTOCOL_BINARY_CMD_QUITQ:
        3: 2249:        c->cmd = PROTOCOL_BINARY_CMD_QUIT;
        3: 2250:        break;
        -: 2251:    case PROTOCOL_BINARY_CMD_FLUSHQ:
       21: 2252:        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;
       21: 2253:        break;
        -: 2254:    case PROTOCOL_BINARY_CMD_APPENDQ:
       15: 2255:        c->cmd = PROTOCOL_BINARY_CMD_APPEND;
       15: 2256:        break;
        -: 2257:    case PROTOCOL_BINARY_CMD_PREPENDQ:
       10: 2258:        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;
       10: 2259:        break;
        -: 2260:    case PROTOCOL_BINARY_CMD_GETQ:
       19: 2261:        c->cmd = PROTOCOL_BINARY_CMD_GET;
       19: 2262:        break;
        -: 2263:    case PROTOCOL_BINARY_CMD_GETKQ:
       18: 2264:        c->cmd = PROTOCOL_BINARY_CMD_GETK;
       18: 2265:        break;
        -: 2266:    case PROTOCOL_BINARY_CMD_GATQ:
       19: 2267:        c->cmd = PROTOCOL_BINARY_CMD_GAT;
       19: 2268:        break;
        -: 2269:    case PROTOCOL_BINARY_CMD_GATKQ:
       20: 2270:        c->cmd = PROTOCOL_BINARY_CMD_GATK;
       20: 2271:        break;
        -: 2272:    default:
     4812: 2273:        c->noreply = false;
        -: 2274:    }
        -: 2275:
    24950: 2276:    switch (c->cmd) {
        -: 2277:        case PROTOCOL_BINARY_CMD_VERSION:
       13: 2278:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
       13: 2279:                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
        -: 2280:            } else {
        -: 2281:                protocol_error = 1;
        -: 2282:            }
        -: 2283:            break;
        -: 2284:        case PROTOCOL_BINARY_CMD_FLUSH:
       45: 2285:            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {
       45: 2286:                bin_read_key(c, bin_read_flush_exptime, extlen);
        -: 2287:            } else {
        -: 2288:                protocol_error = 1;
        -: 2289:            }
        -: 2290:            break;
        -: 2291:        case PROTOCOL_BINARY_CMD_NOOP:
       35: 2292:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
       35: 2293:                write_bin_response(c, NULL, 0, 0, 0);
        -: 2294:            } else {
        -: 2295:                protocol_error = 1;
        -: 2296:            }
        -: 2297:            break;
        -: 2298:        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */
        -: 2299:        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */
        -: 2300:        case PROTOCOL_BINARY_CMD_REPLACE:
    20253: 2301:            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {
    20253: 2302:                bin_read_key(c, bin_reading_set_header, 8);
        -: 2303:            } else {
        -: 2304:                protocol_error = 1;
        -: 2305:            }
        -: 2306:            break;
        -: 2307:        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */
        -: 2308:        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */
        -: 2309:        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */
        -: 2310:        case PROTOCOL_BINARY_CMD_GETK:
      850: 2311:            if (extlen == 0 && bodylen == keylen && keylen > 0) {
      850: 2312:                bin_read_key(c, bin_reading_get_key, 0);
        -: 2313:            } else {
        -: 2314:                protocol_error = 1;
        -: 2315:            }
        -: 2316:            break;
        -: 2317:        case PROTOCOL_BINARY_CMD_DELETE:
       40: 2318:            if (keylen > 0 && extlen == 0 && bodylen == keylen) {
       40: 2319:                bin_read_key(c, bin_reading_del_header, extlen);
        -: 2320:            } else {
        -: 2321:                protocol_error = 1;
        -: 2322:            }
        -: 2323:            break;
        -: 2324:        case PROTOCOL_BINARY_CMD_INCREMENT:
        -: 2325:        case PROTOCOL_BINARY_CMD_DECREMENT:
      131: 2326:            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {
      131: 2327:                bin_read_key(c, bin_reading_incr_header, 20);
        -: 2328:            } else {
        -: 2329:                protocol_error = 1;
        -: 2330:            }
        -: 2331:            break;
        -: 2332:        case PROTOCOL_BINARY_CMD_APPEND:
        -: 2333:        case PROTOCOL_BINARY_CMD_PREPEND:
       55: 2334:            if (keylen > 0 && extlen == 0) {
       55: 2335:                bin_read_key(c, bin_reading_set_header, 0);
        -: 2336:            } else {
        -: 2337:                protocol_error = 1;
        -: 2338:            }
        -: 2339:            break;
        -: 2340:        case PROTOCOL_BINARY_CMD_STAT:
       23: 2341:            if (extlen == 0) {
       23: 2342:                bin_read_key(c, bin_reading_stat, 0);
        -: 2343:            } else {
        -: 2344:                protocol_error = 1;
        -: 2345:            }
        -: 2346:            break;
        -: 2347:        case PROTOCOL_BINARY_CMD_QUIT:
        4: 2348:            if (keylen == 0 && extlen == 0 && bodylen == 0) {
        4: 2349:                write_bin_response(c, NULL, 0, 0, 0);
        4: 2350:                c->write_and_go = conn_closing;
        4: 2351:                if (c->noreply) {
        3: 2352:                    conn_set_state(c, conn_closing);
        -: 2353:                }
        -: 2354:            } else {
        -: 2355:                protocol_error = 1;
        -: 2356:            }
        -: 2357:            break;
        -: 2358:        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:
    #####: 2359:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2360:                bin_list_sasl_mechs(c);
        -: 2361:            } else {
        -: 2362:                protocol_error = 1;
        -: 2363:            }
        -: 2364:            break;
        -: 2365:        case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 2366:        case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2367:            if (extlen == 0 && keylen != 0) {
    #####: 2368:                bin_read_key(c, bin_reading_sasl_auth, 0);
        -: 2369:            } else {
        -: 2370:                protocol_error = 1;
        -: 2371:            }
        -: 2372:            break;
        -: 2373:        case PROTOCOL_BINARY_CMD_TOUCH:
        -: 2374:        case PROTOCOL_BINARY_CMD_GAT:
        -: 2375:        case PROTOCOL_BINARY_CMD_GATQ:
        -: 2376:        case PROTOCOL_BINARY_CMD_GATK:
        -: 2377:        case PROTOCOL_BINARY_CMD_GATKQ:
      115: 2378:            if (extlen == 4 && keylen != 0) {
      115: 2379:                bin_read_key(c, bin_reading_touch_key, 4);
        -: 2380:            } else {
        -: 2381:                protocol_error = 1;
        -: 2382:            }
        -: 2383:            break;
        -: 2384:        default:
     3386: 2385:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
        -: 2386:                            bodylen);
        -: 2387:    }
        -: 2388:
    24950: 2389:    if (protocol_error)
    #####: 2390:        handle_binary_protocol_error(c);
        -: 2391:}
        -: 2392:
    20253: 2393:static void process_bin_update(conn *c) {
        -: 2394:    char *key;
        -: 2395:    int nkey;
        -: 2396:    int vlen;
        -: 2397:    item *it;
    20253: 2398:    protocol_binary_request_set* req = binary_get_request(c);
        -: 2399:
    20253: 2400:    assert(c != NULL);
        -: 2401:
    40506: 2402:    key = binary_get_key(c);
    20253: 2403:    nkey = c->binary_header.request.keylen;
        -: 2404:
        -: 2405:    /* fix byteorder in the request */
    40506: 2406:    req->message.body.flags = ntohl(req->message.body.flags);
    40506: 2407:    req->message.body.expiration = ntohl(req->message.body.expiration);
        -: 2408:
    20253: 2409:    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);
        -: 2410:
    20253: 2411:    if (settings.verbose > 1) {
        -: 2412:        int ii;
    #####: 2413:        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
    #####: 2414:            fprintf(stderr, "<%d ADD ", c->sfd);
    #####: 2415:        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2416:            fprintf(stderr, "<%d SET ", c->sfd);
        -: 2417:        } else {
    #####: 2418:            fprintf(stderr, "<%d REPLACE ", c->sfd);
        -: 2419:        }
    #####: 2420:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2421:            fprintf(stderr, "%c", key[ii]);
        -: 2422:        }
        -: 2423:
    #####: 2424:        fprintf(stderr, " Value len is %d", vlen);
    #####: 2425:        fprintf(stderr, "\n");
        -: 2426:    }
        -: 2427:
    20253: 2428:    if (settings.detail_enabled) {
    19888: 2429:        stats_prefix_record_set(key, nkey);
        -: 2430:    }
        -: 2431:
    60759: 2432:    it = item_alloc(key, nkey, req->message.body.flags,
    20253: 2433:            realtime(req->message.body.expiration), vlen+2);
        -: 2434:
    20253: 2435:    if (it == 0) {
        -: 2436:        enum store_item_type status;
        2: 2437:        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {
        2: 2438:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        2: 2439:            status = TOO_LARGE;
        -: 2440:        } else {
    #####: 2441:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2442:            /* This error generating method eats the swallow value. Add here. */
    #####: 2443:            c->sbytes = vlen;
    #####: 2444:            status = NO_MEMORY;
        -: 2445:        }
        -: 2446:        /* FIXME: losing c->cmd since it's translated below. refactor? */
        2: 2447:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 2448:                NULL, status, 0, key, nkey, req->message.body.expiration,
        -: 2449:                ITEM_clsid(it));
        -: 2450:
        -: 2451:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 2452:         * Unacceptable for SET. Anywhere else too? */
        2: 2453:        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
        1: 2454:            it = item_get(key, nkey, c, DONT_UPDATE);
        1: 2455:            if (it) {
        1: 2456:                item_unlink(it);
        -: 2457:                STORAGE_delete(c->thread->storage, it);
        1: 2458:                item_remove(it);
        -: 2459:            }
        -: 2460:        }
        -: 2461:
        -: 2462:        /* swallow the data line */
        2: 2463:        c->write_and_go = conn_swallow;
        2: 2464:        return;
        -: 2465:    }
        -: 2466:
    20251: 2467:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2468:
    20251: 2469:    switch (c->cmd) {
        -: 2470:        case PROTOCOL_BINARY_CMD_ADD:
       73: 2471:            c->cmd = NREAD_ADD;
       73: 2472:            break;
        -: 2473:        case PROTOCOL_BINARY_CMD_SET:
    20126: 2474:            c->cmd = NREAD_SET;
    20126: 2475:            break;
        -: 2476:        case PROTOCOL_BINARY_CMD_REPLACE:
       52: 2477:            c->cmd = NREAD_REPLACE;
       52: 2478:            break;
        -: 2479:        default:
    #####: 2480:            assert(0);
        -: 2481:    }
        -: 2482:
    20251: 2483:    if (ITEM_get_cas(it) != 0) {
        5: 2484:        c->cmd = NREAD_CAS;
        -: 2485:    }
        -: 2486:
    20251: 2487:    c->item = it;
        -: 2488:#ifdef NEED_ALIGN
        -: 2489:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2490:        c->ritem = ITEM_schunk(it);
        -: 2491:    } else {
        -: 2492:        c->ritem = ITEM_data(it);
        -: 2493:    }
        -: 2494:#else
    20251: 2495:    c->ritem = ITEM_data(it);
        -: 2496:#endif
    20251: 2497:    c->rlbytes = vlen;
    20251: 2498:    conn_set_state(c, conn_nread);
    20251: 2499:    c->substate = bin_read_set_value;
        -: 2500:}
        -: 2501:
       55: 2502:static void process_bin_append_prepend(conn *c) {
        -: 2503:    char *key;
        -: 2504:    int nkey;
        -: 2505:    int vlen;
        -: 2506:    item *it;
        -: 2507:
       55: 2508:    assert(c != NULL);
        -: 2509:
      110: 2510:    key = binary_get_key(c);
       55: 2511:    nkey = c->binary_header.request.keylen;
       55: 2512:    vlen = c->binary_header.request.bodylen - nkey;
        -: 2513:
       55: 2514:    if (settings.verbose > 1) {
    #####: 2515:        fprintf(stderr, "Value len is %d\n", vlen);
        -: 2516:    }
        -: 2517:
       55: 2518:    if (settings.detail_enabled) {
        4: 2519:        stats_prefix_record_set(key, nkey);
        -: 2520:    }
        -: 2521:
       55: 2522:    it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2523:
       55: 2524:    if (it == 0) {
    #####: 2525:        if (! item_size_ok(nkey, 0, vlen + 2)) {
    #####: 2526:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        -: 2527:        } else {
    #####: 2528:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2529:            /* OOM calls eat the swallow value. Add here. */
    #####: 2530:            c->sbytes = vlen;
        -: 2531:        }
        -: 2532:        /* swallow the data line */
    #####: 2533:        c->write_and_go = conn_swallow;
    #####: 2534:        return;
        -: 2535:    }
        -: 2536:
       55: 2537:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2538:
       55: 2539:    switch (c->cmd) {
        -: 2540:        case PROTOCOL_BINARY_CMD_APPEND:
       31: 2541:            c->cmd = NREAD_APPEND;
       31: 2542:            break;
        -: 2543:        case PROTOCOL_BINARY_CMD_PREPEND:
       24: 2544:            c->cmd = NREAD_PREPEND;
       24: 2545:            break;
        -: 2546:        default:
    #####: 2547:            assert(0);
        -: 2548:    }
        -: 2549:
       55: 2550:    c->item = it;
        -: 2551:#ifdef NEED_ALIGN
        -: 2552:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2553:        c->ritem = ITEM_schunk(it);
        -: 2554:    } else {
        -: 2555:        c->ritem = ITEM_data(it);
        -: 2556:    }
        -: 2557:#else
       55: 2558:    c->ritem = ITEM_data(it);
        -: 2559:#endif
       55: 2560:    c->rlbytes = vlen;
       55: 2561:    conn_set_state(c, conn_nread);
       55: 2562:    c->substate = bin_read_set_value;
        -: 2563:}
        -: 2564:
       45: 2565:static void process_bin_flush(conn *c) {
       45: 2566:    time_t exptime = 0;
       45: 2567:    protocol_binary_request_flush* req = binary_get_request(c);
       45: 2568:    rel_time_t new_oldest = 0;
        -: 2569:
       45: 2570:    if (!settings.flush_enabled) {
        -: 2571:      // flush_all is not allowed but we log it on stats
    #####: 2572:      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2573:      return;
        -: 2574:    }
        -: 2575:
       45: 2576:    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
        8: 2577:        exptime = ntohl(req->message.body.expiration);
        -: 2578:    }
        -: 2579:
       45: 2580:    if (exptime > 0) {
        2: 2581:        new_oldest = realtime(exptime);
        -: 2582:    } else {
       43: 2583:        new_oldest = current_time;
        -: 2584:    }
       45: 2585:    if (settings.use_cas) {
       45: 2586:        settings.oldest_live = new_oldest - 1;
       45: 2587:        if (settings.oldest_live <= current_time)
       43: 2588:            settings.oldest_cas = get_cas_id();
        -: 2589:    } else {
    #####: 2590:        settings.oldest_live = new_oldest;
        -: 2591:    }
        -: 2592:
       45: 2593:    pthread_mutex_lock(&c->thread->stats.mutex);
       45: 2594:    c->thread->stats.flush_cmds++;
       45: 2595:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2596:
       45: 2597:    write_bin_response(c, NULL, 0, 0, 0);
        -: 2598:}
        -: 2599:
       40: 2600:static void process_bin_delete(conn *c) {
        -: 2601:    item *it;
        -: 2602:
       40: 2603:    protocol_binary_request_delete* req = binary_get_request(c);
        -: 2604:
       80: 2605:    char* key = binary_get_key(c);
       40: 2606:    size_t nkey = c->binary_header.request.keylen;
        -: 2607:
       40: 2608:    assert(c != NULL);
        -: 2609:
       40: 2610:    if (settings.verbose > 1) {
        -: 2611:        int ii;
    #####: 2612:        fprintf(stderr, "Deleting ");
    #####: 2613:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2614:            fprintf(stderr, "%c", key[ii]);
        -: 2615:        }
    #####: 2616:        fprintf(stderr, "\n");
        -: 2617:    }
        -: 2618:
       40: 2619:    if (settings.detail_enabled) {
        2: 2620:        stats_prefix_record_delete(key, nkey);
        -: 2621:    }
        -: 2622:
       40: 2623:    it = item_get(key, nkey, c, DONT_UPDATE);
       40: 2624:    if (it) {
        5: 2625:        uint64_t cas = ntohll(req->message.header.request.cas);
        5: 2626:        if (cas == 0 || cas == ITEM_get_cas(it)) {
        -: 2627:            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        5: 2628:            pthread_mutex_lock(&c->thread->stats.mutex);
        5: 2629:            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
        5: 2630:            pthread_mutex_unlock(&c->thread->stats.mutex);
        5: 2631:            item_unlink(it);
        -: 2632:            STORAGE_delete(c->thread->storage, it);
        5: 2633:            write_bin_response(c, NULL, 0, 0, 0);
        -: 2634:        } else {
    #####: 2635:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        -: 2636:        }
        5: 2637:        item_remove(it);      /* release our reference */
        -: 2638:    } else {
       35: 2639:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
       35: 2640:        pthread_mutex_lock(&c->thread->stats.mutex);
       35: 2641:        c->thread->stats.delete_misses++;
       35: 2642:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2643:    }
       40: 2644:}
        -: 2645:
    41818: 2646:static void complete_nread_binary(conn *c) {
    41818: 2647:    assert(c != NULL);
    41818: 2648:    assert(c->cmd >= 0);
        -: 2649:
    41818: 2650:    switch(c->substate) {
        -: 2651:    case bin_reading_set_header:
    20308: 2652:        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||
        -: 2653:                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {
       55: 2654:            process_bin_append_prepend(c);
        -: 2655:        } else {
    20253: 2656:            process_bin_update(c);
        -: 2657:        }
        -: 2658:        break;
        -: 2659:    case bin_read_set_value:
    20306: 2660:        complete_update_bin(c);
    20306: 2661:        break;
        -: 2662:    case bin_reading_get_key:
        -: 2663:    case bin_reading_touch_key:
      965: 2664:        process_bin_get_or_touch(c);
      965: 2665:        break;
        -: 2666:    case bin_reading_stat:
       23: 2667:        process_bin_stat(c);
       23: 2668:        break;
        -: 2669:    case bin_reading_del_header:
       40: 2670:        process_bin_delete(c);
       40: 2671:        break;
        -: 2672:    case bin_reading_incr_header:
      131: 2673:        complete_incr_bin(c);
      131: 2674:        break;
        -: 2675:    case bin_read_flush_exptime:
       45: 2676:        process_bin_flush(c);
       45: 2677:        break;
        -: 2678:    case bin_reading_sasl_auth:
    #####: 2679:        process_bin_sasl_auth(c);
    #####: 2680:        break;
        -: 2681:    case bin_reading_sasl_auth_data:
    #####: 2682:        process_bin_complete_sasl_auth(c);
    #####: 2683:        break;
        -: 2684:    default:
    #####: 2685:        fprintf(stderr, "Not handling substate %d\n", c->substate);
    #####: 2686:        assert(0);
        -: 2687:    }
    41818: 2688:}
        -: 2689:
   225565: 2690:static void reset_cmd_handler(conn *c) {
   225565: 2691:    c->cmd = -1;
   225565: 2692:    c->substate = bin_no_state;
   225565: 2693:    if(c->item != NULL) {
    #####: 2694:        item_remove(c->item);
    #####: 2695:        c->item = NULL;
        -: 2696:    }
   225565: 2697:    conn_shrink(c);
   225565: 2698:    if (c->rbytes > 0) {
    71721: 2699:        conn_set_state(c, conn_parse_cmd);
        -: 2700:    } else {
   153844: 2701:        conn_set_state(c, conn_waiting);
        -: 2702:    }
   225565: 2703:}
        -: 2704:
   124343: 2705:static void complete_nread(conn *c) {
   124343: 2706:    assert(c != NULL);
   124343: 2707:    assert(c->protocol == ascii_prot
        -: 2708:           || c->protocol == binary_prot);
        -: 2709:
   124343: 2710:    if (c->protocol == ascii_prot) {
    82525: 2711:        complete_nread_ascii(c);
    41818: 2712:    } else if (c->protocol == binary_prot) {
    41818: 2713:        complete_nread_binary(c);
        -: 2714:    }
   124343: 2715:}
        -: 2716:
        -: 2717:/* Destination must always be chunked */
        -: 2718:/* This should be part of item.c */
    27032: 2719:static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    27032: 2720:    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
        -: 2721:    /* Advance dch until we find free space */
   104131: 2722:    while (dch->size == dch->used) {
    77099: 2723:        if (dch->next) {
        -: 2724:            dch = dch->next;
        -: 2725:        } else {
        -: 2726:            break;
        -: 2727:        }
        -: 2728:    }
        -: 2729:
    27032: 2730:    if (s_it->it_flags & ITEM_CHUNKED) {
    13516: 2731:        int remain = len;
    13516: 2732:        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
    13516: 2733:        int copied = 0;
        -: 2734:        /* Fills dch's to capacity, not straight copy sch in case data is
        -: 2735:         * being added or removed (ie append/prepend)
        -: 2736:         */
   150187: 2737:        while (sch && dch && remain) {
   123155: 2738:            assert(dch->used <= dch->size);
   123155: 2739:            int todo = (dch->size - dch->used < sch->used - copied)
   123155: 2740:                ? dch->size - dch->used : sch->used - copied;
   123155: 2741:            if (remain < todo)
    #####: 2742:                todo = remain;
   246310: 2743:            memcpy(dch->data + dch->used, sch->data + copied, todo);
   123155: 2744:            dch->used += todo;
   123155: 2745:            copied += todo;
   123155: 2746:            remain -= todo;
   123155: 2747:            assert(dch->used <= dch->size);
   123155: 2748:            if (dch->size == dch->used) {
    73103: 2749:                item_chunk *tch = do_item_alloc_chunk(dch, remain);
    73103: 2750:                if (tch) {
        -: 2751:                    dch = tch;
        -: 2752:                } else {
        -: 2753:                    return -1;
        -: 2754:                }
        -: 2755:            }
   123155: 2756:            assert(copied <= sch->used);
   123155: 2757:            if (copied == sch->used) {
    93361: 2758:                copied = 0;
    93361: 2759:                sch = sch->next;
        -: 2760:            }
        -: 2761:        }
        -: 2762:        /* assert that the destination had enough space for the source */
    13516: 2763:        assert(remain == 0);
        -: 2764:    } else {
        -: 2765:        int done = 0;
        -: 2766:        /* Fill dch's via a non-chunked item. */
    40548: 2767:        while (len > done && dch) {
    27032: 2768:            int todo = (dch->size - dch->used < len - done)
    27032: 2769:                ? dch->size - dch->used : len - done;
        -: 2770:            //assert(dch->size - dch->used != 0);
    54064: 2771:            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
    27032: 2772:            done += todo;
    27032: 2773:            dch->used += todo;
    27032: 2774:            assert(dch->used <= dch->size);
    27032: 2775:            if (dch->size == dch->used) {
    27032: 2776:                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
    27032: 2777:                if (tch) {
        -: 2778:                    dch = tch;
        -: 2779:                } else {
        -: 2780:                    return -1;
        -: 2781:                }
        -: 2782:            }
        -: 2783:        }
    13516: 2784:        assert(len == done);
        -: 2785:    }
        -: 2786:    return 0;
        -: 2787:}
        -: 2788:
    16012: 2789:static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    16012: 2790:    if (comm == NREAD_APPEND) {
     8006: 2791:        if (new_it->it_flags & ITEM_CHUNKED) {
    13516: 2792:            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
     6758: 2793:                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
        -: 2794:                return -1;
        -: 2795:            }
        -: 2796:        } else {
     2496: 2797:            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
     1248: 2798:            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        -: 2799:        }
        -: 2800:    } else {
        -: 2801:        /* NREAD_PREPEND */
     8006: 2802:        if (new_it->it_flags & ITEM_CHUNKED) {
    13516: 2803:            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
     6758: 2804:                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
        -: 2805:                return -1;
        -: 2806:            }
        -: 2807:        } else {
     2496: 2808:            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
     1248: 2809:            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        -: 2810:        }
        -: 2811:    }
        -: 2812:    return 0;
        -: 2813:}
        -: 2814:
        -: 2815:/*
        -: 2816: * Stores an item in the cache according to the semantics of one of the set
        -: 2817: * commands. In threaded mode, this is protected by the cache lock.
        -: 2818: *
        -: 2819: * Returns the state of storage.
        -: 2820: */
   102902: 2821:enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
   102902: 2822:    char *key = ITEM_key(it);
   102902: 2823:    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
   102902: 2824:    enum store_item_type stored = NOT_STORED;
        -: 2825:
   102902: 2826:    item *new_it = NULL;
        -: 2827:    uint32_t flags;
        -: 2828:
   102902: 2829:    if (old_it != NULL && comm == NREAD_ADD) {
        -: 2830:        /* add only adds a nonexistent item, but promote to head of LRU */
       23: 2831:        do_item_update(old_it);
   170013: 2832:    } else if (!old_it && (comm == NREAD_REPLACE
    67134: 2833:        || comm == NREAD_APPEND || comm == NREAD_PREPEND))
        -: 2834:    {
        -: 2835:        /* replace only replaces an existing value; don't store */
   102803: 2836:    } else if (comm == NREAD_CAS) {
        -: 2837:        /* validate cas operation */
       17: 2838:        if(old_it == NULL) {
        -: 2839:            // LRU expired
        3: 2840:            stored = NOT_FOUND;
        3: 2841:            pthread_mutex_lock(&c->thread->stats.mutex);
        3: 2842:            c->thread->stats.cas_misses++;
        3: 2843:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2844:        }
       14: 2845:        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {
        -: 2846:            // cas validates
        -: 2847:            // it and old_it may belong to different classes.
        -: 2848:            // I'm updating the stats for the one that's getting pushed out
        7: 2849:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 2850:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
        7: 2851:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2852:
        -: 2853:            STORAGE_delete(c->thread->storage, old_it);
        7: 2854:            item_replace(old_it, it, hv);
        7: 2855:            stored = STORED;
        -: 2856:        } else {
        7: 2857:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 2858:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
        7: 2859:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2860:
        7: 2861:            if(settings.verbose > 1) {
    #####: 2862:                fprintf(stderr, "CAS:  failure: expected %llu, got %llu\n",
    #####: 2863:                        (unsigned long long)ITEM_get_cas(old_it),
    #####: 2864:                        (unsigned long long)ITEM_get_cas(it));
        -: 2865:            }
        -: 2866:            stored = EXISTS;
        -: 2867:        }
        -: 2868:    } else {
   102786: 2869:        int failed_alloc = 0;
        -: 2870:        /*
        -: 2871:         * Append - combine new and old record into single one. Here it's
        -: 2872:         * atomic and thread-safe.
        -: 2873:         */
   102786: 2874:        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {
        -: 2875:            /*
        -: 2876:             * Validate CAS
        -: 2877:             */
    16012: 2878:            if (ITEM_get_cas(it) != 0) {
        -: 2879:                // CAS much be equal
    #####: 2880:                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {
    #####: 2881:                    stored = EXISTS;
        -: 2882:                }
        -: 2883:            }
        -: 2884:#ifdef EXTSTORE
        -: 2885:            if ((old_it->it_flags & ITEM_HDR) != 0) {
        -: 2886:                /* block append/prepend from working with extstore-d items.
        -: 2887:                 * also don't replace the header with the append chunk
        -: 2888:                 * accidentally, so mark as a failed_alloc.
        -: 2889:                 */
        -: 2890:                failed_alloc = 1;
        -: 2891:            } else
        -: 2892:#endif
    16012: 2893:            if (stored == NOT_STORED) {
        -: 2894:                /* we have it and old_it here - alloc memory to hold both */
        -: 2895:                /* flags was already lost - so recover them from ITEM_suffix(it) */
    16012: 2896:                FLAGS_CONV(settings.inline_ascii_response, old_it, flags);
    16012: 2897:                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);
        -: 2898:
        -: 2899:                /* copy data from it and old_it to new_it */
    16012: 2900:                if (new_it == NULL || _store_item_copy_data(comm, old_it, new_it, it) == -1) {
    #####: 2901:                    failed_alloc = 1;
    #####: 2902:                    stored = NOT_STORED;
        -: 2903:                    // failed data copy, free up.
    #####: 2904:                    if (new_it != NULL)
    #####: 2905:                        item_remove(new_it);
        -: 2906:                } else {
        -: 2907:                    it = new_it;
        -: 2908:                }
        -: 2909:            }
        -: 2910:        }
        -: 2911:
   102786: 2912:        if (stored == NOT_STORED && failed_alloc == 0) {
   102786: 2913:            if (old_it != NULL) {
        -: 2914:                STORAGE_delete(c->thread->storage, old_it);
    35731: 2915:                item_replace(old_it, it, hv);
        -: 2916:            } else {
    67055: 2917:                do_item_link(it, hv);
        -: 2918:            }
        -: 2919:
   102786: 2920:            c->cas = ITEM_get_cas(it);
        -: 2921:
   102786: 2922:            stored = STORED;
        -: 2923:        }
        -: 2924:    }
        -: 2925:
   102902: 2926:    if (old_it != NULL)
    35768: 2927:        do_item_remove(old_it);         /* release our reference */
   102902: 2928:    if (new_it != NULL)
    16012: 2929:        do_item_remove(new_it);
        -: 2930:
   102902: 2931:    if (stored == STORED) {
   102793: 2932:        c->cas = ITEM_get_cas(it);
        -: 2933:    }
   102902: 2934:    LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
        -: 2935:            stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it));
        -: 2936:
   102902: 2937:    return stored;
        -: 2938:}
        -: 2939:
        -: 2940:typedef struct token_s {
        -: 2941:    char *value;
        -: 2942:    size_t length;
        -: 2943:} token_t;
        -: 2944:
        -: 2945:#define COMMAND_TOKEN 0
        -: 2946:#define SUBCOMMAND_TOKEN 1
        -: 2947:#define KEY_TOKEN 1
        -: 2948:
        -: 2949:#define MAX_TOKENS 8
        -: 2950:
        -: 2951:/*
        -: 2952: * Tokenize the command string by replacing whitespace with '\0' and update
        -: 2953: * the token array tokens with pointer to start of each token and length.
        -: 2954: * Returns total number of tokens.  The last valid token is the terminal
        -: 2955: * token (value points to the first unprocessed character of the string and
        -: 2956: * length zero).
        -: 2957: *
        -: 2958: * Usage example:
        -: 2959: *
        -: 2960: *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {
        -: 2961: *      for(int ix = 0; tokens[ix].length != 0; ix++) {
        -: 2962: *          ...
        -: 2963: *      }
        -: 2964: *      ncommand = tokens[ix].value - command;
        -: 2965: *      command  = tokens[ix].value;
        -: 2966: *   }
        -: 2967: */
   200623: 2968:static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
        -: 2969:    char *s, *e;
   200623: 2970:    size_t ntokens = 0;
   200623: 2971:    size_t len = strlen(command);
   200623: 2972:    unsigned int i = 0;
        -: 2973:
   200623: 2974:    assert(command != NULL && tokens != NULL && max_tokens > 1);
        -: 2975:
        -: 2976:    s = e = command;
 21142377: 2977:    for (i = 0; i < len; i++) {
 21142481: 2978:        if (*e == ' ') {
   512298: 2979:            if (s != e) {
   512287: 2980:                tokens[ntokens].value = s;
   512287: 2981:                tokens[ntokens].length = e - s;
   512287: 2982:                ntokens++;
   512287: 2983:                *e = '\0';
   512287: 2984:                if (ntokens == max_tokens - 1) {
      104: 2985:                    e++;
      104: 2986:                    s = e; /* so we don't add an extra token */
      104: 2987:                    break;
        -: 2988:                }
        -: 2989:            }
   512194: 2990:            s = e + 1;
        -: 2991:        }
 21142377: 2992:        e++;
        -: 2993:    }
        -: 2994:
   200622: 2995:    if (s != e) {
   200516: 2996:        tokens[ntokens].value = s;
   200516: 2997:        tokens[ntokens].length = e - s;
   200516: 2998:        ntokens++;
        -: 2999:    }
        -: 3000:
        -: 3001:    /*
        -: 3002:     * If we scanned the whole string, the terminal value pointer is null,
        -: 3003:     * otherwise it is the first unprocessed character.
        -: 3004:     */
   200622: 3005:    tokens[ntokens].value =  *e == '\0' ? NULL : e;
   200622: 3006:    tokens[ntokens].length = 0;
   200622: 3007:    ntokens++;
        -: 3008:
   200622: 3009:    return ntokens;
        -: 3010:}
        -: 3011:
        -: 3012:/* set up a connection to write a buffer then free it, used for stats */
     2712: 3013:static void write_and_free(conn *c, char *buf, int bytes) {
     2712: 3014:    if (buf) {
     2712: 3015:        c->write_and_free = buf;
     2712: 3016:        c->wcurr = buf;
     2712: 3017:        c->wbytes = bytes;
     2712: 3018:        conn_set_state(c, conn_write);
     2712: 3019:        c->write_and_go = conn_new_cmd;
        -: 3020:    } else {
    #####: 3021:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3022:    }
     2712: 3023:}
        -: 3024:
    85341: 3025:static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
        -: 3026:{
    85341: 3027:    int noreply_index = ntokens - 2;
        -: 3028:
        -: 3029:    /*
        -: 3030:      NOTE: this function is not the first place where we are going to
        -: 3031:      send the reply.  We could send it instead from process_command()
        -: 3032:      if the request line has wrong number of tokens.  However parsing
        -: 3033:      malformed line for "noreply" option is not reliable anyway, so
        -: 3034:      it can't be helped.
        -: 3035:    */
    85341: 3036:    if (tokens[noreply_index].value
    85341: 3037:        && strcmp(tokens[noreply_index].value, "noreply") == 0) {
    65717: 3038:        c->noreply = true;
        -: 3039:    }
    85341: 3040:    return c->noreply;
        -: 3041:}
        -: 3042:
   209690: 3043:void append_stat(const char *name, ADD_STAT add_stats, conn *c,
        -: 3044:                 const char *fmt, ...) {
        -: 3045:    char val_str[STAT_VAL_LEN];
        -: 3046:    int vlen;
        -: 3047:    va_list ap;
        -: 3048:
   209690: 3049:    assert(name);
   209690: 3050:    assert(add_stats);
   209690: 3051:    assert(c);
   209690: 3052:    assert(fmt);
        -: 3053:
   209690: 3054:    va_start(ap, fmt);
   209690: 3055:    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
   209690: 3056:    va_end(ap);
        -: 3057:
   209690: 3058:    add_stats(name, strlen(name), val_str, vlen, c);
   209690: 3059:}
        -: 3060:
       10: 3061:inline static void process_stats_detail(conn *c, const char *command) {
       10: 3062:    assert(c != NULL);
        -: 3063:
       10: 3064:    if (strcmp(command, "on") == 0) {
        1: 3065:        settings.detail_enabled = 1;
        1: 3066:        out_string(c, "OK");
        -: 3067:    }
        9: 3068:    else if (strcmp(command, "off") == 0) {
        1: 3069:        settings.detail_enabled = 0;
        1: 3070:        out_string(c, "OK");
        -: 3071:    }
        8: 3072:    else if (strcmp(command, "dump") == 0) {
        -: 3073:        int len;
        8: 3074:        char *stats = stats_prefix_dump(&len);
        8: 3075:        write_and_free(c, stats, len);
        -: 3076:    }
        -: 3077:    else {
    #####: 3078:        out_string(c, "CLIENT_ERROR usage: stats detail on|off|dump");
        -: 3079:    }
       10: 3080:}
        -: 3081:
        -: 3082:/* return server specific stats only */
     2647: 3083:static void server_stats(ADD_STAT add_stats, conn *c) {
     2647: 3084:    pid_t pid = getpid();
     2647: 3085:    rel_time_t now = current_time;
        -: 3086:
        -: 3087:    struct thread_stats thread_stats;
     2647: 3088:    threadlocal_stats_aggregate(&thread_stats);
        -: 3089:    struct slab_stats slab_stats;
     2647: 3090:    slab_stats_aggregate(&thread_stats, &slab_stats);
        -: 3091:#ifdef EXTSTORE
        -: 3092:    struct extstore_stats st;
        -: 3093:#endif
        -: 3094:#ifndef WIN32
        -: 3095:    struct rusage usage;
     2647: 3096:    getrusage(RUSAGE_SELF, &usage);
        -: 3097:#endif /* !WIN32 */
        -: 3098:
     2647: 3099:    STATS_LOCK();
        -: 3100:
     2647: 3101:    APPEND_STAT("pid", "%lu", (long)pid);
     2647: 3102:    APPEND_STAT("uptime", "%u", now - ITEM_UPDATE_INTERVAL);
     2647: 3103:    APPEND_STAT("time", "%ld", now + (long)process_started);
     2647: 3104:    APPEND_STAT("version", "%s", VERSION);
     2647: 3105:    APPEND_STAT("libevent", "%s", event_get_version());
     2647: 3106:    APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));
        -: 3107:
        -: 3108:#ifndef WIN32
     2647: 3109:    append_stat("rusage_user", add_stats, c, "%ld.%06ld",
     2647: 3110:                (long)usage.ru_utime.tv_sec,
     2647: 3111:                (long)usage.ru_utime.tv_usec);
     2647: 3112:    append_stat("rusage_system", add_stats, c, "%ld.%06ld",
     2647: 3113:                (long)usage.ru_stime.tv_sec,
     2647: 3114:                (long)usage.ru_stime.tv_usec);
        -: 3115:#endif /* !WIN32 */
        -: 3116:
     2647: 3117:    APPEND_STAT("max_connections", "%d", settings.maxconns);
     2647: 3118:    APPEND_STAT("curr_connections", "%llu", (unsigned long long)stats_state.curr_conns - 1);
     2647: 3119:    APPEND_STAT("total_connections", "%llu", (unsigned long long)stats.total_conns);
     2647: 3120:    if (settings.maxconns_fast) {
     2637: 3121:        APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
        -: 3122:    }
     2647: 3123:    APPEND_STAT("connection_structures", "%u", stats_state.conn_structs);
     2647: 3124:    APPEND_STAT("reserved_fds", "%u", stats_state.reserved_fds);
     2647: 3125:    APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
     2647: 3126:    APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
     2647: 3127:    APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
     2647: 3128:    APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
     2647: 3129:    APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
     2647: 3130:    APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
     2647: 3131:    APPEND_STAT("get_expired", "%llu", (unsigned long long)thread_stats.get_expired);
     2647: 3132:    APPEND_STAT("get_flushed", "%llu", (unsigned long long)thread_stats.get_flushed);
        -: 3133:#ifdef EXTSTORE
        -: 3134:    if (c->thread->storage) {
        -: 3135:        APPEND_STAT("get_extstore", "%llu", (unsigned long long)thread_stats.get_extstore);
        -: 3136:        APPEND_STAT("get_aborted_extstore", "%llu", (unsigned long long)thread_stats.get_aborted_extstore);
        -: 3137:        APPEND_STAT("get_oom_extstore", "%llu", (unsigned long long)thread_stats.get_oom_extstore);
        -: 3138:        APPEND_STAT("recache_from_extstore", "%llu", (unsigned long long)thread_stats.recache_from_extstore);
        -: 3139:        APPEND_STAT("miss_from_extstore", "%llu", (unsigned long long)thread_stats.miss_from_extstore);
        -: 3140:        APPEND_STAT("badcrc_from_extstore", "%llu", (unsigned long long)thread_stats.badcrc_from_extstore);
        -: 3141:    }
        -: 3142:#endif
     2647: 3143:    APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
     2647: 3144:    APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
     2647: 3145:    APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
     2647: 3146:    APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
     2647: 3147:    APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
     2647: 3148:    APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
     2647: 3149:    APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
     2647: 3150:    APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
     2647: 3151:    APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
     2647: 3152:    APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
     2647: 3153:    APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
     2647: 3154:    APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
     2647: 3155:    APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
     2647: 3156:    if (settings.idle_timeout) {
        9: 3157:        APPEND_STAT("idle_kicks", "%llu", (unsigned long long)thread_stats.idle_kicks);
        -: 3158:    }
     2647: 3159:    APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
     2647: 3160:    APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
     2647: 3161:    APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
     2647: 3162:    APPEND_STAT("accepting_conns", "%u", stats_state.accepting_conns);
     2647: 3163:    APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
     2647: 3164:    APPEND_STAT("time_in_listen_disabled_us", "%llu", stats.time_in_listen_disabled_us);
     2647: 3165:    APPEND_STAT("threads", "%d", settings.num_threads);
     2647: 3166:    APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
     2647: 3167:    APPEND_STAT("hash_power_level", "%u", stats_state.hash_power_level);
     2647: 3168:    APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats_state.hash_bytes);
     2647: 3169:    APPEND_STAT("hash_is_expanding", "%u", stats_state.hash_is_expanding);
     2647: 3170:    if (settings.slab_reassign) {
     2637: 3171:        APPEND_STAT("slab_reassign_rescues", "%llu", stats.slab_reassign_rescues);
     2637: 3172:        APPEND_STAT("slab_reassign_chunk_rescues", "%llu", stats.slab_reassign_chunk_rescues);
     2637: 3173:        APPEND_STAT("slab_reassign_evictions_nomem", "%llu", stats.slab_reassign_evictions_nomem);
     2637: 3174:        APPEND_STAT("slab_reassign_inline_reclaim", "%llu", stats.slab_reassign_inline_reclaim);
     2637: 3175:        APPEND_STAT("slab_reassign_busy_items", "%llu", stats.slab_reassign_busy_items);
     2637: 3176:        APPEND_STAT("slab_reassign_busy_deletes", "%llu", stats.slab_reassign_busy_deletes);
     2637: 3177:        APPEND_STAT("slab_reassign_running", "%u", stats_state.slab_reassign_running);
     2637: 3178:        APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
        -: 3179:    }
     2647: 3180:    if (settings.lru_crawler) {
     2624: 3181:        APPEND_STAT("lru_crawler_running", "%u", stats_state.lru_crawler_running);
     2624: 3182:        APPEND_STAT("lru_crawler_starts", "%u", stats.lru_crawler_starts);
        -: 3183:    }
     2647: 3184:    if (settings.lru_maintainer_thread) {
     2622: 3185:        APPEND_STAT("lru_maintainer_juggles", "%llu", (unsigned long long)stats.lru_maintainer_juggles);
        -: 3186:    }
     2647: 3187:    APPEND_STAT("malloc_fails", "%llu",
        -: 3188:                (unsigned long long)stats.malloc_fails);
     2647: 3189:    APPEND_STAT("log_worker_dropped", "%llu", (unsigned long long)stats.log_worker_dropped);
     2647: 3190:    APPEND_STAT("log_worker_written", "%llu", (unsigned long long)stats.log_worker_written);
     2647: 3191:    APPEND_STAT("log_watcher_skipped", "%llu", (unsigned long long)stats.log_watcher_skipped);
     2647: 3192:    APPEND_STAT("log_watcher_sent", "%llu", (unsigned long long)stats.log_watcher_sent);
     2647: 3193:    STATS_UNLOCK();
        -: 3194:#ifdef EXTSTORE
        -: 3195:    if (c->thread->storage) {
        -: 3196:        STATS_LOCK();
        -: 3197:        APPEND_STAT("extstore_compact_lost", "%llu", (unsigned long long)stats.extstore_compact_lost);
        -: 3198:        APPEND_STAT("extstore_compact_rescues", "%llu", (unsigned long long)stats.extstore_compact_rescues);
        -: 3199:        APPEND_STAT("extstore_compact_skipped", "%llu", (unsigned long long)stats.extstore_compact_skipped);
        -: 3200:        STATS_UNLOCK();
        -: 3201:        extstore_get_stats(c->thread->storage, &st);
        -: 3202:        APPEND_STAT("extstore_page_allocs", "%llu", (unsigned long long)st.page_allocs);
        -: 3203:        APPEND_STAT("extstore_page_evictions", "%llu", (unsigned long long)st.page_evictions);
        -: 3204:        APPEND_STAT("extstore_page_reclaims", "%llu", (unsigned long long)st.page_reclaims);
        -: 3205:        APPEND_STAT("extstore_pages_free", "%llu", (unsigned long long)st.pages_free);
        -: 3206:        APPEND_STAT("extstore_pages_used", "%llu", (unsigned long long)st.pages_used);
        -: 3207:        APPEND_STAT("extstore_objects_evicted", "%llu", (unsigned long long)st.objects_evicted);
        -: 3208:        APPEND_STAT("extstore_objects_read", "%llu", (unsigned long long)st.objects_read);
        -: 3209:        APPEND_STAT("extstore_objects_written", "%llu", (unsigned long long)st.objects_written);
        -: 3210:        APPEND_STAT("extstore_objects_used", "%llu", (unsigned long long)st.objects_used);
        -: 3211:        APPEND_STAT("extstore_bytes_evicted", "%llu", (unsigned long long)st.bytes_evicted);
        -: 3212:        APPEND_STAT("extstore_bytes_written", "%llu", (unsigned long long)st.bytes_written);
        -: 3213:        APPEND_STAT("extstore_bytes_read", "%llu", (unsigned long long)st.bytes_read);
        -: 3214:        APPEND_STAT("extstore_bytes_used", "%llu", (unsigned long long)st.bytes_used);
        -: 3215:        APPEND_STAT("extstore_bytes_fragmented", "%llu", (unsigned long long)st.bytes_fragmented);
        -: 3216:        APPEND_STAT("extstore_limit_maxbytes", "%llu", (unsigned long long)(st.page_count * st.page_size));
        -: 3217:    }
        -: 3218:#endif
     2647: 3219:}
        -: 3220:
       17: 3221:static void process_stat_settings(ADD_STAT add_stats, void *c) {
       17: 3222:    assert(add_stats);
       17: 3223:    APPEND_STAT("maxbytes", "%llu", (unsigned long long)settings.maxbytes);
       17: 3224:    APPEND_STAT("maxconns", "%d", settings.maxconns);
       17: 3225:    APPEND_STAT("tcpport", "%d", settings.port);
       17: 3226:    APPEND_STAT("udpport", "%d", settings.udpport);
       17: 3227:    APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
       17: 3228:    APPEND_STAT("verbosity", "%d", settings.verbose);
       17: 3229:    APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
       17: 3230:    APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
       17: 3231:    APPEND_STAT("domain_socket", "%s",
        -: 3232:                settings.socketpath ? settings.socketpath : "NULL");
       17: 3233:    APPEND_STAT("umask", "%o", settings.access);
       17: 3234:    APPEND_STAT("growth_factor", "%.2f", settings.factor);
       17: 3235:    APPEND_STAT("chunk_size", "%d", settings.chunk_size);
       17: 3236:    APPEND_STAT("num_threads", "%d", settings.num_threads);
       17: 3237:    APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
       17: 3238:    APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
       17: 3239:    APPEND_STAT("detail_enabled", "%s",
        -: 3240:                settings.detail_enabled ? "yes" : "no");
       17: 3241:    APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
       17: 3242:    APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
       17: 3243:    APPEND_STAT("tcp_backlog", "%d", settings.backlog);
       34: 3244:    APPEND_STAT("binding_protocol", "%s",
        -: 3245:                prot_text(settings.binding_protocol));
       17: 3246:    APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
       17: 3247:    APPEND_STAT("item_size_max", "%d", settings.item_size_max);
       17: 3248:    APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
       17: 3249:    APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
       17: 3250:    APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
       17: 3251:    APPEND_STAT("slab_automove", "%d", settings.slab_automove);
       17: 3252:    APPEND_STAT("slab_automove_ratio", "%.2f", settings.slab_automove_ratio);
       17: 3253:    APPEND_STAT("slab_automove_window", "%u", settings.slab_automove_window);
       17: 3254:    APPEND_STAT("slab_chunk_max", "%d", settings.slab_chunk_size_max);
       17: 3255:    APPEND_STAT("lru_crawler", "%s", settings.lru_crawler ? "yes" : "no");
       17: 3256:    APPEND_STAT("lru_crawler_sleep", "%d", settings.lru_crawler_sleep);
       17: 3257:    APPEND_STAT("lru_crawler_tocrawl", "%lu", (unsigned long)settings.lru_crawler_tocrawl);
       17: 3258:    APPEND_STAT("tail_repair_time", "%d", settings.tail_repair_time);
       17: 3259:    APPEND_STAT("flush_enabled", "%s", settings.flush_enabled ? "yes" : "no");
       17: 3260:    APPEND_STAT("dump_enabled", "%s", settings.dump_enabled ? "yes" : "no");
       17: 3261:    APPEND_STAT("hash_algorithm", "%s", settings.hash_algorithm);
       17: 3262:    APPEND_STAT("lru_maintainer_thread", "%s", settings.lru_maintainer_thread ? "yes" : "no");
       17: 3263:    APPEND_STAT("lru_segmented", "%s", settings.lru_segmented ? "yes" : "no");
       17: 3264:    APPEND_STAT("hot_lru_pct", "%d", settings.hot_lru_pct);
       17: 3265:    APPEND_STAT("warm_lru_pct", "%d", settings.warm_lru_pct);
       17: 3266:    APPEND_STAT("hot_max_factor", "%.2f", settings.hot_max_factor);
       17: 3267:    APPEND_STAT("warm_max_factor", "%.2f", settings.warm_max_factor);
       17: 3268:    APPEND_STAT("temp_lru", "%s", settings.temp_lru ? "yes" : "no");
       17: 3269:    APPEND_STAT("temporary_ttl", "%u", settings.temporary_ttl);
       17: 3270:    APPEND_STAT("idle_timeout", "%d", settings.idle_timeout);
       17: 3271:    APPEND_STAT("watcher_logbuf_size", "%u", settings.logger_watcher_buf_size);
       17: 3272:    APPEND_STAT("worker_logbuf_size", "%u", settings.logger_buf_size);
       17: 3273:    APPEND_STAT("track_sizes", "%s", item_stats_sizes_status() ? "yes" : "no");
       17: 3274:    APPEND_STAT("inline_ascii_response", "%s", settings.inline_ascii_response ? "yes" : "no");
        -: 3275:#ifdef HAVE_DROP_PRIVILEGES
        -: 3276:    APPEND_STAT("drop_privileges", "%s", settings.drop_privileges ? "yes" : "no");
        -: 3277:#endif
        -: 3278:#ifdef EXTSTORE
        -: 3279:    APPEND_STAT("ext_item_size", "%u", settings.ext_item_size);
        -: 3280:    APPEND_STAT("ext_item_age", "%u", settings.ext_item_age);
        -: 3281:    APPEND_STAT("ext_low_ttl", "%u", settings.ext_low_ttl);
        -: 3282:    APPEND_STAT("ext_recache_rate", "%u", settings.ext_recache_rate);
        -: 3283:    APPEND_STAT("ext_wbuf_size", "%u", settings.ext_wbuf_size);
        -: 3284:    APPEND_STAT("ext_compact_under", "%u", settings.ext_compact_under);
        -: 3285:    APPEND_STAT("ext_drop_under", "%u", settings.ext_drop_under);
        -: 3286:    APPEND_STAT("ext_max_frag", "%.2f", settings.ext_max_frag);
        -: 3287:    APPEND_STAT("slab_automove_freeratio", "%.3f", settings.slab_automove_freeratio);
        -: 3288:    APPEND_STAT("ext_drop_unread", "%s", settings.ext_drop_unread ? "yes" : "no");
        -: 3289:#endif
       17: 3290:}
        -: 3291:
       10: 3292:static void conn_to_str(const conn *c, char *buf) {
        -: 3293:    char addr_text[MAXPATHLEN];
        -: 3294:
       10: 3295:    if (!c) {
        -: 3296:        strcpy(buf, "<null>");
       10: 3297:    } else if (c->state == conn_closed) {
        -: 3298:        strcpy(buf, "<closed>");
        -: 3299:    } else {
       10: 3300:        const char *protoname = "?";
        -: 3301:        struct sockaddr_in6 local_addr;
       10: 3302:        struct sockaddr *addr = (void *)&c->request_addr;
        -: 3303:        int af;
       10: 3304:        unsigned short port = 0;
        -: 3305:
        -: 3306:        /* For listen ports and idle UDP ports, show listen address */
       18: 3307:        if (c->state == conn_listening ||
       12: 3308:                (IS_UDP(c->transport) &&
        -: 3309:                 c->state == conn_read)) {
        6: 3310:            socklen_t local_addr_len = sizeof(local_addr);
        -: 3311:
        6: 3312:            if (getsockname(c->sfd,
        -: 3313:                        (struct sockaddr *)&local_addr,
        -: 3314:                        &local_addr_len) == 0) {
        6: 3315:                addr = (struct sockaddr *)&local_addr;
        -: 3316:            }
        -: 3317:        }
        -: 3318:
       10: 3319:        af = addr->sa_family;
       10: 3320:        addr_text[0] = '\0';
        -: 3321:
       10: 3322:        switch (af) {
        -: 3323:            case AF_INET:
        7: 3324:                (void) inet_ntop(af,
        7: 3325:                        &((struct sockaddr_in *)addr)->sin_addr,
        -: 3326:                        addr_text,
        -: 3327:                        sizeof(addr_text) - 1);
        7: 3328:                port = ntohs(((struct sockaddr_in *)addr)->sin_port);
        7: 3329:                protoname = IS_UDP(c->transport) ? "udp" : "tcp";
        -: 3330:                break;
        -: 3331:
        -: 3332:            case AF_INET6:
    #####: 3333:                addr_text[0] = '[';
    #####: 3334:                addr_text[1] = '\0';
    #####: 3335:                if (inet_ntop(af,
    #####: 3336:                        &((struct sockaddr_in6 *)addr)->sin6_addr,
        -: 3337:                        addr_text + 1,
        -: 3338:                        sizeof(addr_text) - 2)) {
        -: 3339:                    strcat(addr_text, "]");
        -: 3340:                }
    #####: 3341:                port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
    #####: 3342:                protoname = IS_UDP(c->transport) ? "udp6" : "tcp6";
        -: 3343:                break;
        -: 3344:
        -: 3345:            case AF_UNIX:
        1: 3346:                strncpy(addr_text,
        1: 3347:                        ((struct sockaddr_un *)addr)->sun_path,
        -: 3348:                        sizeof(addr_text) - 1);
        1: 3349:                addr_text[sizeof(addr_text)-1] = '\0';
        1: 3350:                protoname = "unix";
        1: 3351:                break;
        -: 3352:        }
        -: 3353:
       10: 3354:        if (strlen(addr_text) < 2) {
        -: 3355:            /* Most likely this is a connected UNIX-domain client which
        -: 3356:             * has no peer socket address, but there's no portable way
        -: 3357:             * to tell for sure.
        -: 3358:             */
        -: 3359:            sprintf(addr_text, "<AF %d>", af);
        -: 3360:        }
        -: 3361:
       10: 3362:        if (port) {
        7: 3363:            sprintf(buf, "%s:%s:%u", protoname, addr_text, port);
        -: 3364:        } else {
        -: 3365:            sprintf(buf, "%s:%s", protoname, addr_text);
        -: 3366:        }
        -: 3367:    }
       10: 3368:}
        -: 3369:
        2: 3370:static void process_stats_conns(ADD_STAT add_stats, void *c) {
        -: 3371:    int i;
        -: 3372:    char key_str[STAT_KEY_LEN];
        -: 3373:    char val_str[STAT_VAL_LEN];
        -: 3374:    char conn_name[MAXPATHLEN + sizeof("unix:") + sizeof("65535")];
        2: 3375:    int klen = 0, vlen = 0;
        -: 3376:
        2: 3377:    assert(add_stats);
        -: 3378:
     2048: 3379:    for (i = 0; i < max_fds; i++) {
     2048: 3380:        if (conns[i]) {
        -: 3381:            /* This is safe to do unlocked because conns are never freed; the
        -: 3382:             * worst that'll happen will be a minor inconsistency in the
        -: 3383:             * output -- not worth the complexity of the locking that'd be
        -: 3384:             * required to prevent it.
        -: 3385:             */
       10: 3386:            if (conns[i]->state != conn_closed) {
       10: 3387:                conn_to_str(conns[i], conn_name);
        -: 3388:
       20: 3389:                APPEND_NUM_STAT(i, "addr", "%s", conn_name);
       30: 3390:                APPEND_NUM_STAT(i, "state", "%s",
        -: 3391:                        state_text(conns[i]->state));
       20: 3392:                APPEND_NUM_STAT(i, "secs_since_last_cmd", "%d",
        -: 3393:                        current_time - conns[i]->last_cmd_time);
        -: 3394:            }
        -: 3395:        }
        -: 3396:    }
        2: 3397:}
        -: 3398:#ifdef EXTSTORE
        -: 3399:static void process_extstore_stats(ADD_STAT add_stats, conn *c) {
        -: 3400:    int i;
        -: 3401:    char key_str[STAT_KEY_LEN];
        -: 3402:    char val_str[STAT_VAL_LEN];
        -: 3403:    int klen = 0, vlen = 0;
        -: 3404:    struct extstore_stats st;
        -: 3405:
        -: 3406:    assert(add_stats);
        -: 3407:
        -: 3408:    void *storage = c->thread->storage;
        -: 3409:    extstore_get_stats(storage, &st);
        -: 3410:    st.page_data = calloc(st.page_count, sizeof(struct extstore_page_data));
        -: 3411:    extstore_get_page_data(storage, &st);
        -: 3412:
        -: 3413:    for (i = 0; i < st.page_count; i++) {
        -: 3414:        APPEND_NUM_STAT(i, "version", "%llu",
        -: 3415:                (unsigned long long) st.page_data[i].version);
        -: 3416:        APPEND_NUM_STAT(i, "bytes", "%llu",
        -: 3417:                (unsigned long long) st.page_data[i].bytes_used);
        -: 3418:        APPEND_NUM_STAT(i, "bucket", "%u",
        -: 3419:                st.page_data[i].bucket);
        -: 3420:        APPEND_NUM_STAT(i, "free_bucket", "%u",
        -: 3421:                st.page_data[i].free_bucket);
        -: 3422:    }
        -: 3423:}
        -: 3424:#endif
     2695: 3425:static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
     2695: 3426:    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
     2695: 3427:    assert(c != NULL);
        -: 3428:
     2695: 3429:    if (ntokens < 2) {
    #####: 3430:        out_string(c, "CLIENT_ERROR bad command line");
    #####: 3431:        return;
        -: 3432:    }
        -: 3433:
     2695: 3434:    if (ntokens == 2) {
     2627: 3435:        server_stats(&append_stats, c);
     2627: 3436:        (void)get_stats(NULL, 0, &append_stats, c);
       68: 3437:    } else if (strcmp(subcommand, "reset") == 0) {
        3: 3438:        stats_reset();
        3: 3439:        out_string(c, "RESET");
        3: 3440:        return ;
       65: 3441:    } else if (strcmp(subcommand, "detail") == 0) {
        -: 3442:        /* NOTE: how to tackle detail with binary? */
       10: 3443:        if (ntokens < 4)
    #####: 3444:            process_stats_detail(c, "");  /* outputs the error message */
        -: 3445:        else
       10: 3446:            process_stats_detail(c, tokens[2].value);
        -: 3447:        /* Output already generated */
        -: 3448:        return ;
       55: 3449:    } else if (strcmp(subcommand, "settings") == 0) {
       16: 3450:        process_stat_settings(&append_stats, c);
       39: 3451:    } else if (strcmp(subcommand, "cachedump") == 0) {
        -: 3452:        char *buf;
        3: 3453:        unsigned int bytes, id, limit = 0;
        -: 3454:
        3: 3455:        if (!settings.dump_enabled) {
    #####: 3456:            out_string(c, "CLIENT_ERROR stats cachedump not allowed");
    #####: 3457:            return;
        -: 3458:        }
        -: 3459:
        3: 3460:        if (ntokens < 5) {
    #####: 3461:            out_string(c, "CLIENT_ERROR bad command line");
    #####: 3462:            return;
        -: 3463:        }
        -: 3464:
        6: 3465:        if (!safe_strtoul(tokens[2].value, &id) ||
        3: 3466:            !safe_strtoul(tokens[3].value, &limit)) {
    #####: 3467:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3468:            return;
        -: 3469:        }
        -: 3470:
        3: 3471:        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
        1: 3472:            out_string(c, "CLIENT_ERROR Illegal slab id");
        1: 3473:            return;
        -: 3474:        }
        -: 3475:
        2: 3476:        buf = item_cachedump(id, limit, &bytes);
        2: 3477:        write_and_free(c, buf, bytes);
        2: 3478:        return ;
       36: 3479:    } else if (strcmp(subcommand, "conns") == 0) {
        2: 3480:        process_stats_conns(&append_stats, c);
        -: 3481:#ifdef EXTSTORE
        -: 3482:    } else if (strcmp(subcommand, "extstore") == 0) {
        -: 3483:        process_extstore_stats(&append_stats, c);
        -: 3484:#endif
        -: 3485:    } else {
        -: 3486:        /* getting here means that the subcommand is either engine specific or
        -: 3487:           is invalid. query the engine and see. */
       34: 3488:        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
       34: 3489:            if (c->stats.buffer == NULL) {
    #####: 3490:                out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3491:            } else {
       34: 3492:                write_and_free(c, c->stats.buffer, c->stats.offset);
       34: 3493:                c->stats.buffer = NULL;
        -: 3494:            }
        -: 3495:        } else {
    #####: 3496:            out_string(c, "ERROR");
        -: 3497:        }
        -: 3498:        return ;
        -: 3499:    }
        -: 3500:
        -: 3501:    /* append terminator and start the transfer */
     2645: 3502:    append_stats(NULL, 0, NULL, 0, c);
        -: 3503:
     2645: 3504:    if (c->stats.buffer == NULL) {
    #####: 3505:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3506:    } else {
     2645: 3507:        write_and_free(c, c->stats.buffer, c->stats.offset);
     2645: 3508:        c->stats.buffer = NULL;
        -: 3509:    }
        -: 3510:}
        -: 3511:
        -: 3512:/* nsuffix == 0 means use no storage for client flags */
    31371: 3513:static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    31371: 3514:    char *p = suffix;
    31371: 3515:    if (!settings.inline_ascii_response) {
    31371: 3516:        *p = ' ';
    31371: 3517:        p++;
    31371: 3518:        if (it->nsuffix == 0) {
    31355: 3519:            *p = '0';
    31355: 3520:            p++;
        -: 3521:        } else {
       16: 3522:            p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
        -: 3523:        }
    31371: 3524:        *p = ' ';
    31371: 3525:        p = itoa_u32(nbytes-2, p+1);
        -: 3526:    } else {
        -: 3527:        p = suffix;
        -: 3528:    }
    31371: 3529:    if (return_cas) {
       29: 3530:        *p = ' ';
       29: 3531:        p = itoa_u64(ITEM_get_cas(it), p+1);
        -: 3532:    }
    31371: 3533:    *p = '\r';
    31371: 3534:    *(p+1) = '\n';
    31371: 3535:    *(p+2) = '\0';
    31371: 3536:    return (p - suffix) + 2;
        -: 3537:}
        -: 3538:
        -: 3539:#define IT_REFCOUNT_LIMIT 60000
   113023: 3540:static inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch) {
        -: 3541:    item *it;
   113023: 3542:    if (should_touch) {
        5: 3543:        it = item_touch(key, nkey, exptime, c);
        -: 3544:    } else {
   113018: 3545:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 3546:    }
   113023: 3547:    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
    #####: 3548:        item_remove(it);
    #####: 3549:        it = NULL;
        -: 3550:    }
   113023: 3551:    return it;
        -: 3552:}
        -: 3553:
    31438: 3554:static inline int _ascii_get_expand_ilist(conn *c, int i) {
    31438: 3555:    if (i >= c->isize) {
    #####: 3556:        item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
    #####: 3557:        if (new_list) {
    #####: 3558:            c->isize *= 2;
    #####: 3559:            c->ilist = new_list;
        -: 3560:        } else {
    #####: 3561:            STATS_LOCK();
    #####: 3562:            stats.malloc_fails++;
    #####: 3563:            STATS_UNLOCK();
        -: 3564:            return -1;
        -: 3565:        }
        -: 3566:    }
        -: 3567:    return 0;
        -: 3568:}
        -: 3569:
    31371: 3570:static inline char *_ascii_get_suffix_buf(conn *c, int i) {
        -: 3571:    char *suffix;
        -: 3572:    /* Goofy mid-flight realloc. */
    31371: 3573:    if (i >= c->suffixsize) {
    #####: 3574:    char **new_suffix_list = realloc(c->suffixlist,
        -: 3575:                           sizeof(char *) * c->suffixsize * 2);
    #####: 3576:    if (new_suffix_list) {
    #####: 3577:        c->suffixsize *= 2;
    #####: 3578:        c->suffixlist  = new_suffix_list;
        -: 3579:    } else {
    #####: 3580:        STATS_LOCK();
    #####: 3581:        stats.malloc_fails++;
    #####: 3582:        STATS_UNLOCK();
    #####: 3583:        return NULL;
        -: 3584:    }
        -: 3585:    }
        -: 3586:
    31371: 3587:    suffix = do_cache_alloc(c->thread->suffix_cache);
    31371: 3588:    if (suffix == NULL) {
    #####: 3589:      STATS_LOCK();
    #####: 3590:      stats.malloc_fails++;
    #####: 3591:      STATS_UNLOCK();
    #####: 3592:      out_of_memory(c, "SERVER_ERROR out of memory making CAS suffix");
    #####: 3593:      return NULL;
        -: 3594:    }
    31371: 3595:    *(c->suffixlist + i) = suffix;
    31371: 3596:    return suffix;
        -: 3597:}
        -: 3598:#ifdef EXTSTORE
        -: 3599:// FIXME: This runs in the IO thread. to get better IO performance this should
        -: 3600:// simply mark the io wrapper with the return value and decrement wrapleft, if
        -: 3601:// zero redispatching. Still a bit of work being done in the side thread but
        -: 3602:// minimized at least.
        -: 3603:static void _get_extstore_cb(void *e, obj_io *io, int ret) {
        -: 3604:    // FIXME: assumes success
        -: 3605:    io_wrap *wrap = (io_wrap *)io->data;
        -: 3606:    conn *c = wrap->c;
        -: 3607:    assert(wrap->active == true);
        -: 3608:    item *read_it = (item *)io->buf;
        -: 3609:    bool miss = false;
        -: 3610:
        -: 3611:    // TODO: How to do counters for hit/misses?
        -: 3612:    if (ret < 1) {
        -: 3613:        miss = true;
        -: 3614:    } else {
        -: 3615:        uint32_t crc2;
        -: 3616:        uint32_t crc = (uint32_t) read_it->exptime;
        -: 3617:        int x;
        -: 3618:        // item is chunked, crc the iov's
        -: 3619:        if (io->iov != NULL) {
        -: 3620:            // first iov is the header, which we don't use beyond crc
        -: 3621:            crc2 = crc32c(0, (char *)io->iov[0].iov_base+STORE_OFFSET, io->iov[0].iov_len-STORE_OFFSET);
        -: 3622:            // make sure it's not sent. hack :(
        -: 3623:            io->iov[0].iov_len = 0;
        -: 3624:            for (x = 1; x < io->iovcnt; x++) {
        -: 3625:                crc2 = crc32c(crc2, (char *)io->iov[x].iov_base, io->iov[x].iov_len);
        -: 3626:            }
        -: 3627:        } else {
        -: 3628:            crc2 = crc32c(0, (char *)read_it+STORE_OFFSET, io->len-STORE_OFFSET);
        -: 3629:        }
        -: 3630:
        -: 3631:        if (crc != crc2) {
        -: 3632:            miss = true;
        -: 3633:            wrap->badcrc = true;
        -: 3634:        }
        -: 3635:    }
        -: 3636:
        -: 3637:    if (miss) {
        -: 3638:        int i;
        -: 3639:        struct iovec *v;
        -: 3640:        // TODO: This should be movable to the worker thread.
        -: 3641:        if (c->protocol == binary_prot) {
        -: 3642:            protocol_binary_response_header *header =
        -: 3643:                (protocol_binary_response_header *)c->wbuf;
        -: 3644:            // this zeroes out the iovecs since binprot never stacks them.
        -: 3645:            if (header->response.keylen) {
        -: 3646:                write_bin_miss_response(c, ITEM_key(wrap->hdr_it), wrap->hdr_it->nkey);
        -: 3647:            } else {
        -: 3648:                write_bin_miss_response(c, 0, 0);
        -: 3649:            }
        -: 3650:        } else {
        -: 3651:            for (i = 0; i < wrap->iovec_count; i++) {
        -: 3652:                v = &c->iov[wrap->iovec_start + i];
        -: 3653:                v->iov_len = 0;
        -: 3654:                v->iov_base = NULL;
        -: 3655:            }
        -: 3656:        }
        -: 3657:        wrap->miss = true;
        -: 3658:    } else {
        -: 3659:        assert(read_it->slabs_clsid != 0);
        -: 3660:        // kill \r\n for binprot
        -: 3661:        if (io->iov == NULL) {
        -: 3662:            c->iov[wrap->iovec_data].iov_base = ITEM_data(read_it);
        -: 3663:            if (c->protocol == binary_prot)
        -: 3664:                c->iov[wrap->iovec_data].iov_len -= 2;
        -: 3665:        } else {
        -: 3666:            // FIXME: Might need to go back and ensure chunked binprots don't
        -: 3667:            // ever span two chunks for the final \r\n
        -: 3668:            if (c->protocol == binary_prot) {
        -: 3669:                if (io->iov[io->iovcnt-1].iov_len >= 2) {
        -: 3670:                    io->iov[io->iovcnt-1].iov_len -= 2;
        -: 3671:                } else {
        -: 3672:                    io->iov[io->iovcnt-1].iov_len = 0;
        -: 3673:                    io->iov[io->iovcnt-2].iov_len -= 1;
        -: 3674:                }
        -: 3675:            }
        -: 3676:        }
        -: 3677:        wrap->miss = false;
        -: 3678:        // iov_len is already set
        -: 3679:        // TODO: Should do that here instead and cuddle in the wrap object
        -: 3680:    }
        -: 3681:    c->io_wrapleft--;
        -: 3682:    wrap->active = false;
        -: 3683:    //assert(c->io_wrapleft >= 0);
        -: 3684:
        -: 3685:    // All IO's have returned, lets re-attach this connection to our original
        -: 3686:    // thread.
        -: 3687:    if (c->io_wrapleft == 0) {
        -: 3688:        assert(c->io_queued == true);
        -: 3689:        c->io_queued = false;
        -: 3690:        redispatch_conn(c);
        -: 3691:    }
        -: 3692:}
        -: 3693:
        -: 3694:// FIXME: This completely breaks UDP support.
        -: 3695:static inline int _get_extstore(conn *c, item *it, int iovst, int iovcnt) {
        -: 3696:#ifdef NEED_ALIGN
        -: 3697:    item_hdr hdr;
        -: 3698:    memcpy(&hdr, ITEM_data(it), sizeof(hdr));
        -: 3699:#else
        -: 3700:    item_hdr *hdr = (item_hdr *)ITEM_data(it);
        -: 3701:#endif
        -: 3702:    size_t ntotal = ITEM_ntotal(it);
        -: 3703:    unsigned int clsid = slabs_clsid(ntotal);
        -: 3704:    item *new_it;
        -: 3705:    bool chunked = false;
        -: 3706:    if (ntotal > settings.slab_chunk_size_max) {
        -: 3707:        // Pull a chunked item header.
        -: 3708:        uint32_t flags;
        -: 3709:        FLAGS_CONV(settings.inline_ascii_response, it, flags);
        -: 3710:        new_it = item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, it->nbytes);
        -: 3711:        assert(new_it == NULL || (new_it->it_flags & ITEM_CHUNKED));
        -: 3712:        chunked = true;
        -: 3713:    } else {
        -: 3714:        new_it = do_item_alloc_pull(ntotal, clsid);
        -: 3715:    }
        -: 3716:    if (new_it == NULL)
        -: 3717:        return -1;
        -: 3718:    assert(!c->io_queued); // FIXME: debugging.
        -: 3719:    // so we can free the chunk on a miss
        -: 3720:    new_it->slabs_clsid = clsid;
        -: 3721:
        -: 3722:    io_wrap *io = do_cache_alloc(c->thread->io_cache);
        -: 3723:    io->active = true;
        -: 3724:    io->miss = false;
        -: 3725:    io->badcrc = false;
        -: 3726:    // io_wrap owns the reference for this object now.
        -: 3727:    io->hdr_it = it;
        -: 3728:
        -: 3729:    // FIXME: error handling.
        -: 3730:    // The offsets we'll wipe on a miss.
        -: 3731:    io->iovec_start = iovst;
        -: 3732:    io->iovec_count = iovcnt;
        -: 3733:    // This is probably super dangerous. keep it at 0 and fill into wrap
        -: 3734:    // object?
        -: 3735:    if (chunked) {
        -: 3736:        unsigned int ciovcnt = 1;
        -: 3737:        size_t remain = new_it->nbytes;
        -: 3738:        item_chunk *chunk = (item_chunk *) ITEM_schunk(new_it);
        -: 3739:        io->io.iov = &c->iov[c->iovused];
        -: 3740:        // fill the header so we can get the full data + crc back.
        -: 3741:        add_iov(c, new_it, ITEM_ntotal(new_it) - new_it->nbytes);
        -: 3742:        while (remain > 0) {
        -: 3743:            chunk = do_item_alloc_chunk(chunk, remain);
        -: 3744:            if (chunk == NULL) {
        -: 3745:                item_remove(new_it);
        -: 3746:                do_cache_free(c->thread->io_cache, io);
        -: 3747:                return -1;
        -: 3748:            }
        -: 3749:            add_iov(c, chunk->data, (remain < chunk->size) ? remain : chunk->size);
        -: 3750:            chunk->used = (remain < chunk->size) ? remain : chunk->size;
        -: 3751:            remain -= chunk->size;
        -: 3752:            ciovcnt++;
        -: 3753:        }
        -: 3754:        io->io.iovcnt = ciovcnt;
        -: 3755:        // header object was already accounted for, remove one from total
        -: 3756:        io->iovec_count += ciovcnt-1;
        -: 3757:    } else {
        -: 3758:        io->io.iov = NULL;
        -: 3759:        io->iovec_data = c->iovused;
        -: 3760:        add_iov(c, "", it->nbytes);
        -: 3761:    }
        -: 3762:    io->io.buf = (void *)new_it;
        -: 3763:    // The offset we'll fill in on a hit.
        -: 3764:    io->c = c;
        -: 3765:    // We need to stack the sub-struct IO's together as well.
        -: 3766:    if (c->io_wraplist) {
        -: 3767:        io->io.next = &c->io_wraplist->io;
        -: 3768:    } else {
        -: 3769:        io->io.next = NULL;
        -: 3770:    }
        -: 3771:    // IO queue for this connection.
        -: 3772:    io->next = c->io_wraplist;
        -: 3773:    c->io_wraplist = io;
        -: 3774:    assert(c->io_wrapleft >= 0);
        -: 3775:    c->io_wrapleft++;
        -: 3776:    // reference ourselves for the callback.
        -: 3777:    io->io.data = (void *)io;
        -: 3778:
        -: 3779:    // Now, fill in io->io based on what was in our header.
        -: 3780:#ifdef NEED_ALIGN
        -: 3781:    io->io.page_version = hdr.page_version;
        -: 3782:    io->io.page_id = hdr.page_id;
        -: 3783:    io->io.offset = hdr.offset;
        -: 3784:#else
        -: 3785:    io->io.page_version = hdr->page_version;
        -: 3786:    io->io.page_id = hdr->page_id;
        -: 3787:    io->io.offset = hdr->offset;
        -: 3788:#endif
        -: 3789:    io->io.len = ntotal;
        -: 3790:    io->io.mode = OBJ_IO_READ;
        -: 3791:    io->io.cb = _get_extstore_cb;
        -: 3792:
        -: 3793:    //fprintf(stderr, "EXTSTORE: IO stacked %u\n", io->iovec_data);
        -: 3794:    // FIXME: This stat needs to move to reflect # of flash hits vs misses
        -: 3795:    // for now it's a good gauge on how often we request out to flash at
        -: 3796:    // least.
        -: 3797:    pthread_mutex_lock(&c->thread->stats.mutex);
        -: 3798:    c->thread->stats.get_extstore++;
        -: 3799:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3800:
        -: 3801:    return 0;
        -: 3802:}
        -: 3803:#endif
        -: 3804:/* ntokens is overwritten here... shrug.. */
   112294: 3805:static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
        -: 3806:    char *key;
        -: 3807:    size_t nkey;
   112294: 3808:    int i = 0;
   112294: 3809:    int si = 0;
        -: 3810:    item *it;
   112294: 3811:    token_t *key_token = &tokens[KEY_TOKEN];
        -: 3812:    char *suffix;
   112294: 3813:    int32_t exptime_int = 0;
   112294: 3814:    rel_time_t exptime = 0;
   112294: 3815:    bool fail_length = false;
   112294: 3816:    assert(c != NULL);
        -: 3817:
   112294: 3818:    if (should_touch) {
        -: 3819:        // For get and touch commands, use first token as exptime
        3: 3820:        if (!safe_strtol(tokens[1].value, &exptime_int)) {
    #####: 3821:            out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 3822:            return;
        -: 3823:        }
        3: 3824:        key_token++;
        6: 3825:        exptime = realtime(exptime_int);
        -: 3826:    }
        -: 3827:
        -: 3828:    do {
   225421: 3829:        while(key_token->length != 0) {
        -: 3830:
   113024: 3831:            key = key_token->value;
   113024: 3832:            nkey = key_token->length;
        -: 3833:
   113024: 3834:            if (nkey > KEY_MAX_LENGTH) {
        -: 3835:                fail_length = true;
        -: 3836:                goto stop;
        -: 3837:            }
        -: 3838:
   113023: 3839:            it = limited_get(key, nkey, c, exptime, should_touch);
   113023: 3840:            if (settings.detail_enabled) {
        3: 3841:                stats_prefix_record_get(key, nkey, NULL != it);
        -: 3842:            }
   113023: 3843:            if (it) {
    31438: 3844:                if (_ascii_get_expand_ilist(c, i) != 0) {
    #####: 3845:                    item_remove(it);
    #####: 3846:                    goto stop;
        -: 3847:                }
        -: 3848:
        -: 3849:                /*
        -: 3850:                 * Construct the response. Each hit adds three elements to the
        -: 3851:                 * outgoing data list:
        -: 3852:                 *   "VALUE "
        -: 3853:                 *   key
        -: 3854:                 *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
        -: 3855:                 */
        -: 3856:
    31438: 3857:                if (return_cas || !settings.inline_ascii_response)
        -: 3858:                {
        -: 3859:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
        -: 3860:                                        it->nbytes, ITEM_get_cas(it));
        -: 3861:                  int nbytes;
    31371: 3862:                  suffix = _ascii_get_suffix_buf(c, si);
    31371: 3863:                  if (suffix == NULL) {
    #####: 3864:                      item_remove(it);
    #####: 3865:                      goto stop;
        -: 3866:                  }
    31371: 3867:                  si++;
    31371: 3868:                  nbytes = it->nbytes;
    31371: 3869:                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes);
    62742: 3870:                  if (add_iov(c, "VALUE ", 6) != 0 ||
    62742: 3871:                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||
    62742: 3872:                      (settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||
    31371: 3873:                      add_iov(c, suffix, suffix_len) != 0)
        -: 3874:                      {
    #####: 3875:                          item_remove(it);
    #####: 3876:                          goto stop;
        -: 3877:                      }
        -: 3878:#ifdef EXTSTORE
        -: 3879:                  if (it->it_flags & ITEM_HDR) {
        -: 3880:                      if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
        -: 3881:                          pthread_mutex_lock(&c->thread->stats.mutex);
        -: 3882:                          c->thread->stats.get_oom_extstore++;
        -: 3883:                          pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3884:
        -: 3885:                          item_remove(it);
        -: 3886:                          goto stop;
        -: 3887:                      }
        -: 3888:                  } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 3889:#else
    31371: 3890:                  if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 3891:#endif
    12976: 3892:                      add_iov(c, ITEM_data(it), it->nbytes);
    18395: 3893:                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
    #####: 3894:                      item_remove(it);
    #####: 3895:                      goto stop;
        -: 3896:                  }
        -: 3897:                }
        -: 3898:                else
        -: 3899:                {
        -: 3900:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
        -: 3901:                                        it->nbytes, ITEM_get_cas(it));
      134: 3902:                  if (add_iov(c, "VALUE ", 6) != 0 ||
       67: 3903:                      add_iov(c, ITEM_key(it), it->nkey) != 0)
        -: 3904:                      {
    #####: 3905:                          item_remove(it);
    #####: 3906:                          goto stop;
        -: 3907:                      }
       67: 3908:                  if ((it->it_flags & ITEM_CHUNKED) == 0)
        -: 3909:                      {
       66: 3910:                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)
        -: 3911:                          {
    #####: 3912:                              item_remove(it);
    #####: 3913:                              goto stop;
        -: 3914:                          }
        2: 3915:                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||
        1: 3916:                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {
    #####: 3917:                          item_remove(it);
    #####: 3918:                          goto stop;
        -: 3919:                      }
        -: 3920:                }
        -: 3921:
        -: 3922:
    31438: 3923:                if (settings.verbose > 1) {
        -: 3924:                    int ii;
    #####: 3925:                    fprintf(stderr, ">%d sending key ", c->sfd);
    #####: 3926:                    for (ii = 0; ii < it->nkey; ++ii) {
    #####: 3927:                        fprintf(stderr, "%c", key[ii]);
        -: 3928:                    }
    #####: 3929:                    fprintf(stderr, "\n");
        -: 3930:                }
        -: 3931:
        -: 3932:                /* item_get() has incremented it->refcount for us */
    31438: 3933:                pthread_mutex_lock(&c->thread->stats.mutex);
    31438: 3934:                if (should_touch) {
        4: 3935:                    c->thread->stats.touch_cmds++;
        4: 3936:                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 3937:                } else {
    31434: 3938:                    c->thread->stats.lru_hits[it->slabs_clsid]++;
    31434: 3939:                    c->thread->stats.get_cmds++;
        -: 3940:                }
    31438: 3941:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3942:#ifdef EXTSTORE
        -: 3943:                /* If ITEM_HDR, an io_wrap owns the reference. */
        -: 3944:                if ((it->it_flags & ITEM_HDR) == 0) {
        -: 3945:                    *(c->ilist + i) = it;
        -: 3946:                    i++;
        -: 3947:                }
        -: 3948:#else
    31438: 3949:                *(c->ilist + i) = it;
    31438: 3950:                i++;
        -: 3951:#endif
        -: 3952:            } else {
    81585: 3953:                pthread_mutex_lock(&c->thread->stats.mutex);
    81585: 3954:                if (should_touch) {
        1: 3955:                    c->thread->stats.touch_cmds++;
        1: 3956:                    c->thread->stats.touch_misses++;
        -: 3957:                } else {
    81584: 3958:                    c->thread->stats.get_misses++;
    81584: 3959:                    c->thread->stats.get_cmds++;
        -: 3960:                }
        -: 3961:                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
    81585: 3962:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3963:            }
        -: 3964:
   113023: 3965:            key_token++;
        -: 3966:        }
        -: 3967:
        -: 3968:        /*
        -: 3969:         * If the command string hasn't been fully processed, get the next set
        -: 3970:         * of tokens.
        -: 3971:         */
   112397: 3972:        if(key_token->value != NULL) {
      104: 3973:            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
      104: 3974:            key_token = tokens;
        -: 3975:        }
        -: 3976:
   112397: 3977:    } while(key_token->value != NULL);
        -: 3978:stop:
        -: 3979:
   112294: 3980:    c->icurr = c->ilist;
   112294: 3981:    c->ileft = i;
   112294: 3982:    if (return_cas || !settings.inline_ascii_response) {
   112160: 3983:        c->suffixcurr = c->suffixlist;
   112160: 3984:        c->suffixleft = si;
        -: 3985:    }
        -: 3986:
   112294: 3987:    if (settings.verbose > 1)
    #####: 3988:        fprintf(stderr, ">%d END\n", c->sfd);
        -: 3989:
        -: 3990:    /*
        -: 3991:        If the loop was terminated because of out-of-memory, it is not
        -: 3992:        reliable to add END\r\n to the buffer, because it might not end
        -: 3993:        in \r\n. So we send SERVER_ERROR instead.
        -: 3994:    */
   112294: 3995:    if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
   112293: 3996:        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
        1: 3997:        if (fail_length) {
        1: 3998:            out_string(c, "CLIENT_ERROR bad command line format");
        -: 3999:        } else {
    #####: 4000:            out_of_memory(c, "SERVER_ERROR out of memory writing get response");
        -: 4001:        }
        1: 4002:        conn_release_items(c);
        -: 4003:    }
        -: 4004:    else {
   112293: 4005:        conn_set_state(c, conn_mwrite);
   112293: 4006:        c->msgcurr = 0;
        -: 4007:    }
        -: 4008:}
        -: 4009:
    82542: 4010:static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
        -: 4011:    char *key;
        -: 4012:    size_t nkey;
        -: 4013:    unsigned int flags;
    82542: 4014:    int32_t exptime_int = 0;
        -: 4015:    time_t exptime;
        -: 4016:    int vlen;
    82542: 4017:    uint64_t req_cas_id=0;
        -: 4018:    item *it;
        -: 4019:
    82542: 4020:    assert(c != NULL);
        -: 4021:
    82542: 4022:    set_noreply_maybe(c, tokens, ntokens);
        -: 4023:
    82542: 4024:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4025:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4026:        return;
        -: 4027:    }
        -: 4028:
    82542: 4029:    key = tokens[KEY_TOKEN].value;
    82542: 4030:    nkey = tokens[KEY_TOKEN].length;
        -: 4031:
   165082: 4032:    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
    82541: 4033:           && safe_strtol(tokens[3].value, &exptime_int)
    82540: 4034:           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
        3: 4035:        out_string(c, "CLIENT_ERROR bad command line format");
        3: 4036:        return;
        -: 4037:    }
        -: 4038:
        -: 4039:    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */
    82539: 4040:    exptime = exptime_int;
        -: 4041:
        -: 4042:    /* Negative exptimes can underflow and end up immortal. realtime() will
        -: 4043:       immediately expire values that are greater than REALTIME_MAXDELTA, but less
        -: 4044:       than process_started, so lets aim for that. */
    82539: 4045:    if (exptime < 0)
    #####: 4046:        exptime = REALTIME_MAXDELTA + 1;
        -: 4047:
        -: 4048:    // does cas value exist?
    82539: 4049:    if (handle_cas) {
       13: 4050:        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
        1: 4051:            out_string(c, "CLIENT_ERROR bad command line format");
        1: 4052:            return;
        -: 4053:        }
        -: 4054:    }
        -: 4055:
    82538: 4056:    if (vlen < 0 || vlen > (INT_MAX - 2)) {
        3: 4057:        out_string(c, "CLIENT_ERROR bad command line format");
        3: 4058:        return;
        -: 4059:    }
    82535: 4060:    vlen += 2;
        -: 4061:
    82535: 4062:    if (settings.detail_enabled) {
      101: 4063:        stats_prefix_record_set(key, nkey);
        -: 4064:    }
        -: 4065:
   165070: 4066:    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
        -: 4067:
    82535: 4068:    if (it == 0) {
        -: 4069:        enum store_item_type status;
        8: 4070:        if (! item_size_ok(nkey, flags, vlen)) {
        3: 4071:            out_string(c, "SERVER_ERROR object too large for cache");
        3: 4072:            status = TOO_LARGE;
        -: 4073:        } else {
        5: 4074:            out_of_memory(c, "SERVER_ERROR out of memory storing object");
        5: 4075:            status = NO_MEMORY;
        -: 4076:        }
        8: 4077:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 4078:                NULL, status, comm, key, nkey, 0, 0);
        -: 4079:        /* swallow the data line */
        8: 4080:        c->write_and_go = conn_swallow;
        8: 4081:        c->sbytes = vlen;
        -: 4082:
        -: 4083:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 4084:         * Unacceptable for SET. Anywhere else too? */
        8: 4085:        if (comm == NREAD_SET) {
        8: 4086:            it = item_get(key, nkey, c, DONT_UPDATE);
        8: 4087:            if (it) {
        2: 4088:                item_unlink(it);
        -: 4089:                STORAGE_delete(c->thread->storage, it);
        2: 4090:                item_remove(it);
        -: 4091:            }
        -: 4092:        }
        -: 4093:
        -: 4094:        return;
        -: 4095:    }
    82527: 4096:    ITEM_set_cas(it, req_cas_id);
        -: 4097:
    82527: 4098:    c->item = it;
        -: 4099:#ifdef NEED_ALIGN
        -: 4100:    if (it->it_flags & ITEM_CHUNKED) {
        -: 4101:        c->ritem = ITEM_schunk(it);
        -: 4102:    } else {
        -: 4103:        c->ritem = ITEM_data(it);
        -: 4104:    }
        -: 4105:#else
    82527: 4106:    c->ritem = ITEM_data(it);
        -: 4107:#endif
    82527: 4108:    c->rlbytes = it->nbytes;
    82527: 4109:    c->cmd = comm;
    82527: 4110:    conn_set_state(c, conn_nread);
        -: 4111:}
        -: 4112:
        1: 4113:static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 4114:    char *key;
        -: 4115:    size_t nkey;
        1: 4116:    int32_t exptime_int = 0;
        -: 4117:    item *it;
        -: 4118:
        1: 4119:    assert(c != NULL);
        -: 4120:
        1: 4121:    set_noreply_maybe(c, tokens, ntokens);
        -: 4122:
        1: 4123:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4124:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4125:        return;
        -: 4126:    }
        -: 4127:
        1: 4128:    key = tokens[KEY_TOKEN].value;
        1: 4129:    nkey = tokens[KEY_TOKEN].length;
        -: 4130:
        1: 4131:    if (!safe_strtol(tokens[2].value, &exptime_int)) {
    #####: 4132:        out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 4133:        return;
        -: 4134:    }
        -: 4135:
        2: 4136:    it = item_touch(key, nkey, realtime(exptime_int), c);
        1: 4137:    if (it) {
        1: 4138:        pthread_mutex_lock(&c->thread->stats.mutex);
        1: 4139:        c->thread->stats.touch_cmds++;
        1: 4140:        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        1: 4141:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4142:
        1: 4143:        out_string(c, "TOUCHED");
        1: 4144:        item_remove(it);
        -: 4145:    } else {
    #####: 4146:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4147:        c->thread->stats.touch_cmds++;
    #####: 4148:        c->thread->stats.touch_misses++;
    #####: 4149:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4150:
    #####: 4151:        out_string(c, "NOT_FOUND");
        -: 4152:    }
        -: 4153:}
        -: 4154:
      272: 4155:static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
        -: 4156:    char temp[INCR_MAX_STORAGE_LEN];
        -: 4157:    uint64_t delta;
        -: 4158:    char *key;
        -: 4159:    size_t nkey;
        -: 4160:
      272: 4161:    assert(c != NULL);
        -: 4162:
      272: 4163:    set_noreply_maybe(c, tokens, ntokens);
        -: 4164:
      272: 4165:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4166:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4167:        return;
        -: 4168:    }
        -: 4169:
      272: 4170:    key = tokens[KEY_TOKEN].value;
      272: 4171:    nkey = tokens[KEY_TOKEN].length;
        -: 4172:
      272: 4173:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 4174:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 4175:        return;
        -: 4176:    }
        -: 4177:
      272: 4178:    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
        -: 4179:    case OK:
      267: 4180:        out_string(c, temp);
      267: 4181:        break;
        -: 4182:    case NON_NUMERIC:
        1: 4183:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
        1: 4184:        break;
        -: 4185:    case EOM:
    #####: 4186:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 4187:        break;
        -: 4188:    case DELTA_ITEM_NOT_FOUND:
        4: 4189:        pthread_mutex_lock(&c->thread->stats.mutex);
        4: 4190:        if (incr) {
        1: 4191:            c->thread->stats.incr_misses++;
        -: 4192:        } else {
        3: 4193:            c->thread->stats.decr_misses++;
        -: 4194:        }
        4: 4195:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4196:
        4: 4197:        out_string(c, "NOT_FOUND");
        4: 4198:        break;
        -: 4199:    case DELTA_ITEM_CAS_MISMATCH:
        -: 4200:        break; /* Should never get here */
        -: 4201:    }
        -: 4202:}
        -: 4203:
        -: 4204:/*
        -: 4205: * adds a delta value to a numeric item.
        -: 4206: *
        -: 4207: * c     connection requesting the operation
        -: 4208: * it    item to adjust
        -: 4209: * incr  true to increment value, false to decrement
        -: 4210: * delta amount to adjust value by
        -: 4211: * buf   buffer for response string
        -: 4212: *
        -: 4213: * returns a response string to send back to the client.
        -: 4214: */
      403: 4215:enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
        -: 4216:                                    const bool incr, const int64_t delta,
        -: 4217:                                    char *buf, uint64_t *cas,
        -: 4218:                                    const uint32_t hv) {
        -: 4219:    char *ptr;
        -: 4220:    uint64_t value;
        -: 4221:    int res;
        -: 4222:    item *it;
        -: 4223:
      403: 4224:    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
      403: 4225:    if (!it) {
        -: 4226:        return DELTA_ITEM_NOT_FOUND;
        -: 4227:    }
        -: 4228:
        -: 4229:    /* Can't delta zero byte values. 2-byte are the "\r\n" */
        -: 4230:    /* Also can't delta for chunked items. Too large to be a number */
        -: 4231:#ifdef EXTSTORE
        -: 4232:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
        -: 4233:#else
      328: 4234:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
        -: 4235:#endif
        -: 4236:        return NON_NUMERIC;
        -: 4237:    }
        -: 4238:
      328: 4239:    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
    #####: 4240:        do_item_remove(it);
    #####: 4241:        return DELTA_ITEM_CAS_MISMATCH;
        -: 4242:    }
        -: 4243:
      328: 4244:    ptr = ITEM_data(it);
        -: 4245:
      328: 4246:    if (!safe_strtoull(ptr, &value)) {
        4: 4247:        do_item_remove(it);
        4: 4248:        return NON_NUMERIC;
        -: 4249:    }
        -: 4250:
      324: 4251:    if (incr) {
      292: 4252:        value += delta;
        -: 4253:        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4254:    } else {
       32: 4255:        if(delta > value) {
        4: 4256:            value = 0;
        -: 4257:        } else {
       28: 4258:            value -= delta;
        -: 4259:        }
        -: 4260:        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4261:    }
        -: 4262:
      324: 4263:    pthread_mutex_lock(&c->thread->stats.mutex);
      324: 4264:    if (incr) {
      292: 4265:        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
        -: 4266:    } else {
       32: 4267:        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
        -: 4268:    }
      324: 4269:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4270:
      648: 4271:    snprintf(buf, INCR_MAX_STORAGE_LEN, "%llu", (unsigned long long)value);
      324: 4272:    res = strlen(buf);
        -: 4273:    /* refcount == 2 means we are the only ones holding the item, and it is
        -: 4274:     * linked. We hold the item's lock in this function, so refcount cannot
        -: 4275:     * increase. */
      324: 4276:    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */
        -: 4277:        /* When changing the value without replacing the item, we
        -: 4278:           need to update the CAS on the existing item. */
        -: 4279:        /* We also need to fiddle it in the sizes tracker in case the tracking
        -: 4280:         * was enabled at runtime, since it relies on the CAS value to know
        -: 4281:         * whether to remove an item or not. */
       70: 4282:        item_stats_sizes_remove(it);
       70: 4283:        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
       70: 4284:        item_stats_sizes_add(it);
      140: 4285:        memcpy(ITEM_data(it), buf, res);
      140: 4286:        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
       70: 4287:        do_item_update(it);
      254: 4288:    } else if (it->refcount > 1) {
        -: 4289:        item *new_it;
        -: 4290:        uint32_t flags;
      254: 4291:        FLAGS_CONV(settings.inline_ascii_response, it, flags);
      254: 4292:        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
      254: 4293:        if (new_it == 0) {
    #####: 4294:            do_item_remove(it);
    #####: 4295:            return EOM;
        -: 4296:        }
      508: 4297:        memcpy(ITEM_data(new_it), buf, res);
      508: 4298:        memcpy(ITEM_data(new_it) + res, "\r\n", 2);
      254: 4299:        item_replace(it, new_it, hv);
        -: 4300:        // Overwrite the older item's CAS with our new CAS since we're
        -: 4301:        // returning the CAS of the old item below.
      254: 4302:        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
      254: 4303:        do_item_remove(new_it);       /* release our reference */
        -: 4304:    } else {
        -: 4305:        /* Should never get here. This means we somehow fetched an unlinked
        -: 4306:         * item. TODO: Add a counter? */
    #####: 4307:        if (settings.verbose) {
    #####: 4308:            fprintf(stderr, "Tried to do incr/decr on invalid item\n");
        -: 4309:        }
    #####: 4310:        if (it->refcount == 1)
    #####: 4311:            do_item_remove(it);
        -: 4312:        return DELTA_ITEM_NOT_FOUND;
        -: 4313:    }
        -: 4314:
      324: 4315:    if (cas) {
       57: 4316:        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
        -: 4317:    }
      324: 4318:    do_item_remove(it);         /* release our reference */
      324: 4319:    return OK;
        -: 4320:}
        -: 4321:
     2672: 4322:static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 4323:    char *key;
        -: 4324:    size_t nkey;
        -: 4325:    item *it;
        -: 4326:
     2672: 4327:    assert(c != NULL);
        -: 4328:
     2672: 4329:    if (ntokens > 3) {
     2507: 4330:        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
     2507: 4331:        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
     5012: 4332:        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
     2510: 4333:            || (ntokens == 5 && hold_is_zero && sets_noreply);
     2507: 4334:        if (!valid) {
        2: 4335:            out_string(c, "CLIENT_ERROR bad command line format.  "
        -: 4336:                       "Usage: delete <key> [noreply]");
        2: 4337:            return;
        -: 4338:        }
        -: 4339:    }
        -: 4340:
        -: 4341:
     2670: 4342:    key = tokens[KEY_TOKEN].value;
     2670: 4343:    nkey = tokens[KEY_TOKEN].length;
        -: 4344:
     2670: 4345:    if(nkey > KEY_MAX_LENGTH) {
    #####: 4346:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4347:        return;
        -: 4348:    }
        -: 4349:
     2670: 4350:    if (settings.detail_enabled) {
        1: 4351:        stats_prefix_record_delete(key, nkey);
        -: 4352:    }
        -: 4353:
     2670: 4354:    it = item_get(key, nkey, c, DONT_UPDATE);
     2670: 4355:    if (it) {
        -: 4356:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 4357:
     2662: 4358:        pthread_mutex_lock(&c->thread->stats.mutex);
     2662: 4359:        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
     2662: 4360:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4361:
     2662: 4362:        item_unlink(it);
        -: 4363:        STORAGE_delete(c->thread->storage, it);
     2662: 4364:        item_remove(it);      /* release our reference */
     2662: 4365:        out_string(c, "DELETED");
        -: 4366:    } else {
        8: 4367:        pthread_mutex_lock(&c->thread->stats.mutex);
        8: 4368:        c->thread->stats.delete_misses++;
        8: 4369:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4370:
        8: 4371:        out_string(c, "NOT_FOUND");
        -: 4372:    }
        -: 4373:}
        -: 4374:
        1: 4375:static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 4376:    unsigned int level;
        -: 4377:
        1: 4378:    assert(c != NULL);
        -: 4379:
        1: 4380:    set_noreply_maybe(c, tokens, ntokens);
        -: 4381:
        1: 4382:    level = strtoul(tokens[1].value, NULL, 10);
        1: 4383:    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
        1: 4384:    out_string(c, "OK");
        1: 4385:    return;
        -: 4386:}
        -: 4387:
        -: 4388:#ifdef MEMCACHED_DEBUG
    #####: 4389:static void process_misbehave_command(conn *c) {
    #####: 4390:    int allowed = 0;
        -: 4391:
        -: 4392:    // try opening new TCP socket
    #####: 4393:    int i = socket(AF_INET, SOCK_STREAM, 0);
    #####: 4394:    if (i != -1) {
    #####: 4395:        allowed++;
    #####: 4396:        close(i);
        -: 4397:    }
        -: 4398:
        -: 4399:    // try executing new commands
    #####: 4400:    i = system("sleep 0");
    #####: 4401:    if (i != -1) {
    #####: 4402:        allowed++;
        -: 4403:    }
        -: 4404:
    #####: 4405:    if (allowed) {
    #####: 4406:        out_string(c, "ERROR");
        -: 4407:    } else {
    #####: 4408:        out_string(c, "OK");
        -: 4409:    }
    #####: 4410:}
        -: 4411:#endif
        -: 4412:
    #####: 4413:static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 4414:    unsigned int level;
        -: 4415:    double ratio;
        -: 4416:
    #####: 4417:    assert(c != NULL);
        -: 4418:
    #####: 4419:    set_noreply_maybe(c, tokens, ntokens);
        -: 4420:
    #####: 4421:    if (strcmp(tokens[2].value, "ratio") == 0) {
    #####: 4422:        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
    #####: 4423:            out_string(c, "ERROR");
    #####: 4424:            return;
        -: 4425:        }
    #####: 4426:        settings.slab_automove_ratio = ratio;
        -: 4427:    } else {
    #####: 4428:        level = strtoul(tokens[2].value, NULL, 10);
    #####: 4429:        if (level == 0) {
    #####: 4430:            settings.slab_automove = 0;
    #####: 4431:        } else if (level == 1 || level == 2) {
    #####: 4432:            settings.slab_automove = level;
        -: 4433:        } else {
    #####: 4434:            out_string(c, "ERROR");
    #####: 4435:            return;
        -: 4436:        }
        -: 4437:    }
    #####: 4438:    out_string(c, "OK");
    #####: 4439:    return;
        -: 4440:}
        -: 4441:
        -: 4442:/* TODO: decide on syntax for sampling? */
        3: 4443:static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
        3: 4444:    uint16_t f = 0;
        -: 4445:    int x;
        3: 4446:    assert(c != NULL);
        -: 4447:
        3: 4448:    set_noreply_maybe(c, tokens, ntokens);
        3: 4449:    if (ntokens > 2) {
        3: 4450:        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
        3: 4451:            if ((strcmp(tokens[x].value, "rawcmds") == 0)) {
    #####: 4452:                f |= LOG_RAWCMDS;
        3: 4453:            } else if ((strcmp(tokens[x].value, "evictions") == 0)) {
        2: 4454:                f |= LOG_EVICTIONS;
        1: 4455:            } else if ((strcmp(tokens[x].value, "fetchers") == 0)) {
    #####: 4456:                f |= LOG_FETCHERS;
        1: 4457:            } else if ((strcmp(tokens[x].value, "mutations") == 0)) {
        1: 4458:                f |= LOG_MUTATIONS;
    #####: 4459:            } else if ((strcmp(tokens[x].value, "sysevents") == 0)) {
    #####: 4460:                f |= LOG_SYSEVENTS;
        -: 4461:            } else {
    #####: 4462:                out_string(c, "ERROR");
    #####: 4463:                return;
        -: 4464:            }
        -: 4465:        }
        -: 4466:    } else {
        -: 4467:        f |= LOG_FETCHERS;
        -: 4468:    }
        -: 4469:
        3: 4470:    switch(logger_add_watcher(c, c->sfd, f)) {
        -: 4471:        case LOGGER_ADD_WATCHER_TOO_MANY:
    #####: 4472:            out_string(c, "WATCHER_TOO_MANY log watcher limit reached");
    #####: 4473:            break;
        -: 4474:        case LOGGER_ADD_WATCHER_FAILED:
    #####: 4475:            out_string(c, "WATCHER_FAILED failed to add log watcher");
    #####: 4476:            break;
        -: 4477:        case LOGGER_ADD_WATCHER_OK:
        3: 4478:            conn_set_state(c, conn_watch);
        3: 4479:            event_del(&c->event);
        3: 4480:            break;
        -: 4481:    }
        -: 4482:}
        -: 4483:
        3: 4484:static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 4485:    uint32_t memlimit;
        3: 4486:    assert(c != NULL);
        -: 4487:
        3: 4488:    set_noreply_maybe(c, tokens, ntokens);
        -: 4489:
        3: 4490:    if (!safe_strtoul(tokens[1].value, &memlimit)) {
    #####: 4491:        out_string(c, "ERROR");
        -: 4492:    } else {
        3: 4493:        if (memlimit < 8) {
    #####: 4494:            out_string(c, "MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m");
        -: 4495:        } else {
        3: 4496:            if (memlimit > 1000000000) {
    #####: 4497:                out_string(c, "MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes");
        3: 4498:            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
        3: 4499:                if (settings.verbose > 0) {
    #####: 4500:                    fprintf(stderr, "maxbytes adjusted to %llum\n", (unsigned long long)memlimit);
        -: 4501:                }
        -: 4502:
        3: 4503:                out_string(c, "OK");
        -: 4504:            } else {
    #####: 4505:                out_string(c, "MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust");
        -: 4506:            }
        -: 4507:        }
        -: 4508:    }
        3: 4509:}
        -: 4510:
    #####: 4511:static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 4512:    uint32_t pct_hot;
        -: 4513:    uint32_t pct_warm;
        -: 4514:    double hot_factor;
        -: 4515:    int32_t ttl;
        -: 4516:    double factor;
        -: 4517:
    #####: 4518:    set_noreply_maybe(c, tokens, ntokens);
        -: 4519:
    #####: 4520:    if (strcmp(tokens[1].value, "tune") == 0 && ntokens >= 7) {
    #####: 4521:        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
    #####: 4522:            !safe_strtoul(tokens[3].value, &pct_warm) ||
    #####: 4523:            !safe_strtod(tokens[4].value, &hot_factor) ||
    #####: 4524:            !safe_strtod(tokens[5].value, &factor)) {
    #####: 4525:            out_string(c, "ERROR");
        -: 4526:        } else {
    #####: 4527:            if (pct_hot + pct_warm > 80) {
    #####: 4528:                out_string(c, "ERROR hot and warm pcts must not exceed 80");
    #####: 4529:            } else if (factor <= 0 || hot_factor <= 0) {
    #####: 4530:                out_string(c, "ERROR hot/warm age factors must be greater than 0");
        -: 4531:            } else {
    #####: 4532:                settings.hot_lru_pct = pct_hot;
    #####: 4533:                settings.warm_lru_pct = pct_warm;
    #####: 4534:                settings.hot_max_factor = hot_factor;
    #####: 4535:                settings.warm_max_factor = factor;
    #####: 4536:                out_string(c, "OK");
        -: 4537:            }
        -: 4538:        }
    #####: 4539:    } else if (strcmp(tokens[1].value, "mode") == 0 && ntokens >= 3 &&
    #####: 4540:               settings.lru_maintainer_thread) {
    #####: 4541:        if (strcmp(tokens[2].value, "flat") == 0) {
    #####: 4542:            settings.lru_segmented = false;
    #####: 4543:            out_string(c, "OK");
    #####: 4544:        } else if (strcmp(tokens[2].value, "segmented") == 0) {
    #####: 4545:            settings.lru_segmented = true;
    #####: 4546:            out_string(c, "OK");
        -: 4547:        } else {
    #####: 4548:            out_string(c, "ERROR");
        -: 4549:        }
    #####: 4550:    } else if (strcmp(tokens[1].value, "temp_ttl") == 0 && ntokens >= 3 &&
    #####: 4551:               settings.lru_maintainer_thread) {
    #####: 4552:        if (!safe_strtol(tokens[2].value, &ttl)) {
    #####: 4553:            out_string(c, "ERROR");
        -: 4554:        } else {
    #####: 4555:            if (ttl < 0) {
    #####: 4556:                settings.temp_lru = false;
        -: 4557:            } else {
    #####: 4558:                settings.temp_lru = true;
    #####: 4559:                settings.temporary_ttl = ttl;
        -: 4560:            }
    #####: 4561:            out_string(c, "OK");
        -: 4562:        }
        -: 4563:    } else {
    #####: 4564:        out_string(c, "ERROR");
        -: 4565:    }
    #####: 4566:}
        -: 4567:#ifdef EXTSTORE
        -: 4568:static void process_extstore_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 4569:    set_noreply_maybe(c, tokens, ntokens);
        -: 4570:    bool ok = true;
        -: 4571:    if (ntokens < 4) {
        -: 4572:        ok = false;
        -: 4573:    } else if (strcmp(tokens[1].value, "free_memchunks") == 0 && ntokens > 4) {
        -: 4574:        /* per-slab-class free chunk setting. */
        -: 4575:        unsigned int clsid = 0;
        -: 4576:        unsigned int limit = 0;
        -: 4577:        if (!safe_strtoul(tokens[2].value, &clsid) ||
        -: 4578:                !safe_strtoul(tokens[3].value, &limit)) {
        -: 4579:            ok = false;
        -: 4580:        } else {
        -: 4581:            if (clsid < MAX_NUMBER_OF_SLAB_CLASSES) {
        -: 4582:                settings.ext_free_memchunks[clsid] = limit;
        -: 4583:            } else {
        -: 4584:                ok = false;
        -: 4585:            }
        -: 4586:        }
        -: 4587:    } else if (strcmp(tokens[1].value, "item_size") == 0) {
        -: 4588:        if (!safe_strtoul(tokens[2].value, &settings.ext_item_size))
        -: 4589:            ok = false;
        -: 4590:    } else if (strcmp(tokens[1].value, "item_age") == 0) {
        -: 4591:        if (!safe_strtoul(tokens[2].value, &settings.ext_item_age))
        -: 4592:            ok = false;
        -: 4593:    } else if (strcmp(tokens[1].value, "low_ttl") == 0) {
        -: 4594:        if (!safe_strtoul(tokens[2].value, &settings.ext_low_ttl))
        -: 4595:            ok = false;
        -: 4596:    } else if (strcmp(tokens[1].value, "recache_rate") == 0) {
        -: 4597:        if (!safe_strtoul(tokens[2].value, &settings.ext_recache_rate))
        -: 4598:            ok = false;
        -: 4599:    } else if (strcmp(tokens[1].value, "compact_under") == 0) {
        -: 4600:        if (!safe_strtoul(tokens[2].value, &settings.ext_compact_under))
        -: 4601:            ok = false;
        -: 4602:    } else if (strcmp(tokens[1].value, "drop_under") == 0) {
        -: 4603:        if (!safe_strtoul(tokens[2].value, &settings.ext_drop_under))
        -: 4604:            ok = false;
        -: 4605:    } else if (strcmp(tokens[1].value, "max_frag") == 0) {
        -: 4606:        if (!safe_strtod(tokens[2].value, &settings.ext_max_frag))
        -: 4607:            ok = false;
        -: 4608:    } else if (strcmp(tokens[1].value, "drop_unread") == 0) {
        -: 4609:        unsigned int v;
        -: 4610:        if (!safe_strtoul(tokens[2].value, &v)) {
        -: 4611:            ok = false;
        -: 4612:        } else {
        -: 4613:            settings.ext_drop_unread = v == 0 ? false : true;
        -: 4614:        }
        -: 4615:    } else {
        -: 4616:        ok = false;
        -: 4617:    }
        -: 4618:    if (!ok) {
        -: 4619:        out_string(c, "ERROR");
        -: 4620:    } else {
        -: 4621:        out_string(c, "OK");
        -: 4622:    }
        -: 4623:}
        -: 4624:#endif
   200519: 4625:static void process_command(conn *c, char *command) {
        -: 4626:
        -: 4627:    token_t tokens[MAX_TOKENS];
        -: 4628:    size_t ntokens;
        -: 4629:    int comm;
        -: 4630:
   200519: 4631:    assert(c != NULL);
        -: 4632:
        -: 4633:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
        -: 4634:
   200519: 4635:    if (settings.verbose > 1)
    #####: 4636:        fprintf(stderr, "<%d %s\n", c->sfd, command);
        -: 4637:
        -: 4638:    /*
        -: 4639:     * for commands set/add/replace, we build an item and read the data
        -: 4640:     * directly into it, then continue in nread_complete().
        -: 4641:     */
        -: 4642:
   200519: 4643:    c->msgcurr = 0;
   200519: 4644:    c->msgused = 0;
   200519: 4645:    c->iovused = 0;
   200519: 4646:    if (add_msghdr(c) != 0) {
    #####: 4647:        out_of_memory(c, "SERVER_ERROR out of memory preparing response");
    #####: 4648:        return;
        -: 4649:    }
        -: 4650:
   200519: 4651:    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
   398397: 4652:    if (ntokens >= 3 &&
   283493: 4653:        ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
    85615: 4654:         (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) {
        -: 4655:
   112263: 4656:        process_get_command(c, tokens, ntokens, false, false);
        -: 4657:
   170800: 4658:    } else if ((ntokens == 6 || ntokens == 7) &&
   165075: 4659:               ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
    98556: 4660:                (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
    32047: 4661:                (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
    24042: 4662:                (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
     8020: 4663:                (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
        -: 4664:
    82526: 4665:        process_update_command(c, tokens, ntokens, comm, false);
        -: 4666:
     5730: 4667:    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
        -: 4668:
       16: 4669:        process_update_command(c, tokens, ntokens, comm, true);
        -: 4670:
     5714: 4671:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
        -: 4672:
      262: 4673:        process_arithmetic_command(c, tokens, ntokens, 1);
        -: 4674:
     5452: 4675:    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
        -: 4676:
       28: 4677:        process_get_command(c, tokens, ntokens, true, false);
        -: 4678:
     5424: 4679:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
        -: 4680:
       10: 4681:        process_arithmetic_command(c, tokens, ntokens, 0);
        -: 4682:
     5414: 4683:    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
        -: 4684:
     2672: 4685:        process_delete_command(c, tokens, ntokens);
        -: 4686:
     2742: 4687:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
        -: 4688:
        1: 4689:        process_touch_command(c, tokens, ntokens);
        -: 4690:
     2741: 4691:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0)) {
        -: 4692:
        2: 4693:        process_get_command(c, tokens, ntokens, false, true);
        -: 4694:
     2739: 4695:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gats") == 0)) {
        -: 4696:
        1: 4697:        process_get_command(c, tokens, ntokens, true, true);
        -: 4698:
     2738: 4699:    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
        -: 4700:
     2695: 4701:        process_stat(c, tokens, ntokens);
        -: 4702:
       43: 4703:    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
       12: 4704:        time_t exptime = 0;
       12: 4705:        rel_time_t new_oldest = 0;
        -: 4706:
       12: 4707:        set_noreply_maybe(c, tokens, ntokens);
        -: 4708:
       12: 4709:        pthread_mutex_lock(&c->thread->stats.mutex);
       12: 4710:        c->thread->stats.flush_cmds++;
       12: 4711:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4712:
       12: 4713:        if (!settings.flush_enabled) {
        -: 4714:            // flush_all is not allowed but we log it on stats
        1: 4715:            out_string(c, "CLIENT_ERROR flush_all not allowed");
        1: 4716:            return;
        -: 4717:        }
        -: 4718:
       11: 4719:        if (ntokens != (c->noreply ? 3 : 2)) {
        6: 4720:            exptime = strtol(tokens[1].value, NULL, 10);
        6: 4721:            if(errno == ERANGE) {
    #####: 4722:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4723:                return;
        -: 4724:            }
        -: 4725:        }
        -: 4726:
        -: 4727:        /*
        -: 4728:          If exptime is zero realtime() would return zero too, and
        -: 4729:          realtime(exptime) - 1 would overflow to the max unsigned
        -: 4730:          value.  So we process exptime == 0 the same way we do when
        -: 4731:          no delay is given at all.
        -: 4732:        */
       11: 4733:        if (exptime > 0) {
        2: 4734:            new_oldest = realtime(exptime);
        -: 4735:        } else { /* exptime == 0 */
        9: 4736:            new_oldest = current_time;
        -: 4737:        }
        -: 4738:
       11: 4739:        if (settings.use_cas) {
        9: 4740:            settings.oldest_live = new_oldest - 1;
        9: 4741:            if (settings.oldest_live <= current_time)
        7: 4742:                settings.oldest_cas = get_cas_id();
        -: 4743:        } else {
        2: 4744:            settings.oldest_live = new_oldest;
        -: 4745:        }
       11: 4746:        out_string(c, "OK");
       11: 4747:        return;
        -: 4748:
       31: 4749:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
        -: 4750:
        1: 4751:        out_string(c, "VERSION " VERSION);
        -: 4752:
       30: 4753:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
        -: 4754:
        1: 4755:        conn_set_state(c, conn_closing);
        -: 4756:
       29: 4757:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
        -: 4758:
        1: 4759:        if (settings.shutdown_command) {
        1: 4760:            conn_set_state(c, conn_closing);
        1: 4761:            raise(SIGINT);
        -: 4762:        } else {
    #####: 4763:            out_string(c, "ERROR: shutdown not enabled");
        -: 4764:        }
        -: 4765:
       28: 4766:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
        6: 4767:        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
        -: 4768:            int src, dst, rv;
        -: 4769:
        6: 4770:            if (settings.slab_reassign == false) {
    #####: 4771:                out_string(c, "CLIENT_ERROR slab reassignment disabled");
    #####: 4772:                return;
        -: 4773:            }
        -: 4774:
        6: 4775:            src = strtol(tokens[2].value, NULL, 10);
        6: 4776:            dst = strtol(tokens[3].value, NULL, 10);
        -: 4777:
        6: 4778:            if (errno == ERANGE) {
    #####: 4779:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4780:                return;
        -: 4781:            }
        -: 4782:
        6: 4783:            rv = slabs_reassign(src, dst);
        6: 4784:            switch (rv) {
        -: 4785:            case REASSIGN_OK:
        6: 4786:                out_string(c, "OK");
        6: 4787:                break;
        -: 4788:            case REASSIGN_RUNNING:
    #####: 4789:                out_string(c, "BUSY currently processing reassign request");
    #####: 4790:                break;
        -: 4791:            case REASSIGN_BADCLASS:
    #####: 4792:                out_string(c, "BADCLASS invalid src or dst class id");
    #####: 4793:                break;
        -: 4794:            case REASSIGN_NOSPARE:
    #####: 4795:                out_string(c, "NOSPARE source class has no spare pages");
    #####: 4796:                break;
        -: 4797:            case REASSIGN_SRC_DST_SAME:
    #####: 4798:                out_string(c, "SAME src and dst class are identical");
    #####: 4799:                break;
        -: 4800:            }
        -: 4801:            return;
    #####: 4802:        } else if (ntokens >= 4 &&
    #####: 4803:            (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
    #####: 4804:            process_slabs_automove_command(c, tokens, ntokens);
        -: 4805:        } else {
    #####: 4806:            out_string(c, "ERROR");
        -: 4807:        }
       22: 4808:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
        5: 4809:        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
        -: 4810:            int rv;
        2: 4811:            if (settings.lru_crawler == false) {
    #####: 4812:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4813:                return;
        -: 4814:            }
        -: 4815:
        2: 4816:            rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
        -: 4817:                    settings.lru_crawler_tocrawl);
        2: 4818:            switch(rv) {
        -: 4819:            case CRAWLER_OK:
        2: 4820:                out_string(c, "OK");
        2: 4821:                break;
        -: 4822:            case CRAWLER_RUNNING:
    #####: 4823:                out_string(c, "BUSY currently processing crawler request");
    #####: 4824:                break;
        -: 4825:            case CRAWLER_BADCLASS:
    #####: 4826:                out_string(c, "BADCLASS invalid class id");
    #####: 4827:                break;
        -: 4828:            case CRAWLER_NOTSTARTED:
    #####: 4829:                out_string(c, "NOTSTARTED no items to crawl");
    #####: 4830:                break;
        -: 4831:            case CRAWLER_ERROR:
    #####: 4832:                out_string(c, "ERROR an unknown error happened");
    #####: 4833:                break;
        -: 4834:            }
        -: 4835:            return;
        3: 4836:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
        1: 4837:            if (settings.lru_crawler == false) {
    #####: 4838:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4839:                return;
        -: 4840:            }
        1: 4841:            if (!settings.dump_enabled) {
    #####: 4842:                out_string(c, "ERROR metadump not allowed");
    #####: 4843:                return;
        -: 4844:            }
        -: 4845:
        1: 4846:            int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,
        -: 4847:                    c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
        1: 4848:            switch(rv) {
        -: 4849:                case CRAWLER_OK:
        1: 4850:                    out_string(c, "OK");
        -: 4851:                    // TODO: Don't reuse conn_watch here.
        1: 4852:                    conn_set_state(c, conn_watch);
        1: 4853:                    event_del(&c->event);
        1: 4854:                    break;
        -: 4855:                case CRAWLER_RUNNING:
    #####: 4856:                    out_string(c, "BUSY currently processing crawler request");
    #####: 4857:                    break;
        -: 4858:                case CRAWLER_BADCLASS:
    #####: 4859:                    out_string(c, "BADCLASS invalid class id");
    #####: 4860:                    break;
        -: 4861:                case CRAWLER_NOTSTARTED:
    #####: 4862:                    out_string(c, "NOTSTARTED no items to crawl");
    #####: 4863:                    break;
        -: 4864:                case CRAWLER_ERROR:
    #####: 4865:                    out_string(c, "ERROR an unknown error happened");
    #####: 4866:                    break;
        -: 4867:            }
        -: 4868:            return;
        2: 4869:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
        -: 4870:            uint32_t tocrawl;
    #####: 4871:             if (!safe_strtoul(tokens[2].value, &tocrawl)) {
    #####: 4872:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4873:                return;
        -: 4874:            }
    #####: 4875:            settings.lru_crawler_tocrawl = tocrawl;
    #####: 4876:            out_string(c, "OK");
    #####: 4877:            return;
        2: 4878:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
        -: 4879:            uint32_t tosleep;
    #####: 4880:            if (!safe_strtoul(tokens[2].value, &tosleep)) {
    #####: 4881:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4882:                return;
        -: 4883:            }
    #####: 4884:            if (tosleep > 1000000) {
    #####: 4885:                out_string(c, "CLIENT_ERROR sleep must be one second or less");
    #####: 4886:                return;
        -: 4887:            }
    #####: 4888:            settings.lru_crawler_sleep = tosleep;
    #####: 4889:            out_string(c, "OK");
    #####: 4890:            return;
        2: 4891:        } else if (ntokens == 3) {
        2: 4892:            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
        1: 4893:                if (start_item_crawler_thread() == 0) {
        1: 4894:                    out_string(c, "OK");
        -: 4895:                } else {
    #####: 4896:                    out_string(c, "ERROR failed to start lru crawler thread");
        -: 4897:                }
        1: 4898:            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
        1: 4899:                if (stop_item_crawler_thread() == 0) {
        1: 4900:                    out_string(c, "OK");
        -: 4901:                } else {
    #####: 4902:                    out_string(c, "ERROR failed to stop lru crawler thread");
        -: 4903:                }
        -: 4904:            } else {
    #####: 4905:                out_string(c, "ERROR");
        -: 4906:            }
        -: 4907:            return;
        -: 4908:        } else {
    #####: 4909:            out_string(c, "ERROR");
        -: 4910:        }
       17: 4911:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
        3: 4912:        process_watch_command(c, tokens, ntokens);
       14: 4913:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
        3: 4914:        process_memlimit_command(c, tokens, ntokens);
       11: 4915:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
        1: 4916:        process_verbosity_command(c, tokens, ntokens);
       10: 4917:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
    #####: 4918:        process_lru_command(c, tokens, ntokens);
        -: 4919:#ifdef MEMCACHED_DEBUG
        -: 4920:    // commands which exist only for testing the memcached's security protection
       10: 4921:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0)) {
    #####: 4922:        process_misbehave_command(c);
        -: 4923:#endif
        -: 4924:#ifdef EXTSTORE
        -: 4925:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
        -: 4926:        process_extstore_command(c, tokens, ntokens);
        -: 4927:#endif
        -: 4928:    } else {
       10: 4929:        if (ntokens >= 2 && strncmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
        3: 4930:            conn_set_state(c, conn_closing);
        -: 4931:        } else {
        7: 4932:            out_string(c, "ERROR");
        -: 4933:        }
        -: 4934:    }
        -: 4935:    return;
        -: 4936:}
        -: 4937:
        -: 4938:/*
        -: 4939: * if we have a complete line in the buffer, process it.
        -: 4940: */
   227252: 4941:static int try_read_command(conn *c) {
   227252: 4942:    assert(c != NULL);
   227252: 4943:    assert(c->rcurr <= (c->rbuf + c->rsize));
   227252: 4944:    assert(c->rbytes > 0);
        -: 4945:
   227252: 4946:    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {
      107: 4947:        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
       15: 4948:            c->protocol = binary_prot;
        -: 4949:        } else {
       92: 4950:            c->protocol = ascii_prot;
        -: 4951:        }
        -: 4952:
      107: 4953:        if (settings.verbose > 1) {
    #####: 4954:            fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
        -: 4955:                    prot_text(c->protocol));
        -: 4956:        }
        -: 4957:    }
        -: 4958:
   227252: 4959:    if (c->protocol == binary_prot) {
        -: 4960:        /* Do we have the complete packet header? */
    26629: 4961:        if (c->rbytes < sizeof(c->binary_header)) {
        -: 4962:            /* need more data! */
        -: 4963:            return 0;
        -: 4964:        } else {
        -: 4965:#ifdef NEED_ALIGN
        -: 4966:            if (((long)(c->rcurr)) % 8 != 0) {
        -: 4967:                /* must realign input buffer */
        -: 4968:                memmove(c->rbuf, c->rcurr, c->rbytes);
        -: 4969:                c->rcurr = c->rbuf;
        -: 4970:                if (settings.verbose > 1) {
        -: 4971:                    fprintf(stderr, "%d: Realign input buffer\n", c->sfd);
        -: 4972:                }
        -: 4973:            }
        -: 4974:#endif
        -: 4975:            protocol_binary_request_header* req;
    24953: 4976:            req = (protocol_binary_request_header*)c->rcurr;
        -: 4977:
    24953: 4978:            if (settings.verbose > 1) {
        -: 4979:                /* Dump the packet before we convert it to host order */
        -: 4980:                int ii;
    #####: 4981:                fprintf(stderr, "<%d Read binary protocol data:", c->sfd);
    #####: 4982:                for (ii = 0; ii < sizeof(req->bytes); ++ii) {
    #####: 4983:                    if (ii % 4 == 0) {
    #####: 4984:                        fprintf(stderr, "\n<%d   ", c->sfd);
        -: 4985:                    }
    #####: 4986:                    fprintf(stderr, " 0x%02x", req->bytes[ii]);
        -: 4987:                }
    #####: 4988:                fprintf(stderr, "\n");
        -: 4989:            }
        -: 4990:
    24953: 4991:            c->binary_header = *req;
    24953: 4992:            c->binary_header.request.keylen = ntohs(req->request.keylen);
    49906: 4993:            c->binary_header.request.bodylen = ntohl(req->request.bodylen);
    24953: 4994:            c->binary_header.request.cas = ntohll(req->request.cas);
        -: 4995:
    24953: 4996:            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
        2: 4997:                if (settings.verbose) {
    #####: 4998:                    fprintf(stderr, "Invalid magic:  %x\n",
        -: 4999:                            c->binary_header.request.magic);
        -: 5000:                }
        2: 5001:                conn_set_state(c, conn_closing);
        2: 5002:                return -1;
        -: 5003:            }
        -: 5004:
    24951: 5005:            c->msgcurr = 0;
    24951: 5006:            c->msgused = 0;
    24951: 5007:            c->iovused = 0;
    24951: 5008:            if (add_msghdr(c) != 0) {
    #####: 5009:                out_of_memory(c,
        -: 5010:                        "SERVER_ERROR Out of memory allocating headers");
    #####: 5011:                return 0;
        -: 5012:            }
        -: 5013:
    24951: 5014:            c->cmd = c->binary_header.request.opcode;
    24951: 5015:            c->keylen = c->binary_header.request.keylen;
    24951: 5016:            c->opaque = c->binary_header.request.opaque;
        -: 5017:            /* clear the returned cas value */
    24951: 5018:            c->cas = 0;
        -: 5019:
    24951: 5020:            dispatch_bin_command(c);
        -: 5021:
    24951: 5022:            c->rbytes -= sizeof(c->binary_header);
    24951: 5023:            c->rcurr += sizeof(c->binary_header);
        -: 5024:        }
        -: 5025:    } else {
        -: 5026:        char *el, *cont;
        -: 5027:
   200623: 5028:        if (c->rbytes == 0)
        -: 5029:            return 0;
        -: 5030:
   200623: 5031:        el = memchr(c->rcurr, '\n', c->rbytes);
   200623: 5032:        if (!el) {
      104: 5033:            if (c->rbytes > 1024) {
        -: 5034:                /*
        -: 5035:                 * We didn't have a '\n' in the first k. This _has_ to be a
        -: 5036:                 * large multiget, if not we should just nuke the connection.
        -: 5037:                 */
        -: 5038:                char *ptr = c->rcurr;
     4200: 5039:                while (*ptr == ' ') { /* ignore leading whitespaces */
     4196: 5040:                    ++ptr;
        -: 5041:                }
        -: 5042:
        6: 5043:                if (ptr - c->rcurr > 100 ||
        3: 5044:                    (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
        -: 5045:
        2: 5046:                    conn_set_state(c, conn_closing);
        2: 5047:                    return 1;
        -: 5048:                }
        -: 5049:            }
        -: 5050:
        -: 5051:            return 0;
        -: 5052:        }
   200519: 5053:        cont = el + 1;
   200519: 5054:        if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
   120507: 5055:            el--;
        -: 5056:        }
   200519: 5057:        *el = '\0';
        -: 5058:
   200519: 5059:        assert(cont <= (c->rcurr + c->rbytes));
        -: 5060:
   200519: 5061:        c->last_cmd_time = current_time;
   200519: 5062:        process_command(c, c->rcurr);
        -: 5063:
   200518: 5064:        c->rbytes -= (cont - c->rcurr);
   200518: 5065:        c->rcurr = cont;
        -: 5066:
   200518: 5067:        assert(c->rcurr <= (c->rbuf + c->rsize));
        -: 5068:    }
        -: 5069:
        -: 5070:    return 1;
        -: 5071:}
        -: 5072:
        -: 5073:/*
        -: 5074: * read a UDP request.
        -: 5075: */
       32: 5076:static enum try_read_result try_read_udp(conn *c) {
        -: 5077:    int res;
        -: 5078:
       32: 5079:    assert(c != NULL);
        -: 5080:
       32: 5081:    c->request_addr_size = sizeof(c->request_addr);
       96: 5082:    res = recvfrom(c->sfd, c->rbuf, c->rsize,
       32: 5083:                   0, (struct sockaddr *)&c->request_addr,
        -: 5084:                   &c->request_addr_size);
       32: 5085:    if (res > 8) {
       17: 5086:        unsigned char *buf = (unsigned char *)c->rbuf;
       17: 5087:        pthread_mutex_lock(&c->thread->stats.mutex);
       17: 5088:        c->thread->stats.bytes_read += res;
       17: 5089:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5090:
        -: 5091:        /* Beginning of UDP packet is the request ID; save it. */
       17: 5092:        c->request_id = buf[0] * 256 + buf[1];
        -: 5093:
        -: 5094:        /* If this is a multi-packet request, drop it. */
       17: 5095:        if (buf[4] != 0 || buf[5] != 1) {
    #####: 5096:            out_string(c, "SERVER_ERROR multi-packet request not supported");
    #####: 5097:            return READ_NO_DATA_RECEIVED;
        -: 5098:        }
        -: 5099:
        -: 5100:        /* Don't care about any of the rest of the header. */
       17: 5101:        res -= 8;
       34: 5102:        memmove(c->rbuf, c->rbuf + 8, res);
        -: 5103:
       17: 5104:        c->rbytes = res;
       17: 5105:        c->rcurr = c->rbuf;
       17: 5106:        return READ_DATA_RECEIVED;
        -: 5107:    }
        -: 5108:    return READ_NO_DATA_RECEIVED;
        -: 5109:}
        -: 5110:
        -: 5111:/*
        -: 5112: * read from network as much as we can, handle buffer overflow and connection
        -: 5113: * close.
        -: 5114: * before reading, move the remaining incomplete fragment of a command
        -: 5115: * (if any) to the beginning of the buffer.
        -: 5116: *
        -: 5117: * To protect us from someone flooding a connection with bogus data causing
        -: 5118: * the connection to eat up all available memory, break out and start looking
        -: 5119: * at the data I've got after a number of reallocs...
        -: 5120: *
        -: 5121: * @return enum try_read_result
        -: 5122: */
   155595: 5123:static enum try_read_result try_read_network(conn *c) {
   155595: 5124:    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
        -: 5125:    int res;
   155595: 5126:    int num_allocs = 0;
   155595: 5127:    assert(c != NULL);
        -: 5128:
   155595: 5129:    if (c->rcurr != c->rbuf) {
   142917: 5130:        if (c->rbytes != 0) /* otherwise there's nothing to copy */
     1776: 5131:            memmove(c->rbuf, c->rcurr, c->rbytes);
   142917: 5132:        c->rcurr = c->rbuf;
        -: 5133:    }
        -: 5134:
        -: 5135:    while (1) {
   217605: 5136:        if (c->rbytes >= c->rsize) {
    62010: 5137:            if (num_allocs == 4) {
        -: 5138:                return gotdata;
        -: 5139:            }
    50117: 5140:            ++num_allocs;
    50117: 5141:            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
    50117: 5142:            if (!new_rbuf) {
    #####: 5143:                STATS_LOCK();
    #####: 5144:                stats.malloc_fails++;
    #####: 5145:                STATS_UNLOCK();
    #####: 5146:                if (settings.verbose > 0) {
    #####: 5147:                    fprintf(stderr, "Couldn't realloc input buffer\n");
        -: 5148:                }
    #####: 5149:                c->rbytes = 0; /* ignore what we read */
    #####: 5150:                out_of_memory(c, "SERVER_ERROR out of memory reading request");
    #####: 5151:                c->write_and_go = conn_closing;
    #####: 5152:                return READ_MEMORY_ERROR;
        -: 5153:            }
    50117: 5154:            c->rcurr = c->rbuf = new_rbuf;
    50117: 5155:            c->rsize *= 2;
        -: 5156:        }
        -: 5157:
   205712: 5158:        int avail = c->rsize - c->rbytes;
   411423: 5159:        res = read(c->sfd, c->rbuf + c->rbytes, avail);
   205711: 5160:        if (res > 0) {
   205388: 5161:            pthread_mutex_lock(&c->thread->stats.mutex);
   205388: 5162:            c->thread->stats.bytes_read += res;
   205388: 5163:            pthread_mutex_unlock(&c->thread->stats.mutex);
   205388: 5164:            gotdata = READ_DATA_RECEIVED;
   205388: 5165:            c->rbytes += res;
   205388: 5166:            if (res == avail) {
    62010: 5167:                continue;
        -: 5168:            } else {
        -: 5169:                break;
        -: 5170:            }
        -: 5171:        }
      323: 5172:        if (res == 0) {
        -: 5173:            return READ_ERROR;
        -: 5174:        }
      243: 5175:        if (res == -1) {
      243: 5176:            if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5177:                break;
        -: 5178:            }
        -: 5179:            return READ_ERROR;
        -: 5180:        }
        -: 5181:    }
        -: 5182:    return gotdata;
        -: 5183:}
        -: 5184:
   169182: 5185:static bool update_event(conn *c, const int new_flags) {
   169182: 5186:    assert(c != NULL);
        -: 5187:
   169182: 5188:    struct event_base *base = c->event.ev_base;
   169182: 5189:    if (c->ev_flags == new_flags)
        -: 5190:        return true;
      673: 5191:    if (event_del(&c->event) == -1) return false;
      673: 5192:    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
      673: 5193:    event_base_set(base, &c->event);
      673: 5194:    c->ev_flags = new_flags;
      673: 5195:    if (event_add(&c->event, 0) == -1) return false;
      673: 5196:    return true;
        -: 5197:}
        -: 5198:
        -: 5199:/*
        -: 5200: * Sets whether we are listening for new connections or not.
        -: 5201: */
    #####: 5202:void do_accept_new_conns(const bool do_accept) {
        -: 5203:    conn *next;
        -: 5204:
    #####: 5205:    for (next = listen_conn; next; next = next->next) {
    #####: 5206:        if (do_accept) {
    #####: 5207:            update_event(next, EV_READ | EV_PERSIST);
    #####: 5208:            if (listen(next->sfd, settings.backlog) != 0) {
    #####: 5209:                perror("listen");
        -: 5210:            }
        -: 5211:        }
        -: 5212:        else {
    #####: 5213:            update_event(next, 0);
    #####: 5214:            if (listen(next->sfd, 0) != 0) {
    #####: 5215:                perror("listen");
        -: 5216:            }
        -: 5217:        }
        -: 5218:    }
        -: 5219:
    #####: 5220:    if (do_accept) {
        -: 5221:        struct timeval maxconns_exited;
        -: 5222:        uint64_t elapsed_us;
    #####: 5223:        gettimeofday(&maxconns_exited,NULL);
    #####: 5224:        STATS_LOCK();
    #####: 5225:        elapsed_us =
    #####: 5226:            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
    #####: 5227:            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
    #####: 5228:        stats.time_in_listen_disabled_us += elapsed_us;
    #####: 5229:        stats_state.accepting_conns = true;
    #####: 5230:        STATS_UNLOCK();
        -: 5231:    } else {
    #####: 5232:        STATS_LOCK();
    #####: 5233:        stats_state.accepting_conns = false;
    #####: 5234:        gettimeofday(&stats.maxconns_entered,NULL);
    #####: 5235:        stats.listen_disabled_num++;
    #####: 5236:        STATS_UNLOCK();
    #####: 5237:        allow_new_conns = false;
    #####: 5238:        maxconns_handler(-42, 0, 0);
        -: 5239:    }
    #####: 5240:}
        -: 5241:
        -: 5242:/*
        -: 5243: * Transmit the next chunk of data from our list of msgbuf structures.
        -: 5244: *
        -: 5245: * Returns:
        -: 5246: *   TRANSMIT_COMPLETE   All done writing.
        -: 5247: *   TRANSMIT_INCOMPLETE More data remaining to write.
        -: 5248: *   TRANSMIT_SOFT_ERROR Can't write any more right now.
        -: 5249: *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)
        -: 5250: */
   280096: 5251:static enum transmit_result transmit(conn *c) {
   280096: 5252:    assert(c != NULL);
        -: 5253:
   560192: 5254:    if (c->msgcurr < c->msgused &&
   280096: 5255:            c->msglist[c->msgcurr].msg_iovlen == 0) {
        -: 5256:        /* Finished writing the current msg; advance to the next. */
   139681: 5257:        c->msgcurr++;
        -: 5258:    }
   280096: 5259:    if (c->msgcurr < c->msgused) {
        -: 5260:        ssize_t res;
   140415: 5261:        struct msghdr *m = &c->msglist[c->msgcurr];
        -: 5262:
   140415: 5263:        res = sendmsg(c->sfd, m, 0);
   140415: 5264:        if (res > 0) {
   140077: 5265:            pthread_mutex_lock(&c->thread->stats.mutex);
   140077: 5266:            c->thread->stats.bytes_written += res;
   140077: 5267:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5268:
        -: 5269:            /* We've written some of the data. Remove the completed
        -: 5270:               iovec entries from the list of pending writes. */
   669335: 5271:            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {
   389181: 5272:                res -= m->msg_iov->iov_len;
   389181: 5273:                m->msg_iovlen--;
   389181: 5274:                m->msg_iov++;
        -: 5275:            }
        -: 5276:
        -: 5277:            /* Might have written just part of the last iovec entry;
        -: 5278:               adjust it so the next write will do the rest. */
   140077: 5279:            if (res > 0) {
      396: 5280:                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;
      396: 5281:                m->msg_iov->iov_len -= res;
        -: 5282:            }
        -: 5283:            return TRANSMIT_INCOMPLETE;
        -: 5284:        }
      338: 5285:        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
      336: 5286:            if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5287:                if (settings.verbose > 0)
    #####: 5288:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5289:                conn_set_state(c, conn_closing);
    #####: 5290:                return TRANSMIT_HARD_ERROR;
        -: 5291:            }
        -: 5292:            return TRANSMIT_SOFT_ERROR;
        -: 5293:        }
        -: 5294:        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 5295:           we have a real error, on which we close the connection */
        2: 5296:        if (settings.verbose > 0)
    #####: 5297:            perror("Failed to write, and not due to blocking");
        -: 5298:
        2: 5299:        if (IS_UDP(c->transport))
    #####: 5300:            conn_set_state(c, conn_read);
        -: 5301:        else
        2: 5302:            conn_set_state(c, conn_closing);
        -: 5303:        return TRANSMIT_HARD_ERROR;
        -: 5304:    } else {
        -: 5305:        return TRANSMIT_COMPLETE;
        -: 5306:    }
        -: 5307:}
        -: 5308:
        -: 5309:/* Does a looped read to fill data chunks */
        -: 5310:/* TODO: restrict number of times this can loop.
        -: 5311: * Also, benchmark using readv's.
        -: 5312: */
     8778: 5313:static int read_into_chunked_item(conn *c) {
     8778: 5314:    int total = 0;
        -: 5315:    int res;
     8778: 5316:    assert(c->rcurr != c->ritem);
        -: 5317:
    88899: 5318:    while (c->rlbytes > 0) {
    86388: 5319:        item_chunk *ch = (item_chunk *)c->ritem;
    86388: 5320:        if (ch->size == ch->used) {
        -: 5321:            // FIXME: ch->next is currently always 0. remove this?
    36034: 5322:            if (ch->next) {
    #####: 5323:                c->ritem = (char *) ch->next;
        -: 5324:            } else {
        -: 5325:                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
    36034: 5326:                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
    36034: 5327:                       ((c->protocol == binary_prot) ? 2 : 0));
    36034: 5328:                if (!c->ritem) {
        -: 5329:                    // We failed an allocation. Let caller handle cleanup.
        -: 5330:                    total = -2;
        -: 5331:                    break;
        -: 5332:                }
        -: 5333:                // ritem has new chunk, restart the loop.
    36034: 5334:                continue;
        -: 5335:                //assert(c->rlbytes == 0);
        -: 5336:            }
        -: 5337:        }
        -: 5338:
    50354: 5339:        int unused = ch->size - ch->used;
        -: 5340:        /* first check if we have leftovers in the conn_read buffer */
    50354: 5341:        if (c->rbytes > 0) {
    17563: 5342:            total = 0;
    17563: 5343:            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
    17563: 5344:            tocopy = tocopy > unused ? unused : tocopy;
    17563: 5345:            if (c->ritem != c->rcurr) {
    17563: 5346:                memmove(ch->data + ch->used, c->rcurr, tocopy);
        -: 5347:            }
    17563: 5348:            total += tocopy;
    17563: 5349:            c->rlbytes -= tocopy;
    17563: 5350:            c->rcurr += tocopy;
    17563: 5351:            c->rbytes -= tocopy;
    17563: 5352:            ch->used += tocopy;
    17563: 5353:            if (c->rlbytes == 0) {
        -: 5354:                break;
        -: 5355:            }
        -: 5356:        } else {
        -: 5357:            /*  now try reading from the socket */
    65582: 5358:            res = read(c->sfd, ch->data + ch->used,
    32791: 5359:                    (unused > c->rlbytes ? c->rlbytes : unused));
    32791: 5360:            if (res > 0) {
    30130: 5361:                pthread_mutex_lock(&c->thread->stats.mutex);
    30130: 5362:                c->thread->stats.bytes_read += res;
    30130: 5363:                pthread_mutex_unlock(&c->thread->stats.mutex);
    30130: 5364:                ch->used += res;
    30130: 5365:                total += res;
    30130: 5366:                c->rlbytes -= res;
        -: 5367:            } else {
        -: 5368:                /* Reset total to the latest result so caller can handle it */
        -: 5369:                total = res;
        -: 5370:                break;
        -: 5371:            }
        -: 5372:        }
        -: 5373:    }
        -: 5374:
        -: 5375:    /* At some point I will be able to ditch the \r\n from item storage and
        -: 5376:       remove all of these kludges.
        -: 5377:       The above binprot check ensures inline space for \r\n, but if we do
        -: 5378:       exactly enough allocs there will be no additional chunk for \r\n.
        -: 5379:     */
     8778: 5380:    if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {
      201: 5381:        item_chunk *ch = (item_chunk *)c->ritem;
      201: 5382:        if (ch->size - ch->used < 2) {
        2: 5383:            c->ritem = (char *) do_item_alloc_chunk(ch, 2);
        2: 5384:            if (!c->ritem) {
    #####: 5385:                total = -2;
        -: 5386:            }
        -: 5387:        }
        -: 5388:    }
     8778: 5389:    return total;
        -: 5390:}
        -: 5391:
   169399: 5392:static void drive_machine(conn *c) {
   169399: 5393:    bool stop = false;
        -: 5394:    int sfd;
        -: 5395:    socklen_t addrlen;
        -: 5396:    struct sockaddr_storage addr;
   169399: 5397:    int nreqs = settings.reqs_per_event;
        -: 5398:    int res;
        -: 5399:    const char *str;
        -: 5400:#ifdef HAVE_ACCEPT4
        -: 5401:    static int  use_accept4 = 1;
        -: 5402:#else
        -: 5403:    static int  use_accept4 = 0;
        -: 5404:#endif
        -: 5405:
   169399: 5406:    assert(c != NULL);
        -: 5407:
  1482493: 5408:    while (!stop) {
        -: 5409:
  1313096: 5410:        switch(c->state) {
        -: 5411:        case conn_listening:
      113: 5412:            addrlen = sizeof(addr);
        -: 5413:#ifdef HAVE_ACCEPT4
      113: 5414:            if (use_accept4) {
      113: 5415:                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
        -: 5416:            } else {
    #####: 5417:                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5418:            }
        -: 5419:#else
        -: 5420:            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5421:#endif
      113: 5422:            if (sfd == -1) {
    #####: 5423:                if (use_accept4 && errno == ENOSYS) {
    #####: 5424:                    use_accept4 = 0;
    #####: 5425:                    continue;
        -: 5426:                }
    #####: 5427:                perror(use_accept4 ? "accept4()" : "accept()");
    #####: 5428:                if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5429:                    /* these are transient, so don't log anything */
        -: 5430:                    stop = true;
    #####: 5431:                } else if (errno == EMFILE) {
    #####: 5432:                    if (settings.verbose > 0)
    #####: 5433:                        fprintf(stderr, "Too many open connections\n");
    #####: 5434:                    accept_new_conns(false);
    #####: 5435:                    stop = true;
        -: 5436:                } else {
    #####: 5437:                    perror("accept()");
    #####: 5438:                    stop = true;
        -: 5439:                }
        -: 5440:                break;
        -: 5441:            }
      113: 5442:            if (!use_accept4) {
    #####: 5443:                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
    #####: 5444:                    perror("setting O_NONBLOCK");
    #####: 5445:                    close(sfd);
    #####: 5446:                    break;
        -: 5447:                }
        -: 5448:            }
        -: 5449:
      217: 5450:            if (settings.maxconns_fast &&
      104: 5451:                stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 5452:                str = "ERROR Too many open connections\r\n";
    #####: 5453:                res = write(sfd, str, strlen(str));
    #####: 5454:                close(sfd);
    #####: 5455:                STATS_LOCK();
    #####: 5456:                stats.rejected_conns++;
    #####: 5457:                STATS_UNLOCK();
        -: 5458:            } else {
      113: 5459:                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
        -: 5460:                                     DATA_BUFFER_SIZE, c->transport);
        -: 5461:            }
        -: 5462:
        -: 5463:            stop = true;
        -: 5464:            break;
        -: 5465:
        -: 5466:        case conn_waiting:
   155638: 5467:            if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5468:                if (settings.verbose > 0)
    #####: 5469:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5470:                conn_set_state(c, conn_closing);
    #####: 5471:                break;
        -: 5472:            }
        -: 5473:
   155638: 5474:            conn_set_state(c, conn_read);
   155638: 5475:            stop = true;
   155638: 5476:            break;
        -: 5477:
        -: 5478:        case conn_read:
   155627: 5479:            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);
        -: 5480:
   155626: 5481:            switch (res) {
        -: 5482:            case READ_NO_DATA_RECEIVED:
       15: 5483:                conn_set_state(c, conn_waiting);
       16: 5484:                break;
        -: 5485:            case READ_DATA_RECEIVED:
   155531: 5486:                conn_set_state(c, conn_parse_cmd);
   155531: 5487:                break;
        -: 5488:            case READ_ERROR:
       80: 5489:                conn_set_state(c, conn_closing);
       80: 5490:                break;
        -: 5491:            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
        -: 5492:                /* State already set by try_read_network */
        -: 5493:                break;
        -: 5494:            }
        -: 5495:            break;
        -: 5496:
        -: 5497:        case conn_parse_cmd :
   227252: 5498:            if (try_read_command(c) == 0) {
        -: 5499:                /* wee need more data! */
     1778: 5500:                conn_set_state(c, conn_waiting);
        -: 5501:            }
        -: 5502:
        -: 5503:            break;
        -: 5504:
        -: 5505:        case conn_new_cmd:
        -: 5506:            /* Only process nreqs at a time to avoid starving other
        -: 5507:               connections */
        -: 5508:
   226585: 5509:            --nreqs;
   226585: 5510:            if (nreqs >= 0) {
   225565: 5511:                reset_cmd_handler(c);
        -: 5512:            } else {
     1020: 5513:                pthread_mutex_lock(&c->thread->stats.mutex);
     1020: 5514:                c->thread->stats.conn_yields++;
     1020: 5515:                pthread_mutex_unlock(&c->thread->stats.mutex);
     1020: 5516:                if (c->rbytes > 0) {
        -: 5517:                    /* We have already read in data into the input buffer,
        -: 5518:                       so libevent will most likely not signal read events
        -: 5519:                       on the socket (unless more data is available. As a
        -: 5520:                       hack we should just put in a request to write data,
        -: 5521:                       because that should be possible ;-)
        -: 5522:                    */
     1018: 5523:                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5524:                        if (settings.verbose > 0)
    #####: 5525:                            fprintf(stderr, "Couldn't update event\n");
    #####: 5526:                        conn_set_state(c, conn_closing);
    #####: 5527:                        break;
        -: 5528:                    }
        -: 5529:                }
        -: 5530:                stop = true;
        -: 5531:            }
        -: 5532:            break;
        -: 5533:
        -: 5534:        case conn_nread:
   266965: 5535:            if (c->rlbytes == 0) {
   124343: 5536:                complete_nread(c);
   124343: 5537:                break;
        -: 5538:            }
        -: 5539:
        -: 5540:            /* Check if rbytes < 0, to prevent crash */
   142622: 5541:            if (c->rlbytes < 0) {
    #####: 5542:                if (settings.verbose) {
    #####: 5543:                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
        -: 5544:                }
    #####: 5545:                conn_set_state(c, conn_closing);
    #####: 5546:                break;
        -: 5547:            }
        -: 5548:
   142622: 5549:            if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {
        -: 5550:                /* first check if we have leftovers in the conn_read buffer */
   133844: 5551:                if (c->rbytes > 0) {
   116201: 5552:                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
   116201: 5553:                    if (c->ritem != c->rcurr) {
    94822: 5554:                        memmove(c->ritem, c->rcurr, tocopy);
        -: 5555:                    }
   116201: 5556:                    c->ritem += tocopy;
   116201: 5557:                    c->rlbytes -= tocopy;
   116201: 5558:                    c->rcurr += tocopy;
   116201: 5559:                    c->rbytes -= tocopy;
   116201: 5560:                    if (c->rlbytes == 0) {
        -: 5561:                        break;
        -: 5562:                    }
        -: 5563:                }
        -: 5564:
        -: 5565:                /*  now try reading from the socket */
    70406: 5566:                res = read(c->sfd, c->ritem, c->rlbytes);
    35203: 5567:                if (res > 0) {
    25878: 5568:                    pthread_mutex_lock(&c->thread->stats.mutex);
    25878: 5569:                    c->thread->stats.bytes_read += res;
    25878: 5570:                    pthread_mutex_unlock(&c->thread->stats.mutex);
    25878: 5571:                    if (c->rcurr == c->ritem) {
     1813: 5572:                        c->rcurr += res;
        -: 5573:                    }
    25878: 5574:                    c->ritem += res;
    25878: 5575:                    c->rlbytes -= res;
    25878: 5576:                    break;
        -: 5577:                }
        -: 5578:            } else {
     8778: 5579:                res = read_into_chunked_item(c);
     8778: 5580:                if (res > 0)
        -: 5581:                    break;
        -: 5582:            }
        -: 5583:
    11986: 5584:            if (res == 0) { /* end of stream */
        1: 5585:                conn_set_state(c, conn_closing);
        1: 5586:                break;
        -: 5587:            }
        -: 5588:
    11985: 5589:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    11985: 5590:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5591:                    if (settings.verbose > 0)
    #####: 5592:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5593:                    conn_set_state(c, conn_closing);
    #####: 5594:                    break;
        -: 5595:                }
        -: 5596:                stop = true;
        -: 5597:                break;
        -: 5598:            }
        -: 5599:
        -: 5600:            /* Memory allocation failure */
    #####: 5601:            if (res == -2) {
    #####: 5602:                out_of_memory(c, "SERVER_ERROR Out of memory during read");
    #####: 5603:                c->sbytes = c->rlbytes;
    #####: 5604:                c->write_and_go = conn_swallow;
    #####: 5605:                break;
        -: 5606:            }
        -: 5607:            /* otherwise we have a real error, on which we close the connection */
    #####: 5608:            if (settings.verbose > 0) {
    #####: 5609:                fprintf(stderr, "Failed to read, and not due to blocking:\n"
        -: 5610:                        "errno: %d %s \n"
        -: 5611:                        "rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
    #####: 5612:                        errno, strerror(errno),
    #####: 5613:                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,
        -: 5614:                        (int)c->rlbytes, (int)c->rsize);
        -: 5615:            }
    #####: 5616:            conn_set_state(c, conn_closing);
    #####: 5617:            break;
        -: 5618:
        -: 5619:        case conn_swallow:
        -: 5620:            /* we are reading sbytes and throwing them away */
      719: 5621:            if (c->sbytes <= 0) {
       10: 5622:                conn_set_state(c, conn_new_cmd);
       10: 5623:                break;
        -: 5624:            }
        -: 5625:
        -: 5626:            /* first check if we have leftovers in the conn_read buffer */
      709: 5627:            if (c->rbytes > 0) {
        9: 5628:                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
        9: 5629:                c->sbytes -= tocopy;
        9: 5630:                c->rcurr += tocopy;
        9: 5631:                c->rbytes -= tocopy;
        9: 5632:                break;
        -: 5633:            }
        -: 5634:
        -: 5635:            /*  now try reading from the socket */
     1400: 5636:            res = read(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
      700: 5637:            if (res > 0) {
      495: 5638:                pthread_mutex_lock(&c->thread->stats.mutex);
      495: 5639:                c->thread->stats.bytes_read += res;
      495: 5640:                pthread_mutex_unlock(&c->thread->stats.mutex);
      495: 5641:                c->sbytes -= res;
      495: 5642:                break;
        -: 5643:            }
      205: 5644:            if (res == 0) { /* end of stream */
    #####: 5645:                conn_set_state(c, conn_closing);
    #####: 5646:                break;
        -: 5647:            }
      205: 5648:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
      205: 5649:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5650:                    if (settings.verbose > 0)
    #####: 5651:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5652:                    conn_set_state(c, conn_closing);
    #####: 5653:                    break;
        -: 5654:                }
        -: 5655:                stop = true;
        -: 5656:                break;
        -: 5657:            }
        -: 5658:            /* otherwise we have a real error, on which we close the connection */
    #####: 5659:            if (settings.verbose > 0)
    #####: 5660:                fprintf(stderr, "Failed to read, and not due to blocking\n");
    #####: 5661:            conn_set_state(c, conn_closing);
    #####: 5662:            break;
        -: 5663:
        -: 5664:        case conn_write:
        -: 5665:            /*
        -: 5666:             * We want to write out a simple response. If we haven't already,
        -: 5667:             * assemble it into a msgbuf list (this will be a single-entry
        -: 5668:             * list for TCP or a two-entry list for UDP).
        -: 5669:             */
    45040: 5670:            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
    22521: 5671:                if (add_iov(c, c->wcurr, c->wbytes) != 0) {
    #####: 5672:                    if (settings.verbose > 0)
    #####: 5673:                        fprintf(stderr, "Couldn't build response\n");
    #####: 5674:                    conn_set_state(c, conn_closing);
    #####: 5675:                    break;
        -: 5676:                }
        -: 5677:            }
        -: 5678:
        -: 5679:            /* fall through... */
        -: 5680:
        -: 5681:        case conn_mwrite:
        -: 5682:#ifdef EXTSTORE
        -: 5683:            /* have side IO's that must process before transmit() can run.
        -: 5684:             * remove the connection from the worker thread and dispatch the
        -: 5685:             * IO queue
        -: 5686:             */
        -: 5687:            if (c->io_wrapleft) {
        -: 5688:                assert(c->io_queued == false);
        -: 5689:                assert(c->io_wraplist != NULL);
        -: 5690:                // TODO: create proper state for this condition
        -: 5691:                conn_set_state(c, conn_watch);
        -: 5692:                event_del(&c->event);
        -: 5693:                c->io_queued = true;
        -: 5694:                extstore_submit(c->thread->storage, &c->io_wraplist->io);
        -: 5695:                stop = true;
        -: 5696:                break;
        -: 5697:            }
        -: 5698:#endif
   280096: 5699:          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
    #####: 5700:            if (settings.verbose > 0)
    #####: 5701:              fprintf(stderr, "Failed to build UDP headers\n");
    #####: 5702:            conn_set_state(c, conn_closing);
    #####: 5703:            break;
        -: 5704:          }
   280096: 5705:            switch (transmit(c)) {
        -: 5706:            case TRANSMIT_COMPLETE:
   139681: 5707:                if (c->state == conn_mwrite) {
   117162: 5708:                    conn_release_items(c);
        -: 5709:                    /* XXX:  I don't know why this wasn't the general case */
   117162: 5710:                    if(c->protocol == binary_prot) {
     4869: 5711:                        conn_set_state(c, c->write_and_go);
        -: 5712:                    } else {
   112293: 5713:                        conn_set_state(c, conn_new_cmd);
        -: 5714:                    }
    22519: 5715:                } else if (c->state == conn_write) {
    22519: 5716:                    if (c->write_and_free) {
     2710: 5717:                        free(c->write_and_free);
     2710: 5718:                        c->write_and_free = 0;
        -: 5719:                    }
    22519: 5720:                    conn_set_state(c, c->write_and_go);
        -: 5721:                } else {
    #####: 5722:                    if (settings.verbose > 0)
    #####: 5723:                        fprintf(stderr, "Unexpected state %d\n", c->state);
    #####: 5724:                    conn_set_state(c, conn_closing);
        -: 5725:                }
        -: 5726:                break;
        -: 5727:
        -: 5728:            case TRANSMIT_INCOMPLETE:
        -: 5729:            case TRANSMIT_HARD_ERROR:
        -: 5730:                break;                   /* Continue in state machine. */
        -: 5731:
        -: 5732:            case TRANSMIT_SOFT_ERROR:
      336: 5733:                stop = true;
      336: 5734:                break;
        -: 5735:            }
        -: 5736:            break;
        -: 5737:
        -: 5738:        case conn_closing:
       97: 5739:            if (IS_UDP(c->transport))
    #####: 5740:                conn_cleanup(c);
        -: 5741:            else
       97: 5742:                conn_close(c);
        -: 5743:            stop = true;
        -: 5744:            break;
        -: 5745:
        -: 5746:        case conn_closed:
        -: 5747:            /* This only happens if dormando is an idiot. */
    #####: 5748:            abort();
        -: 5749:            break;
        -: 5750:
        -: 5751:        case conn_watch:
        -: 5752:            /* We handed off our connection to the logger thread. */
        -: 5753:            stop = true;
        -: 5754:            break;
        -: 5755:        case conn_max_state:
    #####: 5756:            assert(false);
        -: 5757:            break;
        -: 5758:        }
        -: 5759:    }
        -: 5760:
   169397: 5761:    return;
        -: 5762:}
        -: 5763:
   169398: 5764:void event_handler(const int fd, const short which, void *arg) {
        -: 5765:    conn *c;
        -: 5766:
   169398: 5767:    c = (conn *)arg;
   169398: 5768:    assert(c != NULL);
        -: 5769:
   169398: 5770:    c->which = which;
        -: 5771:
        -: 5772:    /* sanity */
   169398: 5773:    if (fd != c->sfd) {
    #####: 5774:        if (settings.verbose > 0)
    #####: 5775:            fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
    #####: 5776:        conn_close(c);
    #####: 5777:        return;
        -: 5778:    }
        -: 5779:
   169398: 5780:    drive_machine(c);
        -: 5781:
        -: 5782:    /* wait for next event */
   169396: 5783:    return;
        -: 5784:}
        -: 5785:
       52: 5786:static int new_socket(struct addrinfo *ai) {
        -: 5787:    int sfd;
        -: 5788:    int flags;
        -: 5789:
       52: 5790:    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        -: 5791:        return -1;
        -: 5792:    }
        -: 5793:
      104: 5794:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
       52: 5795:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 5796:        perror("setting O_NONBLOCK");
    #####: 5797:        close(sfd);
        -: 5798:        return -1;
        -: 5799:    }
        -: 5800:    return sfd;
        -: 5801:}
        -: 5802:
        -: 5803:
        -: 5804:/*
        -: 5805: * Sets a socket's send buffer size to the maximum allowed by the system.
        -: 5806: */
       18: 5807:static void maximize_sndbuf(const int sfd) {
       18: 5808:    socklen_t intsize = sizeof(int);
       18: 5809:    int last_good = 0;
        -: 5810:    int min, max, avg;
        -: 5811:    int old_size;
        -: 5812:
        -: 5813:    /* Start with the default size. */
       18: 5814:    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
    #####: 5815:        if (settings.verbose > 0)
    #####: 5816:            perror("getsockopt(SO_SNDBUF)");
    #####: 5817:        return;
        -: 5818:    }
        -: 5819:
        -: 5820:    /* Binary-search for the real maximum. */
       18: 5821:    min = old_size;
       18: 5822:    max = MAX_SENDBUF_SIZE;
        -: 5823:
      540: 5824:    while (min <= max) {
      504: 5825:        avg = ((unsigned int)(min + max)) / 2;
      504: 5826:        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
      504: 5827:            last_good = avg;
      504: 5828:            min = avg + 1;
        -: 5829:        } else {
    #####: 5830:            max = avg - 1;
        -: 5831:        }
        -: 5832:    }
        -: 5833:
       18: 5834:    if (settings.verbose > 1)
    #####: 5835:        fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
        -: 5836:}
        -: 5837:
        -: 5838:/**
        -: 5839: * Create a socket and bind it to a specific port number
        -: 5840: * @param interface the interface to bind to
        -: 5841: * @param port the port number to bind to
        -: 5842: * @param transport the transport protocol (TCP / UDP)
        -: 5843: * @param portnumber_file A filepointer to write the port numbers to
        -: 5844: *        when they are successfully added to the list of ports we
        -: 5845: *        listen on.
        -: 5846: */
       33: 5847:static int server_socket(const char *interface,
        -: 5848:                         int port,
        -: 5849:                         enum network_transport transport,
        -: 5850:                         FILE *portnumber_file) {
        -: 5851:    int sfd;
       33: 5852:    struct linger ling = {0, 0};
        -: 5853:    struct addrinfo *ai;
        -: 5854:    struct addrinfo *next;
       33: 5855:    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
        -: 5856:                              .ai_family = AF_UNSPEC };
        -: 5857:    char port_buf[NI_MAXSERV];
        -: 5858:    int error;
       33: 5859:    int success = 0;
       33: 5860:    int flags =1;
        -: 5861:
       33: 5862:    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;
        -: 5863:
       33: 5864:    if (port == -1) {
        9: 5865:        port = 0;
        -: 5866:    }
       33: 5867:    snprintf(port_buf, sizeof(port_buf), "%d", port);
       33: 5868:    error= getaddrinfo(interface, port_buf, &hints, &ai);
       33: 5869:    if (error != 0) {
        1: 5870:        if (error != EAI_SYSTEM)
        1: 5871:          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
        -: 5872:        else
    #####: 5873:          perror("getaddrinfo()");
        -: 5874:        return 1;
        -: 5875:    }
        -: 5876:
       84: 5877:    for (next= ai; next; next= next->ai_next) {
        -: 5878:        conn *listen_conn_add;
       52: 5879:        if ((sfd = new_socket(next)) == -1) {
        -: 5880:            /* getaddrinfo can return "junk" addresses,
        -: 5881:             * we make sure at least one works before erroring.
        -: 5882:             */
    #####: 5883:            if (errno == EMFILE) {
        -: 5884:                /* ...unless we're out of fds */
    #####: 5885:                perror("server_socket");
    #####: 5886:                exit(EX_OSERR);
        -: 5887:            }
    #####: 5888:            continue;
        -: 5889:        }
        -: 5890:
        -: 5891:#ifdef IPV6_V6ONLY
       52: 5892:        if (next->ai_family == AF_INET6) {
       20: 5893:            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
       20: 5894:            if (error != 0) {
    #####: 5895:                perror("setsockopt");
    #####: 5896:                close(sfd);
    #####: 5897:                continue;
        -: 5898:            }
        -: 5899:        }
        -: 5900:#endif
        -: 5901:
       52: 5902:        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
       52: 5903:        if (IS_UDP(transport)) {
       18: 5904:            maximize_sndbuf(sfd);
        -: 5905:        } else {
       34: 5906:            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
       34: 5907:            if (error != 0)
    #####: 5908:                perror("setsockopt");
        -: 5909:
       34: 5910:            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
       34: 5911:            if (error != 0)
    #####: 5912:                perror("setsockopt");
        -: 5913:
       34: 5914:            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
       34: 5915:            if (error != 0)
    #####: 5916:                perror("setsockopt");
        -: 5917:        }
        -: 5918:
       52: 5919:        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
    #####: 5920:            if (errno != EADDRINUSE) {
    #####: 5921:                perror("bind()");
    #####: 5922:                close(sfd);
    #####: 5923:                freeaddrinfo(ai);
    #####: 5924:                return 1;
        -: 5925:            }
    #####: 5926:            close(sfd);
    #####: 5927:            continue;
        -: 5928:        } else {
       52: 5929:            success++;
       52: 5930:            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
    #####: 5931:                perror("listen()");
    #####: 5932:                close(sfd);
    #####: 5933:                freeaddrinfo(ai);
    #####: 5934:                return 1;
        -: 5935:            }
       92: 5936:            if (portnumber_file != NULL &&
       40: 5937:                (next->ai_addr->sa_family == AF_INET ||
        -: 5938:                 next->ai_addr->sa_family == AF_INET6)) {
        -: 5939:                union {
        -: 5940:                    struct sockaddr_in in;
        -: 5941:                    struct sockaddr_in6 in6;
        -: 5942:                } my_sockaddr;
       40: 5943:                socklen_t len = sizeof(my_sockaddr);
       40: 5944:                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
       40: 5945:                    if (next->ai_addr->sa_family == AF_INET) {
       20: 5946:                        fprintf(portnumber_file, "%s INET: %u\n",
        -: 5947:                                IS_UDP(transport) ? "UDP" : "TCP",
       20: 5948:                                ntohs(my_sockaddr.in.sin_port));
        -: 5949:                    } else {
       20: 5950:                        fprintf(portnumber_file, "%s INET6: %u\n",
        -: 5951:                                IS_UDP(transport) ? "UDP" : "TCP",
       20: 5952:                                ntohs(my_sockaddr.in6.sin6_port));
        -: 5953:                    }
        -: 5954:                }
        -: 5955:            }
        -: 5956:        }
        -: 5957:
       52: 5958:        if (IS_UDP(transport)) {
        -: 5959:            int c;
        -: 5960:
       72: 5961:            for (c = 0; c < settings.num_threads_per_udp; c++) {
        -: 5962:                /* Allocate one UDP file descriptor per worker thread;
        -: 5963:                 * this allows "stats conns" to separately list multiple
        -: 5964:                 * parallel UDP requests in progress.
        -: 5965:                 *
        -: 5966:                 * The dispatch code round-robins new connection requests
        -: 5967:                 * among threads, so this is guaranteed to assign one
        -: 5968:                 * FD to each thread.
        -: 5969:                 */
       72: 5970:                int per_thread_fd = c ? dup(sfd) : sfd;
       72: 5971:                dispatch_conn_new(per_thread_fd, conn_read,
        -: 5972:                                  EV_READ | EV_PERSIST,
        -: 5973:                                  UDP_READ_BUFFER_SIZE, transport);
        -: 5974:            }
        -: 5975:        } else {
       34: 5976:            if (!(listen_conn_add = conn_new(sfd, conn_listening,
        -: 5977:                                             EV_READ | EV_PERSIST, 1,
        -: 5978:                                             transport, main_base))) {
    #####: 5979:                fprintf(stderr, "failed to create listening connection\n");
    #####: 5980:                exit(EXIT_FAILURE);
        -: 5981:            }
       34: 5982:            listen_conn_add->next = listen_conn;
       34: 5983:            listen_conn = listen_conn_add;
        -: 5984:        }
        -: 5985:    }
        -: 5986:
       32: 5987:    freeaddrinfo(ai);
        -: 5988:
        -: 5989:    /* Return zero iff we detected no errors in starting up connections */
       32: 5990:    return success == 0;
        -: 5991:}
        -: 5992:
       33: 5993:static int server_sockets(int port, enum network_transport transport,
        -: 5994:                          FILE *portnumber_file) {
       33: 5995:    if (settings.inter == NULL) {
       20: 5996:        return server_socket(settings.inter, port, transport, portnumber_file);
        -: 5997:    } else {
        -: 5998:        // tokenize them and bind to each one of them..
        -: 5999:        char *b;
       13: 6000:        int ret = 0;
       13: 6001:        char *list = strdup(settings.inter);
        -: 6002:
       13: 6003:        if (list == NULL) {
    #####: 6004:            fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
    #####: 6005:            return 1;
        -: 6006:        }
       39: 6007:        for (char *p = strtok_r(list, ";,", &b);
        -: 6008:             p != NULL;
       13: 6009:             p = strtok_r(NULL, ";,", &b)) {
       13: 6010:            int the_port = port;
        -: 6011:
       13: 6012:            char *h = NULL;
       13: 6013:            if (*p == '[') {
        -: 6014:                // expecting it to be an IPv6 address enclosed in []
        -: 6015:                // i.e. RFC3986 style recommended by RFC5952
    #####: 6016:                char *e = strchr(p, ']');
    #####: 6017:                if (e == NULL) {
    #####: 6018:                    fprintf(stderr, "Invalid IPV6 address: \"%s\"", p);
    #####: 6019:                    free(list);
    #####: 6020:                    return 1;
        -: 6021:                }
    #####: 6022:                h = ++p; // skip the opening '['
    #####: 6023:                *e = '\0';
    #####: 6024:                p = ++e; // skip the closing ']'
        -: 6025:            }
        -: 6026:
       13: 6027:            char *s = strchr(p, ':');
       13: 6028:            if (s != NULL) {
        -: 6029:                // If no more semicolons - attempt to treat as port number.
        -: 6030:                // Otherwise the only valid option is an unenclosed IPv6 without port, until
        -: 6031:                // of course there was an RFC3986 IPv6 address previously specified -
        -: 6032:                // in such a case there is no good option, will just send it to fail as port number.
    #####: 6033:                if (strchr(s + 1, ':') == NULL || h != NULL) {
    #####: 6034:                    *s = '\0';
    #####: 6035:                    ++s;
    #####: 6036:                    if (!safe_strtol(s, &the_port)) {
    #####: 6037:                        fprintf(stderr, "Invalid port number: \"%s\"", s);
    #####: 6038:                        free(list);
    #####: 6039:                        return 1;
        -: 6040:                    }
        -: 6041:                }
        -: 6042:            }
        -: 6043:
       13: 6044:            if (h != NULL)
    #####: 6045:                p = h;
        -: 6046:
       13: 6047:            if (strcmp(p, "*") == 0) {
    #####: 6048:                p = NULL;
        -: 6049:            }
       13: 6050:            ret |= server_socket(p, the_port, transport, portnumber_file);
        -: 6051:        }
       13: 6052:        free(list);
       13: 6053:        return ret;
        -: 6054:    }
        -: 6055:}
        -: 6056:
       73: 6057:static int new_socket_unix(void) {
        -: 6058:    int sfd;
        -: 6059:    int flags;
        -: 6060:
       73: 6061:    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    #####: 6062:        perror("socket()");
    #####: 6063:        return -1;
        -: 6064:    }
        -: 6065:
      146: 6066:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
       73: 6067:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6068:        perror("setting O_NONBLOCK");
    #####: 6069:        close(sfd);
    #####: 6070:        return -1;
        -: 6071:    }
        -: 6072:    return sfd;
        -: 6073:}
        -: 6074:
       73: 6075:static int server_socket_unix(const char *path, int access_mask) {
        -: 6076:    int sfd;
       73: 6077:    struct linger ling = {0, 0};
        -: 6078:    struct sockaddr_un addr;
        -: 6079:    struct stat tstat;
       73: 6080:    int flags =1;
        -: 6081:    int old_umask;
        -: 6082:
       73: 6083:    if (!path) {
        -: 6084:        return 1;
        -: 6085:    }
        -: 6086:
       73: 6087:    if ((sfd = new_socket_unix()) == -1) {
        -: 6088:        return 1;
        -: 6089:    }
        -: 6090:
        -: 6091:    /*
        -: 6092:     * Clean up a previous socket file if we left it around
        -: 6093:     */
       73: 6094:    if (lstat(path, &tstat) == 0) {
    #####: 6095:        if (S_ISSOCK(tstat.st_mode))
    #####: 6096:            unlink(path);
        -: 6097:    }
        -: 6098:
       73: 6099:    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
       73: 6100:    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
       73: 6101:    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        -: 6102:
        -: 6103:    /*
        -: 6104:     * the memset call clears nonstandard fields in some implementations
        -: 6105:     * that otherwise mess things up.
        -: 6106:     */
       73: 6107:    memset(&addr, 0, sizeof(addr));
        -: 6108:
       73: 6109:    addr.sun_family = AF_UNIX;
       73: 6110:    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
       73: 6111:    assert(strcmp(addr.sun_path, path) == 0);
       73: 6112:    old_umask = umask( ~(access_mask&0777));
       73: 6113:    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    #####: 6114:        perror("bind()");
    #####: 6115:        close(sfd);
    #####: 6116:        umask(old_umask);
    #####: 6117:        return 1;
        -: 6118:    }
       73: 6119:    umask(old_umask);
       73: 6120:    if (listen(sfd, settings.backlog) == -1) {
    #####: 6121:        perror("listen()");
    #####: 6122:        close(sfd);
    #####: 6123:        return 1;
        -: 6124:    }
       73: 6125:    if (!(listen_conn = conn_new(sfd, conn_listening,
        -: 6126:                                 EV_READ | EV_PERSIST, 1,
        -: 6127:                                 local_transport, main_base))) {
    #####: 6128:        fprintf(stderr, "failed to create listening connection\n");
    #####: 6129:        exit(EXIT_FAILURE);
        -: 6130:    }
        -: 6131:
        -: 6132:    return 0;
        -: 6133:}
        -: 6134:
        -: 6135:/*
        -: 6136: * We keep the current time of day in a global variable that's updated by a
        -: 6137: * timer event. This saves us a bunch of time() system calls (we really only
        -: 6138: * need to get the time once a second, whereas there can be tens of thousands
        -: 6139: * of requests a second) and allows us to use server-start-relative timestamps
        -: 6140: * rather than absolute UNIX timestamps, a space savings on systems where
        -: 6141: * sizeof(time_t) > sizeof(unsigned int).
        -: 6142: */
        -: 6143:volatile rel_time_t current_time;
        -: 6144:static struct event clockevent;
        -: 6145:
        -: 6146:/* libevent uses a monotonic clock when available for event scheduling. Aside
        -: 6147: * from jitter, simply ticking our internal timer here is accurate enough.
        -: 6148: * Note that users who are setting explicit dates for expiration times *must*
        -: 6149: * ensure their clocks are correct before starting memcached. */
      249: 6150:static void clock_handler(const int fd, const short which, void *arg) {
      249: 6151:    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
        -: 6152:    static bool initialized = false;
        -: 6153:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        -: 6154:    static bool monotonic = false;
        -: 6155:    static time_t monotonic_start;
        -: 6156:#endif
        -: 6157:
      249: 6158:    if (initialized) {
        -: 6159:        /* only delete the event if it's actually there. */
      154: 6160:        evtimer_del(&clockevent);
        -: 6161:    } else {
       95: 6162:        initialized = true;
        -: 6163:        /* process_started is initialized to time() - 2. We initialize to 1 so
        -: 6164:         * flush_all won't underflow during tests. */
        -: 6165:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        -: 6166:        struct timespec ts;
       95: 6167:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
       95: 6168:            monotonic = true;
       95: 6169:            monotonic_start = ts.tv_sec - ITEM_UPDATE_INTERVAL - 2;
        -: 6170:        }
        -: 6171:#endif
        -: 6172:    }
        -: 6173:
        -: 6174:    // While we're here, check for hash table expansion.
        -: 6175:    // This function should be quick to avoid delaying the timer.
      249: 6176:    assoc_start_expand(stats_state.curr_items);
        -: 6177:
      249: 6178:    evtimer_set(&clockevent, clock_handler, 0);
      249: 6179:    event_base_set(main_base, &clockevent);
      249: 6180:    evtimer_add(&clockevent, &t);
        -: 6181:
        -: 6182:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
      249: 6183:    if (monotonic) {
        -: 6184:        struct timespec ts;
      249: 6185:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
        -: 6186:            return;
      249: 6187:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
      249: 6188:        return;
        -: 6189:    }
        -: 6190:#endif
        -: 6191:    {
        -: 6192:        struct timeval tv;
    #####: 6193:        gettimeofday(&tv, NULL);
    #####: 6194:        current_time = (rel_time_t) (tv.tv_sec - process_started);
        -: 6195:    }
        -: 6196:}
        -: 6197:
       16: 6198:static void usage(void) {
       16: 6199:    printf(PACKAGE " " VERSION "\n");
       16: 6200:    printf("-p, --port=<num>          TCP port to listen on (default: 11211)\n"
        -: 6201:           "-U, --udp-port=<num>      UDP port to listen on (default: 0, off)\n"
        -: 6202:           "-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\n"
        -: 6203:           "-A, --enable-shutdown     enable ascii \"shutdown\" command\n"
        -: 6204:           "-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: 0700)\n"
        -: 6205:           "-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n"
        -: 6206:           "-d, --daemon              run as a daemon\n"
        -: 6207:           "-r, --enable-coredumps    maximize core file limit\n"
        -: 6208:           "-u, --user=<user>         assume identity of <username> (only when run as root)\n"
        -: 6209:           "-m, --memory-limit=<num>  item memory in megabytes (default: 64 MB)\n"
        -: 6210:           "-M, --disable-evictions   return error on memory exhausted instead of evicting\n"
        -: 6211:           "-c, --conn-limit=<num>    max simultaneous connections (default: 1024)\n"
        -: 6212:           "-k, --lock-memory         lock down all paged memory\n"
        -: 6213:           "-v, --verbose             verbose (print errors/warnings while in event loop)\n"
        -: 6214:           "-vv                       very verbose (also print client commands/responses)\n"
        -: 6215:           "-vvv                      extremely verbose (internal state transitions)\n"
        -: 6216:           "-h, --help                print this help and exit\n"
        -: 6217:           "-i, --license             print memcached and libevent license\n"
        -: 6218:           "-V, --version             print version and exit\n"
        -: 6219:           "-P, --pidfile=<file>      save PID in <file>, only used with -d option\n"
        -: 6220:           "-f, --slab-growth-factor=<num> chunk size growth factor (default: 1.25)\n"
        -: 6221:           "-n, --slab-min-size=<bytes> min space used for key+value+flags (default: 48)\n");
       16: 6222:    printf("-L, --enable-largepages  try to use large memory pages (if available)\n");
       16: 6223:    printf("-D <char>     Use <char> as the delimiter between key prefixes and IDs.\n"
        -: 6224:           "              This is used for per-prefix stats reporting. The default is\n"
        -: 6225:           "              \":\" (colon). If this option is specified, stats collection\n"
        -: 6226:           "              is turned on automatically; if not, then it may be turned on\n"
        -: 6227:           "              by sending the \"stats detail on\" command to the server.\n");
       16: 6228:    printf("-t, --threads=<num>       number of threads to use (default: 4)\n");
       16: 6229:    printf("-R, --max-reqs-per-event  maximum number of requests per event, limits the\n"
        -: 6230:           "                          requests processed per connection to prevent \n"
        -: 6231:           "                          starvation (default: 20)\n");
       16: 6232:    printf("-C, --disable-cas         disable use of CAS\n");
       16: 6233:    printf("-b, --listen-backlog=<num> set the backlog queue limit (default: 1024)\n");
       16: 6234:    printf("-B, --protocol=<name>     protocol - one of ascii, binary, or auto (default)\n");
       16: 6235:    printf("-I, --max-item-size=<num> adjusts max item size\n"
        -: 6236:           "                          (default: 1mb, min: 1k, max: 128m)\n");
        -: 6237:#ifdef ENABLE_SASL
        -: 6238:    printf("-S, --enable-sasl         turn on Sasl authentication\n");
        -: 6239:#endif
       16: 6240:    printf("-F, --disable-flush-all   disable flush_all command\n");
       16: 6241:    printf("-X, --disable-dumping     disable stats cachedump and lru_crawler metadump\n");
       16: 6242:    printf("-o, --extended            comma separated list of extended options\n"
        -: 6243:           "                          most options have a 'no_' prefix to disable\n"
        -: 6244:           "   - maxconns_fast:       immediately close new connections after limit\n"
        -: 6245:           "   - hashpower:           an integer multiplier for how large the hash\n"
        -: 6246:           "                          table should be. normally grows at runtime.\n"
        -: 6247:           "                          set based on \"STAT hash_power_level\"\n"
        -: 6248:           "   - tail_repair_time:    time in seconds for how long to wait before\n"
        -: 6249:           "                          forcefully killing LRU tail item.\n"
        -: 6250:           "                          disabled by default; very dangerous option.\n"
        -: 6251:           "   - hash_algorithm:      the hash table algorithm\n"
        -: 6252:           "                          default is murmur3 hash. options: jenkins, murmur3\n"
        -: 6253:           "   - lru_crawler:         enable LRU Crawler background thread\n"
        -: 6254:           "   - lru_crawler_sleep:   microseconds to sleep between items\n"
        -: 6255:           "                          default is 100.\n"
        -: 6256:           "   - lru_crawler_tocrawl: max items to crawl per slab per run\n"
        -: 6257:           "                          default is 0 (unlimited)\n"
        -: 6258:           "   - lru_maintainer:      enable new LRU system + background thread\n"
        -: 6259:           "   - hot_lru_pct:         pct of slab memory to reserve for hot lru.\n"
        -: 6260:           "                          (requires lru_maintainer)\n"
        -: 6261:           "   - warm_lru_pct:        pct of slab memory to reserve for warm lru.\n"
        -: 6262:           "                          (requires lru_maintainer)\n"
        -: 6263:           "   - hot_max_factor:      items idle > cold lru age * drop from hot lru.\n"
        -: 6264:           "   - warm_max_factor:     items idle > cold lru age * this drop from warm.\n"
        -: 6265:           "   - temporary_ttl:       TTL's below get separate LRU, can't be evicted.\n"
        -: 6266:           "                          (requires lru_maintainer)\n"
        -: 6267:           "   - idle_timeout:        timeout for idle connections\n"
        -: 6268:           "   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size. use extreme care.\n"
        -: 6269:           "   - watcher_logbuf_size: size in kilobytes of per-watcher write buffer.\n"
        -: 6270:           "   - worker_logbuf_size:  size in kilobytes of per-worker-thread buffer\n"
        -: 6271:           "                          read by background thread, then written to watchers.\n"
        -: 6272:           "   - track_sizes:         enable dynamic reports for 'stats sizes' command.\n"
        -: 6273:           "   - no_inline_ascii_resp: save up to 24 bytes per item.\n"
        -: 6274:           "                           small perf hit in ASCII, no perf difference in\n"
        -: 6275:           "                           binary protocol. speeds up all sets.\n"
        -: 6276:           "   - no_hashexpand:       disables hash table expansion (dangerous)\n"
        -: 6277:           "   - modern:              enables options which will be default in future.\n"
        -: 6278:           "             currently: nothing\n"
        -: 6279:           "   - no_modern:           uses defaults of previous major version (1.4.x)\n"
        -: 6280:#ifdef HAVE_DROP_PRIVILEGES
        -: 6281:           "   - drop_privileges:     enable dropping extra syscall privileges\n"
        -: 6282:           "   - no_drop_privileges:  disable drop_privileges in case it causes issues with\n"
        -: 6283:           "                          some customisation.\n"
        -: 6284:#ifdef MEMCACHED_DEBUG
        -: 6285:           "   - relaxed_privileges: Running tests requires extra privileges.\n"
        -: 6286:#endif
        -: 6287:#endif
        -: 6288:#ifdef EXTSTORE
        -: 6289:           "   - ext_path:            file to write to for external storage.\n"
        -: 6290:           "                          ie: ext_path=/mnt/d1/extstore:1G\n"
        -: 6291:           "   - ext_page_size:       size in megabytes of storage pages.\n"
        -: 6292:           "   - ext_wbuf_size:       size in megabytes of page write buffers.\n"
        -: 6293:           "   - ext_threads:         number of IO threads to run.\n"
        -: 6294:           "   - ext_item_size:       store items larger than this (bytes)\n"
        -: 6295:           "   - ext_item_age:        store items idle at least this long\n"
        -: 6296:           "   - ext_low_ttl:         consider TTLs lower than this specially\n"
        -: 6297:           "   - ext_drop_unread:     don't re-write unread values during compaction\n"
        -: 6298:           "   - ext_recache_rate:    recache an item every N accesses\n"
        -: 6299:           "   - ext_compact_under:   compact when fewer than this many free pages\n"
        -: 6300:           "   - ext_drop_under:      drop COLD items when fewer than this many free pages\n"
        -: 6301:           "   - ext_max_frag:        max page fragmentation to tolerage\n"
        -: 6302:           "   - slab_automove_freeratio: ratio of memory to hold free as buffer.\n"
        -: 6303:           "                          (see doc/storage.txt for more info)\n"
        -: 6304:#endif
        -: 6305:           );
       16: 6306:    return;
        -: 6307:}
        -: 6308:
    #####: 6309:static void usage_license(void) {
    #####: 6310:    printf(PACKAGE " " VERSION "\n\n");
    #####: 6311:    printf(
        -: 6312:    "Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n"
        -: 6313:    "All rights reserved.\n"
        -: 6314:    "\n"
        -: 6315:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6316:    "modification, are permitted provided that the following conditions are\n"
        -: 6317:    "met:\n"
        -: 6318:    "\n"
        -: 6319:    "    * Redistributions of source code must retain the above copyright\n"
        -: 6320:    "notice, this list of conditions and the following disclaimer.\n"
        -: 6321:    "\n"
        -: 6322:    "    * Redistributions in binary form must reproduce the above\n"
        -: 6323:    "copyright notice, this list of conditions and the following disclaimer\n"
        -: 6324:    "in the documentation and/or other materials provided with the\n"
        -: 6325:    "distribution.\n"
        -: 6326:    "\n"
        -: 6327:    "    * Neither the name of the Danga Interactive nor the names of its\n"
        -: 6328:    "contributors may be used to endorse or promote products derived from\n"
        -: 6329:    "this software without specific prior written permission.\n"
        -: 6330:    "\n"
        -: 6331:    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
        -: 6332:    "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
        -: 6333:    "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
        -: 6334:    "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
        -: 6335:    "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
        -: 6336:    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
        -: 6337:    "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6338:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6339:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6340:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
        -: 6341:    "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6342:    "\n"
        -: 6343:    "\n"
        -: 6344:    "This product includes software developed by Niels Provos.\n"
        -: 6345:    "\n"
        -: 6346:    "[ libevent ]\n"
        -: 6347:    "\n"
        -: 6348:    "Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\n"
        -: 6349:    "All rights reserved.\n"
        -: 6350:    "\n"
        -: 6351:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6352:    "modification, are permitted provided that the following conditions\n"
        -: 6353:    "are met:\n"
        -: 6354:    "1. Redistributions of source code must retain the above copyright\n"
        -: 6355:    "   notice, this list of conditions and the following disclaimer.\n"
        -: 6356:    "2. Redistributions in binary form must reproduce the above copyright\n"
        -: 6357:    "   notice, this list of conditions and the following disclaimer in the\n"
        -: 6358:    "   documentation and/or other materials provided with the distribution.\n"
        -: 6359:    "3. All advertising materials mentioning features or use of this software\n"
        -: 6360:    "   must display the following acknowledgement:\n"
        -: 6361:    "      This product includes software developed by Niels Provos.\n"
        -: 6362:    "4. The name of the author may not be used to endorse or promote products\n"
        -: 6363:    "   derived from this software without specific prior written permission.\n"
        -: 6364:    "\n"
        -: 6365:    "THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
        -: 6366:    "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
        -: 6367:    "OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
        -: 6368:    "IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
        -: 6369:    "INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n"
        -: 6370:    "NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6371:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6372:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6373:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n"
        -: 6374:    "THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6375:    );
        -: 6376:
    #####: 6377:    return;
        -: 6378:}
        -: 6379:
        1: 6380:static void save_pid(const char *pid_file) {
        -: 6381:    FILE *fp;
        1: 6382:    if (access(pid_file, F_OK) == 0) {
    #####: 6383:        if ((fp = fopen(pid_file, "r")) != NULL) {
        -: 6384:            char buffer[1024];
    #####: 6385:            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
        -: 6386:                unsigned int pid;
    #####: 6387:                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
    #####: 6388:                    fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
        -: 6389:                }
        -: 6390:            }
    #####: 6391:            fclose(fp);
        -: 6392:        }
        -: 6393:    }
        -: 6394:
        -: 6395:    /* Create the pid file first with a temporary name, then
        -: 6396:     * atomically move the file to the real name to avoid a race with
        -: 6397:     * another process opening the file to read the pid, but finding
        -: 6398:     * it empty.
        -: 6399:     */
        -: 6400:    char tmp_pid_file[1024];
        1: 6401:    snprintf(tmp_pid_file, sizeof(tmp_pid_file), "%s.tmp", pid_file);
        -: 6402:
        1: 6403:    if ((fp = fopen(tmp_pid_file, "w")) == NULL) {
    #####: 6404:        vperror("Could not open the pid file %s for writing", tmp_pid_file);
    #####: 6405:        return;
        -: 6406:    }
        -: 6407:
        2: 6408:    fprintf(fp,"%ld\n", (long)getpid());
        1: 6409:    if (fclose(fp) == -1) {
    #####: 6410:        vperror("Could not close the pid file %s", tmp_pid_file);
        -: 6411:    }
        -: 6412:
        1: 6413:    if (rename(tmp_pid_file, pid_file) != 0) {
    #####: 6414:        vperror("Could not rename the pid file from %s to %s",
        -: 6415:                tmp_pid_file, pid_file);
        -: 6416:    }
        -: 6417:}
        -: 6418:
    #####: 6419:static void remove_pidfile(const char *pid_file) {
    #####: 6420:  if (pid_file == NULL)
        -: 6421:      return;
        -: 6422:
    #####: 6423:  if (unlink(pid_file) != 0) {
    #####: 6424:      vperror("Could not remove the pid file %s", pid_file);
        -: 6425:  }
        -: 6426:
        -: 6427:}
        -: 6428:
       94: 6429:static void sig_handler(const int sig) {
      188: 6430:    printf("Signal handled: %s.\n", strsignal(sig));
       94: 6431:    exit(EXIT_SUCCESS);
        -: 6432:}
        -: 6433:
        -: 6434:#ifndef HAVE_SIGIGNORE
        -: 6435:static int sigignore(int sig) {
        -: 6436:    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };
        -: 6437:
        -: 6438:    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {
        -: 6439:        return -1;
        -: 6440:    }
        -: 6441:    return 0;
        -: 6442:}
        -: 6443:#endif
        -: 6444:
        -: 6445:
        -: 6446:/*
        -: 6447: * On systems that supports multiple page sizes we may reduce the
        -: 6448: * number of TLB-misses by using the biggest available page size
        -: 6449: */
    #####: 6450:static int enable_large_pages(void) {
        -: 6451:#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
        -: 6452:    int ret = -1;
        -: 6453:    size_t sizes[32];
        -: 6454:    int avail = getpagesizes(sizes, 32);
        -: 6455:    if (avail != -1) {
        -: 6456:        size_t max = sizes[0];
        -: 6457:        struct memcntl_mha arg = {0};
        -: 6458:        int ii;
        -: 6459:
        -: 6460:        for (ii = 1; ii < avail; ++ii) {
        -: 6461:            if (max < sizes[ii]) {
        -: 6462:                max = sizes[ii];
        -: 6463:            }
        -: 6464:        }
        -: 6465:
        -: 6466:        arg.mha_flags   = 0;
        -: 6467:        arg.mha_pagesize = max;
        -: 6468:        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;
        -: 6469:
        -: 6470:        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
        -: 6471:            fprintf(stderr, "Failed to set large pages: %s\n",
        -: 6472:                    strerror(errno));
        -: 6473:            fprintf(stderr, "Will use default page size\n");
        -: 6474:        } else {
        -: 6475:            ret = 0;
        -: 6476:        }
        -: 6477:    } else {
        -: 6478:        fprintf(stderr, "Failed to get supported pagesizes: %s\n",
        -: 6479:                strerror(errno));
        -: 6480:        fprintf(stderr, "Will use default page size\n");
        -: 6481:    }
        -: 6482:
        -: 6483:    return ret;
        -: 6484:#elif defined(__linux__) && defined(MADV_HUGEPAGE)
        -: 6485:    /* check if transparent hugepages is compiled into the kernel */
        -: 6486:    struct stat st;
    #####: 6487:    int ret = stat("/sys/kernel/mm/transparent_hugepage/enabled", &st);
    #####: 6488:    if (ret || !(st.st_mode & S_IFREG)) {
    #####: 6489:        fprintf(stderr, "Transparent huge pages support not detected.\n");
    #####: 6490:        fprintf(stderr, "Will use default page size.\n");
    #####: 6491:        return -1;
        -: 6492:    }
        -: 6493:    return 0;
        -: 6494:#else
        -: 6495:    return -1;
        -: 6496:#endif
        -: 6497:}
        -: 6498:
        -: 6499:/**
        -: 6500: * Do basic sanity check of the runtime environment
        -: 6501: * @return true if no errors found, false if we can't use this env
        -: 6502: */
      119: 6503:static bool sanitycheck(void) {
        -: 6504:    /* One of our biggest problems is old and bogus libevents */
      119: 6505:    const char *ever = event_get_version();
      119: 6506:    if (ever != NULL) {
      119: 6507:        if (strncmp(ever, "1.", 2) == 0) {
        -: 6508:            /* Require at least 1.3 (that's still a couple of years old) */
    #####: 6509:            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {
    #####: 6510:                fprintf(stderr, "You are using libevent %s.\nPlease upgrade to"
        -: 6511:                        " a more recent version (1.3 or newer)\n",
        -: 6512:                        event_get_version());
    #####: 6513:                return false;
        -: 6514:            }
        -: 6515:        }
        -: 6516:    }
        -: 6517:
        -: 6518:    return true;
        -: 6519:}
        -: 6520:
    #####: 6521:static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    #####: 6522:    char *b = NULL;
    #####: 6523:    uint32_t size = 0;
    #####: 6524:    int i = 0;
    #####: 6525:    uint32_t last_size = 0;
        -: 6526:
    #####: 6527:    if (strlen(s) < 1)
        -: 6528:        return false;
        -: 6529:
    #####: 6530:    for (char *p = strtok_r(s, "-", &b);
        -: 6531:         p != NULL;
    #####: 6532:         p = strtok_r(NULL, "-", &b)) {
    #####: 6533:        if (!safe_strtoul(p, &size) || size < settings.chunk_size
    #####: 6534:             || size > settings.slab_chunk_size_max) {
    #####: 6535:            fprintf(stderr, "slab size %u is out of valid range\n", size);
    #####: 6536:            return false;
        -: 6537:        }
    #####: 6538:        if (last_size >= size) {
    #####: 6539:            fprintf(stderr, "slab size %u cannot be lower than or equal to a previous class size\n", size);
    #####: 6540:            return false;
        -: 6541:        }
    #####: 6542:        if (size <= last_size + CHUNK_ALIGN_BYTES) {
    #####: 6543:            fprintf(stderr, "slab size %u must be at least %d bytes larger than previous class\n",
        -: 6544:                    size, CHUNK_ALIGN_BYTES);
    #####: 6545:            return false;
        -: 6546:        }
    #####: 6547:        slab_sizes[i++] = size;
    #####: 6548:        last_size = size;
    #####: 6549:        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
    #####: 6550:            fprintf(stderr, "too many slab classes specified\n");
    #####: 6551:            return false;
        -: 6552:        }
        -: 6553:    }
        -: 6554:
    #####: 6555:    slab_sizes[i] = 0;
    #####: 6556:    return true;
        -: 6557:}
        -: 6558:
      119: 6559:int main (int argc, char **argv) {
        -: 6560:    int c;
      119: 6561:    bool lock_memory = false;
      119: 6562:    bool do_daemonize = false;
      119: 6563:    bool preallocate = false;
      119: 6564:    int maxcore = 0;
      119: 6565:    char *username = NULL;
      119: 6566:    char *pid_file = NULL;
        -: 6567:    struct passwd *pw;
        -: 6568:    struct rlimit rlim;
        -: 6569:    char *buf;
      119: 6570:    char unit = '\0';
      119: 6571:    int size_max = 0;
      119: 6572:    int retval = EXIT_SUCCESS;
        -: 6573:    /* listening sockets */
        -: 6574:    static int *l_socket = NULL;
        -: 6575:
        -: 6576:    /* udp socket */
        -: 6577:    static int *u_socket = NULL;
      119: 6578:    bool protocol_specified = false;
      119: 6579:    bool tcp_specified = false;
      119: 6580:    bool udp_specified = false;
      119: 6581:    bool start_lru_maintainer = true;
      119: 6582:    bool start_lru_crawler = true;
      119: 6583:    bool start_assoc_maint = true;
      119: 6584:    enum hashfunc_type hash_type = MURMUR3_HASH;
        -: 6585:    uint32_t tocrawl;
        -: 6586:    uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];
      119: 6587:    bool use_slab_sizes = false;
      119: 6588:    char *slab_sizes_unparsed = NULL;
      119: 6589:    bool slab_chunk_size_changed = false;
        -: 6590:#ifdef EXTSTORE
        -: 6591:    void *storage = NULL;
        -: 6592:    struct extstore_conf_file *storage_file = NULL;
        -: 6593:    struct extstore_conf ext_cf;
        -: 6594:#endif
        -: 6595:    char *subopts, *subopts_orig;
        -: 6596:    char *subopts_value;
        -: 6597:    enum {
        -: 6598:        MAXCONNS_FAST = 0,
        -: 6599:        HASHPOWER_INIT,
        -: 6600:        NO_HASHEXPAND,
        -: 6601:        SLAB_REASSIGN,
        -: 6602:        SLAB_AUTOMOVE,
        -: 6603:        SLAB_AUTOMOVE_RATIO,
        -: 6604:        SLAB_AUTOMOVE_WINDOW,
        -: 6605:        TAIL_REPAIR_TIME,
        -: 6606:        HASH_ALGORITHM,
        -: 6607:        LRU_CRAWLER,
        -: 6608:        LRU_CRAWLER_SLEEP,
        -: 6609:        LRU_CRAWLER_TOCRAWL,
        -: 6610:        LRU_MAINTAINER,
        -: 6611:        HOT_LRU_PCT,
        -: 6612:        WARM_LRU_PCT,
        -: 6613:        HOT_MAX_FACTOR,
        -: 6614:        WARM_MAX_FACTOR,
        -: 6615:        TEMPORARY_TTL,
        -: 6616:        IDLE_TIMEOUT,
        -: 6617:        WATCHER_LOGBUF_SIZE,
        -: 6618:        WORKER_LOGBUF_SIZE,
        -: 6619:        SLAB_SIZES,
        -: 6620:        SLAB_CHUNK_MAX,
        -: 6621:        TRACK_SIZES,
        -: 6622:        NO_INLINE_ASCII_RESP,
        -: 6623:        MODERN,
        -: 6624:        NO_MODERN,
        -: 6625:        NO_CHUNKED_ITEMS,
        -: 6626:        NO_SLAB_REASSIGN,
        -: 6627:        NO_SLAB_AUTOMOVE,
        -: 6628:        NO_MAXCONNS_FAST,
        -: 6629:        INLINE_ASCII_RESP,
        -: 6630:        NO_LRU_CRAWLER,
        -: 6631:        NO_LRU_MAINTAINER,
        -: 6632:        NO_DROP_PRIVILEGES,
        -: 6633:        DROP_PRIVILEGES,
        -: 6634:#ifdef MEMCACHED_DEBUG
        -: 6635:        RELAXED_PRIVILEGES,
        -: 6636:#endif
        -: 6637:#ifdef EXTSTORE
        -: 6638:        EXT_PAGE_SIZE,
        -: 6639:        EXT_WBUF_SIZE,
        -: 6640:        EXT_THREADS,
        -: 6641:        EXT_IO_DEPTH,
        -: 6642:        EXT_PATH,
        -: 6643:        EXT_ITEM_SIZE,
        -: 6644:        EXT_ITEM_AGE,
        -: 6645:        EXT_LOW_TTL,
        -: 6646:        EXT_RECACHE_RATE,
        -: 6647:        EXT_COMPACT_UNDER,
        -: 6648:        EXT_DROP_UNDER,
        -: 6649:        EXT_MAX_FRAG,
        -: 6650:        EXT_DROP_UNREAD,
        -: 6651:        SLAB_AUTOMOVE_FREERATIO,
        -: 6652:#endif
        -: 6653:    };
      119: 6654:    char *const subopts_tokens[] = {
        -: 6655:        [MAXCONNS_FAST] = "maxconns_fast",
        -: 6656:        [HASHPOWER_INIT] = "hashpower",
        -: 6657:        [NO_HASHEXPAND] = "no_hashexpand",
        -: 6658:        [SLAB_REASSIGN] = "slab_reassign",
        -: 6659:        [SLAB_AUTOMOVE] = "slab_automove",
        -: 6660:        [SLAB_AUTOMOVE_RATIO] = "slab_automove_ratio",
        -: 6661:        [SLAB_AUTOMOVE_WINDOW] = "slab_automove_window",
        -: 6662:        [TAIL_REPAIR_TIME] = "tail_repair_time",
        -: 6663:        [HASH_ALGORITHM] = "hash_algorithm",
        -: 6664:        [LRU_CRAWLER] = "lru_crawler",
        -: 6665:        [LRU_CRAWLER_SLEEP] = "lru_crawler_sleep",
        -: 6666:        [LRU_CRAWLER_TOCRAWL] = "lru_crawler_tocrawl",
        -: 6667:        [LRU_MAINTAINER] = "lru_maintainer",
        -: 6668:        [HOT_LRU_PCT] = "hot_lru_pct",
        -: 6669:        [WARM_LRU_PCT] = "warm_lru_pct",
        -: 6670:        [HOT_MAX_FACTOR] = "hot_max_factor",
        -: 6671:        [WARM_MAX_FACTOR] = "warm_max_factor",
        -: 6672:        [TEMPORARY_TTL] = "temporary_ttl",
        -: 6673:        [IDLE_TIMEOUT] = "idle_timeout",
        -: 6674:        [WATCHER_LOGBUF_SIZE] = "watcher_logbuf_size",
        -: 6675:        [WORKER_LOGBUF_SIZE] = "worker_logbuf_size",
        -: 6676:        [SLAB_SIZES] = "slab_sizes",
        -: 6677:        [SLAB_CHUNK_MAX] = "slab_chunk_max",
        -: 6678:        [TRACK_SIZES] = "track_sizes",
        -: 6679:        [NO_INLINE_ASCII_RESP] = "no_inline_ascii_resp",
        -: 6680:        [MODERN] = "modern",
        -: 6681:        [NO_MODERN] = "no_modern",
        -: 6682:        [NO_CHUNKED_ITEMS] = "no_chunked_items",
        -: 6683:        [NO_SLAB_REASSIGN] = "no_slab_reassign",
        -: 6684:        [NO_SLAB_AUTOMOVE] = "no_slab_automove",
        -: 6685:        [NO_MAXCONNS_FAST] = "no_maxconns_fast",
        -: 6686:        [INLINE_ASCII_RESP] = "inline_ascii_resp",
        -: 6687:        [NO_LRU_CRAWLER] = "no_lru_crawler",
        -: 6688:        [NO_LRU_MAINTAINER] = "no_lru_maintainer",
        -: 6689:        [NO_DROP_PRIVILEGES] = "no_drop_privileges",
        -: 6690:        [DROP_PRIVILEGES] = "drop_privileges",
        -: 6691:#ifdef MEMCACHED_DEBUG
        -: 6692:        [RELAXED_PRIVILEGES] = "relaxed_privileges",
        -: 6693:#endif
        -: 6694:#ifdef EXTSTORE
        -: 6695:        [EXT_PAGE_SIZE] = "ext_page_size",
        -: 6696:        [EXT_WBUF_SIZE] = "ext_wbuf_size",
        -: 6697:        [EXT_THREADS] = "ext_threads",
        -: 6698:        [EXT_IO_DEPTH] = "ext_io_depth",
        -: 6699:        [EXT_PATH] = "ext_path",
        -: 6700:        [EXT_ITEM_SIZE] = "ext_item_size",
        -: 6701:        [EXT_ITEM_AGE] = "ext_item_age",
        -: 6702:        [EXT_LOW_TTL] = "ext_low_ttl",
        -: 6703:        [EXT_RECACHE_RATE] = "ext_recache_rate",
        -: 6704:        [EXT_COMPACT_UNDER] = "ext_compact_under",
        -: 6705:        [EXT_DROP_UNDER] = "ext_drop_under",
        -: 6706:        [EXT_MAX_FRAG] = "ext_max_frag",
        -: 6707:        [EXT_DROP_UNREAD] = "ext_drop_unread",
        -: 6708:        [SLAB_AUTOMOVE_FREERATIO] = "slab_automove_freeratio",
        -: 6709:#endif
        -: 6710:        NULL
        -: 6711:    };
        -: 6712:
      119: 6713:    if (!sanitycheck()) {
        -: 6714:        return EX_OSERR;
        -: 6715:    }
        -: 6716:
        -: 6717:    /* handle SIGINT and SIGTERM */
      119: 6718:    signal(SIGINT, sig_handler);
      119: 6719:    signal(SIGTERM, sig_handler);
        -: 6720:
        -: 6721:    /* init settings */
      119: 6722:    settings_init();
        -: 6723:#ifdef EXTSTORE
        -: 6724:    settings.ext_item_size = 512;
        -: 6725:    settings.ext_item_age = UINT_MAX;
        -: 6726:    settings.ext_low_ttl = 0;
        -: 6727:    settings.ext_recache_rate = 2000;
        -: 6728:    settings.ext_max_frag = 0.8;
        -: 6729:    settings.ext_drop_unread = false;
        -: 6730:    settings.ext_wbuf_size = 1024 * 1024 * 4;
        -: 6731:    settings.ext_compact_under = 0;
        -: 6732:    settings.ext_drop_under = 0;
        -: 6733:    settings.slab_automove_freeratio = 0.01;
        -: 6734:    ext_cf.page_size = 1024 * 1024 * 64;
        -: 6735:    ext_cf.wbuf_size = settings.ext_wbuf_size;
        -: 6736:    ext_cf.io_threadcount = 1;
        -: 6737:    ext_cf.io_depth = 1;
        -: 6738:    ext_cf.page_buckets = 4;
        -: 6739:    ext_cf.wbuf_count = ext_cf.page_buckets;
        -: 6740:#endif
        -: 6741:
        -: 6742:    /* Run regardless of initializing it later */
      119: 6743:    init_lru_maintainer();
        -: 6744:
        -: 6745:    /* set stderr non-buffering (for running under, say, daemontools) */
      119: 6746:    setbuf(stderr, NULL);
        -: 6747:
      119: 6748:    char *shortopts =
        -: 6749:          "a:"  /* access mask for unix socket */
        -: 6750:          "A"  /* enable admin shutdown command */
        -: 6751:          "p:"  /* TCP port number to listen on */
        -: 6752:          "s:"  /* unix socket path to listen on */
        -: 6753:          "U:"  /* UDP port number to listen on */
        -: 6754:          "m:"  /* max memory to use for items in megabytes */
        -: 6755:          "M"   /* return error on memory exhausted */
        -: 6756:          "c:"  /* max simultaneous connections */
        -: 6757:          "k"   /* lock down all paged memory */
        -: 6758:          "hiV" /* help, licence info, version */
        -: 6759:          "r"   /* maximize core file limit */
        -: 6760:          "v"   /* verbose */
        -: 6761:          "d"   /* daemon mode */
        -: 6762:          "l:"  /* interface to listen on */
        -: 6763:          "u:"  /* user identity to run as */
        -: 6764:          "P:"  /* save PID in file */
        -: 6765:          "f:"  /* factor? */
        -: 6766:          "n:"  /* minimum space allocated for key+value+flags */
        -: 6767:          "t:"  /* threads */
        -: 6768:          "D:"  /* prefix delimiter? */
        -: 6769:          "L"   /* Large memory pages */
        -: 6770:          "R:"  /* max requests per event */
        -: 6771:          "C"   /* Disable use of CAS */
        -: 6772:          "b:"  /* backlog queue limit */
        -: 6773:          "B:"  /* Binding protocol */
        -: 6774:          "I:"  /* Max item size */
        -: 6775:          "S"   /* Sasl ON */
        -: 6776:          "F"   /* Disable flush_all */
        -: 6777:          "X"   /* Disable dump commands */
        -: 6778:          "o:"  /* Extended generic options */
        -: 6779:          ;
        -: 6780:
        -: 6781:    /* process arguments */
        -: 6782:#ifdef HAVE_GETOPT_LONG
      119: 6783:    const struct option longopts[] = {
        -: 6784:        {"unix-mask", required_argument, 0, 'a'},
        -: 6785:        {"enable-shutdown", no_argument, 0, 'A'},
        -: 6786:        {"port", required_argument, 0, 'p'},
        -: 6787:        {"unix-socket", required_argument, 0, 's'},
        -: 6788:        {"udp-port", required_argument, 0, 'U'},
        -: 6789:        {"memory-limit", required_argument, 0, 'm'},
        -: 6790:        {"disable-evictions", no_argument, 0, 'M'},
        -: 6791:        {"conn-limit", required_argument, 0, 'c'},
        -: 6792:        {"lock-memory", no_argument, 0, 'k'},
        -: 6793:        {"help", no_argument, 0, 'h'},
        -: 6794:        {"license", no_argument, 0, 'i'},
        -: 6795:        {"version", no_argument, 0, 'V'},
        -: 6796:        {"enable-coredumps", no_argument, 0, 'r'},
        -: 6797:        {"verbose", optional_argument, 0, 'v'},
        -: 6798:        {"daemon", no_argument, 0, 'd'},
        -: 6799:        {"listen", required_argument, 0, 'l'},
        -: 6800:        {"user", required_argument, 0, 'u'},
        -: 6801:        {"pidfile", required_argument, 0, 'P'},
        -: 6802:        {"slab-growth-factor", required_argument, 0, 'f'},
        -: 6803:        {"slab-min-size", required_argument, 0, 'n'},
        -: 6804:        {"threads", required_argument, 0, 't'},
        -: 6805:        {"enable-largepages", no_argument, 0, 'L'},
        -: 6806:        {"max-reqs-per-event", required_argument, 0, 'R'},
        -: 6807:        {"disable-cas", no_argument, 0, 'C'},
        -: 6808:        {"listen-backlog", required_argument, 0, 'b'},
        -: 6809:        {"protocol", required_argument, 0, 'B'},
        -: 6810:        {"max-item-size", required_argument, 0, 'I'},
        -: 6811:        {"enable-sasl", no_argument, 0, 'S'},
        -: 6812:        {"disable-flush-all", no_argument, 0, 'F'},
        -: 6813:        {"disable-dumping", no_argument, 0, 'X'},
        -: 6814:        {"extended", required_argument, 0, 'o'},
        -: 6815:        {0, 0, 0, 0}
        -: 6816:    };
        -: 6817:    int optindex;
      521: 6818:    while (-1 != (c = getopt_long(argc, argv, shortopts,
        -: 6819:                    longopts, &optindex))) {
        -: 6820:#else
        -: 6821:    while (-1 != (c = getopt(argc, argv, shortopts))) {
        -: 6822:#endif
      304: 6823:        switch (c) {
        -: 6824:        case 'A':
        -: 6825:            /* enables "shutdown" command */
        3: 6826:            settings.shutdown_command = true;
        3: 6827:            break;
        -: 6828:
        -: 6829:        case 'a':
        -: 6830:            /* access for unix domain socket, as octal mask (like chmod)*/
    #####: 6831:            settings.access= strtol(optarg,NULL,8);
    #####: 6832:            break;
        -: 6833:
        -: 6834:        case 'U':
       36: 6835:            settings.udpport = atoi(optarg);
       18: 6836:            udp_specified = true;
       18: 6837:            break;
        -: 6838:        case 'p':
       36: 6839:            settings.port = atoi(optarg);
       18: 6840:            tcp_specified = true;
       18: 6841:            break;
        -: 6842:        case 's':
       76: 6843:            settings.socketpath = optarg;
       76: 6844:            break;
        -: 6845:        case 'm':
       30: 6846:            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;
       15: 6847:            break;
        -: 6848:        case 'M':
        2: 6849:            settings.evict_to_free = 0;
        2: 6850:            break;
        -: 6851:        case 'c':
        6: 6852:            settings.maxconns = atoi(optarg);
        3: 6853:            if (settings.maxconns <= 0) {
        4: 6854:                fprintf(stderr, "Maximum connections must be greater than 0\n");
        2: 6855:                return 1;
        -: 6856:            }
        -: 6857:            break;
        -: 6858:        case 'h':
       16: 6859:            usage();
       16: 6860:            exit(EXIT_SUCCESS);
        -: 6861:        case 'i':
    #####: 6862:            usage_license();
    #####: 6863:            exit(EXIT_SUCCESS);
        -: 6864:        case 'V':
    #####: 6865:            printf(PACKAGE " " VERSION "\n");
    #####: 6866:            exit(EXIT_SUCCESS);
        -: 6867:        case 'k':
        -: 6868:            lock_memory = true;
        -: 6869:            break;
        -: 6870:        case 'v':
        6: 6871:            settings.verbose++;
        6: 6872:            break;
        -: 6873:        case 'l':
        7: 6874:            if (settings.inter != NULL) {
    #####: 6875:                if (strstr(settings.inter, optarg) != NULL) {
        -: 6876:                    break;
        -: 6877:                }
    #####: 6878:                size_t len = strlen(settings.inter) + strlen(optarg) + 2;
    #####: 6879:                char *p = malloc(len);
    #####: 6880:                if (p == NULL) {
    #####: 6881:                    fprintf(stderr, "Failed to allocate memory\n");
    #####: 6882:                    return 1;
        -: 6883:                }
    #####: 6884:                snprintf(p, len, "%s,%s", settings.inter, optarg);
    #####: 6885:                free(settings.inter);
    #####: 6886:                settings.inter = p;
        -: 6887:            } else {
        7: 6888:                settings.inter= strdup(optarg);
        -: 6889:            }
        -: 6890:            break;
        -: 6891:        case 'd':
        2: 6892:            do_daemonize = true;
        2: 6893:            break;
        -: 6894:        case 'r':
    #####: 6895:            maxcore = 1;
    #####: 6896:            break;
        -: 6897:        case 'R':
        2: 6898:            settings.reqs_per_event = atoi(optarg);
        1: 6899:            if (settings.reqs_per_event == 0) {
    #####: 6900:                fprintf(stderr, "Number of requests per event must be greater than 0\n");
    #####: 6901:                return 1;
        -: 6902:            }
        -: 6903:            break;
        -: 6904:        case 'u':
    #####: 6905:            username = optarg;
    #####: 6906:            break;
        -: 6907:        case 'P':
        2: 6908:            pid_file = optarg;
        2: 6909:            break;
        -: 6910:        case 'f':
    #####: 6911:            settings.factor = atof(optarg);
    #####: 6912:            if (settings.factor <= 1.0) {
    #####: 6913:                fprintf(stderr, "Factor must be greater than 1\n");
    #####: 6914:                return 1;
        -: 6915:            }
        -: 6916:            break;
        -: 6917:        case 'n':
    #####: 6918:            settings.chunk_size = atoi(optarg);
    #####: 6919:            if (settings.chunk_size == 0) {
    #####: 6920:                fprintf(stderr, "Chunk size must be greater than 0\n");
    #####: 6921:                return 1;
        -: 6922:            }
        -: 6923:            break;
        -: 6924:        case 't':
        2: 6925:            settings.num_threads = atoi(optarg);
        1: 6926:            if (settings.num_threads <= 0) {
        2: 6927:                fprintf(stderr, "Number of threads must be greater than 0\n");
        1: 6928:                return 1;
        -: 6929:            }
        -: 6930:            /* There're other problems when you get above 64 threads.
        -: 6931:             * In the future we should portably detect # of cores for the
        -: 6932:             * default.
        -: 6933:             */
    #####: 6934:            if (settings.num_threads > 64) {
    #####: 6935:                fprintf(stderr, "WARNING: Setting a high number of worker"
        -: 6936:                                "threads is not recommended.\n"
        -: 6937:                                " Set this value to the number of cores in"
        -: 6938:                                " your machine or less.\n");
        -: 6939:            }
        -: 6940:            break;
        -: 6941:        case 'D':
    #####: 6942:            if (! optarg || ! optarg[0]) {
    #####: 6943:                fprintf(stderr, "No delimiter specified\n");
    #####: 6944:                return 1;
        -: 6945:            }
    #####: 6946:            settings.prefix_delimiter = optarg[0];
    #####: 6947:            settings.detail_enabled = 1;
    #####: 6948:            break;
        -: 6949:        case 'L' :
    #####: 6950:            if (enable_large_pages() == 0) {
        -: 6951:                preallocate = true;
        -: 6952:            } else {
    #####: 6953:                fprintf(stderr, "Cannot enable large pages on this system\n"
        -: 6954:                    "(There is no Linux support as of this version)\n");
    #####: 6955:                return 1;
        -: 6956:            }
        -: 6957:            break;
        -: 6958:        case 'C' :
        2: 6959:            settings.use_cas = false;
        2: 6960:            break;
        -: 6961:        case 'b' :
        2: 6962:            settings.backlog = atoi(optarg);
        1: 6963:            break;
        -: 6964:        case 'B':
        8: 6965:            protocol_specified = true;
        8: 6966:            if (strcmp(optarg, "auto") == 0) {
        2: 6967:                settings.binding_protocol = negotiating_prot;
        6: 6968:            } else if (strcmp(optarg, "binary") == 0) {
        3: 6969:                settings.binding_protocol = binary_prot;
        3: 6970:            } else if (strcmp(optarg, "ascii") == 0) {
        2: 6971:                settings.binding_protocol = ascii_prot;
        -: 6972:            } else {
        2: 6973:                fprintf(stderr, "Invalid value for binding protocol: %s\n"
        -: 6974:                        " -- should be one of auto, binary, or ascii\n", optarg);
        1: 6975:                exit(EX_USAGE);
        -: 6976:            }
        -: 6977:            break;
        -: 6978:        case 'I':
        5: 6979:            buf = strdup(optarg);
        5: 6980:            unit = buf[strlen(buf)-1];
        5: 6981:            if (unit == 'k' || unit == 'm' ||
        3: 6982:                unit == 'K' || unit == 'M') {
        2: 6983:                buf[strlen(buf)-1] = '\0';
        2: 6984:                size_max = atoi(buf);
        2: 6985:                if (unit == 'k' || unit == 'K')
        1: 6986:                    size_max *= 1024;
        2: 6987:                if (unit == 'm' || unit == 'M')
        1: 6988:                    size_max *= 1024 * 1024;
        2: 6989:                settings.item_size_max = size_max;
        -: 6990:            } else {
        3: 6991:                settings.item_size_max = atoi(buf);
        -: 6992:            }
        5: 6993:            free(buf);
        5: 6994:            break;
        -: 6995:        case 'S': /* set Sasl authentication to true. Default is false */
        -: 6996:#ifndef ENABLE_SASL
        2: 6997:            fprintf(stderr, "This server is not built with SASL support.\n");
        1: 6998:            exit(EX_USAGE);
        -: 6999:#endif
        -: 7000:            settings.sasl = true;
        -: 7001:            break;
        -: 7002:       case 'F' :
        1: 7003:            settings.flush_enabled = false;
        1: 7004:            break;
        -: 7005:       case 'X' :
    #####: 7006:            settings.dump_enabled = false;
    #####: 7007:            break;
        -: 7008:        case 'o': /* It's sub-opts time! */
      116: 7009:            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */
        -: 7010:
      364: 7011:            while (*subopts != '\0') {
        -: 7012:
      132: 7013:            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
        -: 7014:            case MAXCONNS_FAST:
    #####: 7015:                settings.maxconns_fast = true;
    #####: 7016:                break;
        -: 7017:            case HASHPOWER_INIT:
    #####: 7018:                if (subopts_value == NULL) {
    #####: 7019:                    fprintf(stderr, "Missing numeric argument for hashpower\n");
    #####: 7020:                    return 1;
        -: 7021:                }
    #####: 7022:                settings.hashpower_init = atoi(subopts_value);
    #####: 7023:                if (settings.hashpower_init < 12) {
    #####: 7024:                    fprintf(stderr, "Initial hashtable multiplier of %d is too low\n",
        -: 7025:                        settings.hashpower_init);
    #####: 7026:                    return 1;
    #####: 7027:                } else if (settings.hashpower_init > 32) {
    #####: 7028:                    fprintf(stderr, "Initial hashtable multiplier of %d is too high\n"
        -: 7029:                        "Choose a value based on \"STAT hash_power_level\" from a running instance\n",
        -: 7030:                        settings.hashpower_init);
    #####: 7031:                    return 1;
        -: 7032:                }
        -: 7033:                break;
        -: 7034:            case NO_HASHEXPAND:
    #####: 7035:                start_assoc_maint = false;
    #####: 7036:                break;
        -: 7037:            case SLAB_REASSIGN:
        3: 7038:                settings.slab_reassign = true;
        3: 7039:                break;
        -: 7040:            case SLAB_AUTOMOVE:
        2: 7041:                if (subopts_value == NULL) {
        2: 7042:                    settings.slab_automove = 1;
        2: 7043:                    break;
        -: 7044:                }
    #####: 7045:                settings.slab_automove = atoi(subopts_value);
    #####: 7046:                if (settings.slab_automove < 0 || settings.slab_automove > 2) {
    #####: 7047:                    fprintf(stderr, "slab_automove must be between 0 and 2\n");
    #####: 7048:                    return 1;
        -: 7049:                }
        -: 7050:                break;
        -: 7051:            case SLAB_AUTOMOVE_RATIO:
    #####: 7052:                if (subopts_value == NULL) {
    #####: 7053:                    fprintf(stderr, "Missing slab_automove_ratio argument\n");
    #####: 7054:                    return 1;
        -: 7055:                }
    #####: 7056:                settings.slab_automove_ratio = atof(subopts_value);
    #####: 7057:                if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {
    #####: 7058:                    fprintf(stderr, "slab_automove_ratio must be > 0 and < 1\n");
    #####: 7059:                    return 1;
        -: 7060:                }
        -: 7061:                break;
        -: 7062:            case SLAB_AUTOMOVE_WINDOW:
        2: 7063:                if (subopts_value == NULL) {
    #####: 7064:                    fprintf(stderr, "Missing slab_automove_window argument\n");
    #####: 7065:                    return 1;
        -: 7066:                }
        4: 7067:                settings.slab_automove_window = atoi(subopts_value);
        2: 7068:                if (settings.slab_automove_window < 3) {
    #####: 7069:                    fprintf(stderr, "slab_automove_window must be > 2\n");
    #####: 7070:                    return 1;
        -: 7071:                }
        -: 7072:                break;
        -: 7073:            case TAIL_REPAIR_TIME:
    #####: 7074:                if (subopts_value == NULL) {
    #####: 7075:                    fprintf(stderr, "Missing numeric argument for tail_repair_time\n");
    #####: 7076:                    return 1;
        -: 7077:                }
    #####: 7078:                settings.tail_repair_time = atoi(subopts_value);
    #####: 7079:                if (settings.tail_repair_time < 10) {
    #####: 7080:                    fprintf(stderr, "Cannot set tail_repair_time to less than 10 seconds\n");
    #####: 7081:                    return 1;
        -: 7082:                }
        -: 7083:                break;
        -: 7084:            case HASH_ALGORITHM:
    #####: 7085:                if (subopts_value == NULL) {
    #####: 7086:                    fprintf(stderr, "Missing hash_algorithm argument\n");
    #####: 7087:                    return 1;
        -: 7088:                };
    #####: 7089:                if (strcmp(subopts_value, "jenkins") == 0) {
        -: 7090:                    hash_type = JENKINS_HASH;
    #####: 7091:                } else if (strcmp(subopts_value, "murmur3") == 0) {
        -: 7092:                    hash_type = MURMUR3_HASH;
        -: 7093:                } else {
    #####: 7094:                    fprintf(stderr, "Unknown hash_algorithm option (jenkins, murmur3)\n");
    #####: 7095:                    return 1;
        -: 7096:                }
        -: 7097:                break;
        -: 7098:            case LRU_CRAWLER:
        6: 7099:                start_lru_crawler = true;
        6: 7100:                break;
        -: 7101:            case LRU_CRAWLER_SLEEP:
    #####: 7102:                if (subopts_value == NULL) {
    #####: 7103:                    fprintf(stderr, "Missing lru_crawler_sleep value\n");
    #####: 7104:                    return 1;
        -: 7105:                }
    #####: 7106:                settings.lru_crawler_sleep = atoi(subopts_value);
    #####: 7107:                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {
    #####: 7108:                    fprintf(stderr, "LRU crawler sleep must be between 0 and 1 second\n");
    #####: 7109:                    return 1;
        -: 7110:                }
        -: 7111:                break;
        -: 7112:            case LRU_CRAWLER_TOCRAWL:
    #####: 7113:                if (subopts_value == NULL) {
    #####: 7114:                    fprintf(stderr, "Missing lru_crawler_tocrawl value\n");
    #####: 7115:                    return 1;
        -: 7116:                }
    #####: 7117:                if (!safe_strtoul(subopts_value, &tocrawl)) {
    #####: 7118:                    fprintf(stderr, "lru_crawler_tocrawl takes a numeric 32bit value\n");
    #####: 7119:                    return 1;
        -: 7120:                }
    #####: 7121:                settings.lru_crawler_tocrawl = tocrawl;
    #####: 7122:                break;
        -: 7123:            case LRU_MAINTAINER:
        5: 7124:                start_lru_maintainer = true;
        5: 7125:                settings.lru_segmented = true;
        5: 7126:                break;
        -: 7127:            case HOT_LRU_PCT:
    #####: 7128:                if (subopts_value == NULL) {
    #####: 7129:                    fprintf(stderr, "Missing hot_lru_pct argument\n");
    #####: 7130:                    return 1;
        -: 7131:                }
    #####: 7132:                settings.hot_lru_pct = atoi(subopts_value);
    #####: 7133:                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {
    #####: 7134:                    fprintf(stderr, "hot_lru_pct must be > 1 and < 80\n");
    #####: 7135:                    return 1;
        -: 7136:                }
        -: 7137:                break;
        -: 7138:            case WARM_LRU_PCT:
    #####: 7139:                if (subopts_value == NULL) {
    #####: 7140:                    fprintf(stderr, "Missing warm_lru_pct argument\n");
    #####: 7141:                    return 1;
        -: 7142:                }
    #####: 7143:                settings.warm_lru_pct = atoi(subopts_value);
    #####: 7144:                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {
    #####: 7145:                    fprintf(stderr, "warm_lru_pct must be > 1 and < 80\n");
    #####: 7146:                    return 1;
        -: 7147:                }
        -: 7148:                break;
        -: 7149:            case HOT_MAX_FACTOR:
    #####: 7150:                if (subopts_value == NULL) {
    #####: 7151:                    fprintf(stderr, "Missing hot_max_factor argument\n");
    #####: 7152:                    return 1;
        -: 7153:                }
    #####: 7154:                settings.hot_max_factor = atof(subopts_value);
    #####: 7155:                if (settings.hot_max_factor <= 0) {
    #####: 7156:                    fprintf(stderr, "hot_max_factor must be > 0\n");
    #####: 7157:                    return 1;
        -: 7158:                }
        -: 7159:                break;
        -: 7160:            case WARM_MAX_FACTOR:
    #####: 7161:                if (subopts_value == NULL) {
    #####: 7162:                    fprintf(stderr, "Missing warm_max_factor argument\n");
    #####: 7163:                    return 1;
        -: 7164:                }
    #####: 7165:                settings.warm_max_factor = atof(subopts_value);
    #####: 7166:                if (settings.warm_max_factor <= 0) {
    #####: 7167:                    fprintf(stderr, "warm_max_factor must be > 0\n");
    #####: 7168:                    return 1;
        -: 7169:                }
        -: 7170:                break;
        -: 7171:            case TEMPORARY_TTL:
        1: 7172:                if (subopts_value == NULL) {
    #####: 7173:                    fprintf(stderr, "Missing temporary_ttl argument\n");
    #####: 7174:                    return 1;
        -: 7175:                }
        1: 7176:                settings.temp_lru = true;
        2: 7177:                settings.temporary_ttl = atoi(subopts_value);
        1: 7178:                break;
        -: 7179:            case IDLE_TIMEOUT:
        1: 7180:                if (subopts_value == NULL) {
    #####: 7181:                    fprintf(stderr, "Missing numeric argument for idle_timeout\n");
    #####: 7182:                    return 1;
        -: 7183:                }
        2: 7184:                settings.idle_timeout = atoi(subopts_value);
        1: 7185:                break;
        -: 7186:            case WATCHER_LOGBUF_SIZE:
        1: 7187:                if (subopts_value == NULL) {
    #####: 7188:                    fprintf(stderr, "Missing watcher_logbuf_size argument\n");
    #####: 7189:                    return 1;
        -: 7190:                }
        1: 7191:                if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {
    #####: 7192:                    fprintf(stderr, "could not parse argument to watcher_logbuf_size\n");
    #####: 7193:                    return 1;
        -: 7194:                }
        1: 7195:                settings.logger_watcher_buf_size *= 1024; /* kilobytes */
        1: 7196:                break;
        -: 7197:            case WORKER_LOGBUF_SIZE:
    #####: 7198:                if (subopts_value == NULL) {
    #####: 7199:                    fprintf(stderr, "Missing worker_logbuf_size argument\n");
    #####: 7200:                    return 1;
        -: 7201:                }
    #####: 7202:                if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {
    #####: 7203:                    fprintf(stderr, "could not parse argument to worker_logbuf_size\n");
    #####: 7204:                    return 1;
        -: 7205:                }
    #####: 7206:                settings.logger_buf_size *= 1024; /* kilobytes */
        -: 7207:            case SLAB_SIZES:
    #####: 7208:                slab_sizes_unparsed = subopts_value;
    #####: 7209:                break;
        -: 7210:            case SLAB_CHUNK_MAX:
        5: 7211:                if (subopts_value == NULL) {
    #####: 7212:                    fprintf(stderr, "Missing slab_chunk_max argument\n");
        -: 7213:                }
        5: 7214:                if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {
    #####: 7215:                    fprintf(stderr, "could not parse argument to slab_chunk_max\n");
        -: 7216:                }
        -: 7217:                slab_chunk_size_changed = true;
        -: 7218:                break;
        -: 7219:            case TRACK_SIZES:
    #####: 7220:                item_stats_sizes_init();
    #####: 7221:                break;
        -: 7222:            case NO_INLINE_ASCII_RESP:
        1: 7223:                settings.inline_ascii_response = false;
        1: 7224:                break;
        -: 7225:            case INLINE_ASCII_RESP:
    #####: 7226:                settings.inline_ascii_response = true;
    #####: 7227:                break;
        -: 7228:            case NO_CHUNKED_ITEMS:
    #####: 7229:                settings.slab_chunk_size_max = settings.slab_page_size;
    #####: 7230:                break;
        -: 7231:            case NO_SLAB_REASSIGN:
    #####: 7232:                settings.slab_reassign = false;
    #####: 7233:                break;
        -: 7234:            case NO_SLAB_AUTOMOVE:
    #####: 7235:                settings.slab_automove = 0;
    #####: 7236:                break;
        -: 7237:            case NO_MAXCONNS_FAST:
    #####: 7238:                settings.maxconns_fast = false;
    #####: 7239:                break;
        -: 7240:            case NO_LRU_CRAWLER:
        1: 7241:                settings.lru_crawler = false;
        1: 7242:                start_lru_crawler = false;
        1: 7243:                break;
        -: 7244:            case NO_LRU_MAINTAINER:
        1: 7245:                start_lru_maintainer = false;
        1: 7246:                settings.lru_segmented = false;
        1: 7247:                break;
        -: 7248:#ifdef EXTSTORE
        -: 7249:            case EXT_PAGE_SIZE:
        -: 7250:                if (subopts_value == NULL) {
        -: 7251:                    fprintf(stderr, "Missing ext_page_size argument\n");
        -: 7252:                    return 1;
        -: 7253:                }
        -: 7254:                if (!safe_strtoul(subopts_value, &ext_cf.page_size)) {
        -: 7255:                    fprintf(stderr, "could not parse argument to ext_page_size\n");
        -: 7256:                    return 1;
        -: 7257:                }
        -: 7258:                ext_cf.page_size *= 1024 * 1024; /* megabytes */
        -: 7259:                break;
        -: 7260:            case EXT_WBUF_SIZE:
        -: 7261:                if (subopts_value == NULL) {
        -: 7262:                    fprintf(stderr, "Missing ext_wbuf_size argument\n");
        -: 7263:                    return 1;
        -: 7264:                }
        -: 7265:                if (!safe_strtoul(subopts_value, &ext_cf.wbuf_size)) {
        -: 7266:                    fprintf(stderr, "could not parse argument to ext_wbuf_size\n");
        -: 7267:                    return 1;
        -: 7268:                }
        -: 7269:                ext_cf.wbuf_size *= 1024 * 1024; /* megabytes */
        -: 7270:                settings.ext_wbuf_size = ext_cf.wbuf_size;
        -: 7271:                break;
        -: 7272:            case EXT_THREADS:
        -: 7273:                if (subopts_value == NULL) {
        -: 7274:                    fprintf(stderr, "Missing ext_threads argument\n");
        -: 7275:                    return 1;
        -: 7276:                }
        -: 7277:                if (!safe_strtoul(subopts_value, &ext_cf.io_threadcount)) {
        -: 7278:                    fprintf(stderr, "could not parse argument to ext_threads\n");
        -: 7279:                    return 1;
        -: 7280:                }
        -: 7281:                break;
        -: 7282:            case EXT_IO_DEPTH:
        -: 7283:                if (subopts_value == NULL) {
        -: 7284:                    fprintf(stderr, "Missing ext_io_depth argument\n");
        -: 7285:                    return 1;
        -: 7286:                }
        -: 7287:                if (!safe_strtoul(subopts_value, &ext_cf.io_depth)) {
        -: 7288:                    fprintf(stderr, "could not parse argument to ext_io_depth\n");
        -: 7289:                    return 1;
        -: 7290:                }
        -: 7291:                break;
        -: 7292:            case EXT_ITEM_SIZE:
        -: 7293:                if (subopts_value == NULL) {
        -: 7294:                    fprintf(stderr, "Missing ext_item_size argument\n");
        -: 7295:                    return 1;
        -: 7296:                }
        -: 7297:                if (!safe_strtoul(subopts_value, &settings.ext_item_size)) {
        -: 7298:                    fprintf(stderr, "could not parse argument to ext_item_size\n");
        -: 7299:                    return 1;
        -: 7300:                }
        -: 7301:                break;
        -: 7302:            case EXT_ITEM_AGE:
        -: 7303:                if (subopts_value == NULL) {
        -: 7304:                    fprintf(stderr, "Missing ext_item_age argument\n");
        -: 7305:                    return 1;
        -: 7306:                }
        -: 7307:                if (!safe_strtoul(subopts_value, &settings.ext_item_age)) {
        -: 7308:                    fprintf(stderr, "could not parse argument to ext_item_age\n");
        -: 7309:                    return 1;
        -: 7310:                }
        -: 7311:                break;
        -: 7312:            case EXT_LOW_TTL:
        -: 7313:                if (subopts_value == NULL) {
        -: 7314:                    fprintf(stderr, "Missing ext_low_ttl argument\n");
        -: 7315:                    return 1;
        -: 7316:                }
        -: 7317:                if (!safe_strtoul(subopts_value, &settings.ext_low_ttl)) {
        -: 7318:                    fprintf(stderr, "could not parse argument to ext_low_ttl\n");
        -: 7319:                    return 1;
        -: 7320:                }
        -: 7321:                break;
        -: 7322:            case EXT_RECACHE_RATE:
        -: 7323:                if (subopts_value == NULL) {
        -: 7324:                    fprintf(stderr, "Missing ext_recache_rate argument\n");
        -: 7325:                    return 1;
        -: 7326:                }
        -: 7327:                if (!safe_strtoul(subopts_value, &settings.ext_recache_rate)) {
        -: 7328:                    fprintf(stderr, "could not parse argument to ext_recache_rate\n");
        -: 7329:                    return 1;
        -: 7330:                }
        -: 7331:                break;
        -: 7332:            case EXT_COMPACT_UNDER:
        -: 7333:                if (subopts_value == NULL) {
        -: 7334:                    fprintf(stderr, "Missing ext_compact_under argument\n");
        -: 7335:                    return 1;
        -: 7336:                }
        -: 7337:                if (!safe_strtoul(subopts_value, &settings.ext_compact_under)) {
        -: 7338:                    fprintf(stderr, "could not parse argument to ext_compact_under\n");
        -: 7339:                    return 1;
        -: 7340:                }
        -: 7341:                break;
        -: 7342:            case EXT_DROP_UNDER:
        -: 7343:                if (subopts_value == NULL) {
        -: 7344:                    fprintf(stderr, "Missing ext_drop_under argument\n");
        -: 7345:                    return 1;
        -: 7346:                }
        -: 7347:                if (!safe_strtoul(subopts_value, &settings.ext_drop_under)) {
        -: 7348:                    fprintf(stderr, "could not parse argument to ext_drop_under\n");
        -: 7349:                    return 1;
        -: 7350:                }
        -: 7351:                break;
        -: 7352:            case EXT_MAX_FRAG:
        -: 7353:                if (subopts_value == NULL) {
        -: 7354:                    fprintf(stderr, "Missing ext_max_frag argument\n");
        -: 7355:                    return 1;
        -: 7356:                }
        -: 7357:                if (!safe_strtod(subopts_value, &settings.ext_max_frag)) {
        -: 7358:                    fprintf(stderr, "could not parse argument to ext_max_frag\n");
        -: 7359:                    return 1;
        -: 7360:                }
        -: 7361:                break;
        -: 7362:            case SLAB_AUTOMOVE_FREERATIO:
        -: 7363:                if (subopts_value == NULL) {
        -: 7364:                    fprintf(stderr, "Missing slab_automove_freeratio argument\n");
        -: 7365:                    return 1;
        -: 7366:                }
        -: 7367:                if (!safe_strtod(subopts_value, &settings.slab_automove_freeratio)) {
        -: 7368:                    fprintf(stderr, "could not parse argument to slab_automove_freeratio\n");
        -: 7369:                    return 1;
        -: 7370:                }
        -: 7371:                break;
        -: 7372:            case EXT_DROP_UNREAD:
        -: 7373:                settings.ext_drop_unread = true;
        -: 7374:                break;
        -: 7375:            case EXT_PATH:
        -: 7376:                if (subopts_value) {
        -: 7377:                    struct extstore_conf_file *tmp = storage_conf_parse(subopts_value, ext_cf.page_size);
        -: 7378:                    if (tmp == NULL) {
        -: 7379:                        fprintf(stderr, "failed to parse ext_path argument\n");
        -: 7380:                        return 1;
        -: 7381:                    }
        -: 7382:                    if (storage_file != NULL) {
        -: 7383:                        tmp->next = storage_file;
        -: 7384:                    }
        -: 7385:                    storage_file = tmp;
        -: 7386:                } else {
        -: 7387:                    fprintf(stderr, "missing argument to ext_path, ie: ext_path=/d/file:5G\n");
        -: 7388:                    return 1;
        -: 7389:                }
        -: 7390:                break;
        -: 7391:#endif
        -: 7392:            case MODERN:
        -: 7393:                /* currently no new defaults */
        -: 7394:                break;
        -: 7395:            case NO_MODERN:
        7: 7396:                if (!slab_chunk_size_changed) {
        7: 7397:                    settings.slab_chunk_size_max = settings.slab_page_size;
        -: 7398:                }
        7: 7399:                settings.slab_reassign = false;
        7: 7400:                settings.slab_automove = 0;
        7: 7401:                settings.maxconns_fast = false;
        7: 7402:                settings.inline_ascii_response = true;
        7: 7403:                settings.lru_segmented = false;
        7: 7404:                hash_type = JENKINS_HASH;
        7: 7405:                start_lru_crawler = false;
        7: 7406:                start_lru_maintainer = false;
        7: 7407:                break;
        -: 7408:            case NO_DROP_PRIVILEGES:
    #####: 7409:                settings.drop_privileges = false;
    #####: 7410:                break;
        -: 7411:            case DROP_PRIVILEGES:
    #####: 7412:                settings.drop_privileges = true;
    #####: 7413:                break;
        -: 7414:#ifdef MEMCACHED_DEBUG
        -: 7415:            case RELAXED_PRIVILEGES:
       95: 7416:                settings.relaxed_privileges = true;
       95: 7417:                break;
        -: 7418:#endif
        -: 7419:            default:
    #####: 7420:                printf("Illegal suboption \"%s\"\n", subopts_value);
    #####: 7421:                return 1;
        -: 7422:            }
        -: 7423:
        -: 7424:            }
      116: 7425:            free(subopts_orig);
      116: 7426:            break;
        -: 7427:        default:
    #####: 7428:            fprintf(stderr, "Illegal argument \"%c\"\n", c);
    #####: 7429:            return 1;
        -: 7430:        }
        -: 7431:    }
        -: 7432:
       98: 7433:    if (settings.item_size_max < 1024) {
        2: 7434:        fprintf(stderr, "Item max size cannot be less than 1024 bytes.\n");
        1: 7435:        exit(EX_USAGE);
        -: 7436:    }
       97: 7437:    if (settings.item_size_max > (settings.maxbytes / 2)) {
        2: 7438:        fprintf(stderr, "Cannot set item size limit higher than 1/2 of memory max.\n");
        1: 7439:        exit(EX_USAGE);
        -: 7440:    }
       96: 7441:    if (settings.item_size_max > (1024 * 1024 * 1024)) {
    #####: 7442:        fprintf(stderr, "Cannot set item size limit higher than a gigabyte.\n");
    #####: 7443:        exit(EX_USAGE);
        -: 7444:    }
       96: 7445:    if (settings.item_size_max > 1024 * 1024) {
        1: 7446:        if (!slab_chunk_size_changed) {
        -: 7447:            // Ideal new default is 16k, but needs stitching.
        1: 7448:            settings.slab_chunk_size_max = settings.slab_page_size / 2;
        -: 7449:        }
        -: 7450:    }
        -: 7451:
       96: 7452:    if (settings.slab_chunk_size_max > settings.item_size_max) {
    #####: 7453:        fprintf(stderr, "slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\n",
        -: 7454:                settings.slab_chunk_size_max, settings.item_size_max);
    #####: 7455:        exit(EX_USAGE);
        -: 7456:    }
        -: 7457:
       96: 7458:    if (settings.item_size_max % settings.slab_chunk_size_max != 0) {
    #####: 7459:        fprintf(stderr, "-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\n",
        -: 7460:                settings.item_size_max, settings.slab_chunk_size_max);
    #####: 7461:        exit(EX_USAGE);
        -: 7462:    }
        -: 7463:
       96: 7464:    if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {
    #####: 7465:        fprintf(stderr, "slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\n",
        -: 7466:                settings.slab_chunk_size_max, settings.slab_page_size);
    #####: 7467:        exit(EX_USAGE);
        -: 7468:    }
        -: 7469:#ifdef EXTSTORE
        -: 7470:    if (storage_file) {
        -: 7471:        if (settings.item_size_max > ext_cf.wbuf_size) {
        -: 7472:            fprintf(stderr, "-I (item_size_max: %d) cannot be larger than ext_wbuf_size: %d\n",
        -: 7473:                settings.item_size_max, ext_cf.wbuf_size);
        -: 7474:            exit(EX_USAGE);
        -: 7475:        }
        -: 7476:
        -: 7477:        /* This is due to the suffix header being generated with the wrong length
        -: 7478:         * value for the ITEM_HDR replacement. The cuddled nbytes no longer
        -: 7479:         * matches, so we end up losing a few bytes on readback.
        -: 7480:         */
        -: 7481:        if (settings.inline_ascii_response) {
        -: 7482:            fprintf(stderr, "Cannot use inline_ascii_response with extstore enabled\n");
        -: 7483:            exit(EX_USAGE);
        -: 7484:        }
        -: 7485:
        -: 7486:        if (settings.udpport) {
        -: 7487:            fprintf(stderr, "Cannot use UDP with extstore enabled (-U 0 to disable)\n");
        -: 7488:            exit(EX_USAGE);
        -: 7489:        }
        -: 7490:    }
        -: 7491:#endif
        -: 7492:    // Reserve this for the new default. If factor size hasn't changed, use
        -: 7493:    // new default.
        -: 7494:    /*if (settings.slab_chunk_size_max == 16384 && settings.factor == 1.25) {
        -: 7495:        settings.factor = 1.08;
        -: 7496:    }*/
        -: 7497:
       96: 7498:    if (slab_sizes_unparsed != NULL) {
    #####: 7499:        if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {
        -: 7500:            use_slab_sizes = true;
        -: 7501:        } else {
    #####: 7502:            exit(EX_USAGE);
        -: 7503:        }
        -: 7504:    }
        -: 7505:
       96: 7506:    if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {
    #####: 7507:        fprintf(stderr, "hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\n");
    #####: 7508:        exit(EX_USAGE);
        -: 7509:    }
        -: 7510:
       96: 7511:    if (settings.temp_lru && !start_lru_maintainer) {
    #####: 7512:        fprintf(stderr, "temporary_ttl requires lru_maintainer to be enabled\n");
    #####: 7513:        exit(EX_USAGE);
        -: 7514:    }
        -: 7515:
       96: 7516:    if (hash_init(hash_type) != 0) {
    #####: 7517:        fprintf(stderr, "Failed to initialize hash_algorithm!\n");
    #####: 7518:        exit(EX_USAGE);
        -: 7519:    }
        -: 7520:
        -: 7521:    /*
        -: 7522:     * Use one workerthread to serve each UDP port if the user specified
        -: 7523:     * multiple ports
        -: 7524:     */
       96: 7525:    if (settings.inter != NULL && strchr(settings.inter, ',')) {
    #####: 7526:        settings.num_threads_per_udp = 1;
        -: 7527:    } else {
       96: 7528:        settings.num_threads_per_udp = settings.num_threads;
        -: 7529:    }
        -: 7530:
       96: 7531:    if (settings.sasl) {
    #####: 7532:        if (!protocol_specified) {
    #####: 7533:            settings.binding_protocol = binary_prot;
        -: 7534:        } else {
    #####: 7535:            if (settings.binding_protocol != binary_prot) {
    #####: 7536:                fprintf(stderr, "ERROR: You cannot allow the ASCII protocol while using SASL.\n");
    #####: 7537:                exit(EX_USAGE);
        -: 7538:            }
        -: 7539:        }
        -: 7540:    }
        -: 7541:
       96: 7542:    if (udp_specified && settings.udpport != 0 && !tcp_specified) {
        2: 7543:        settings.port = settings.udpport;
        -: 7544:    }
        -: 7545:
       96: 7546:    if (maxcore != 0) {
        -: 7547:        struct rlimit rlim_new;
        -: 7548:        /*
        -: 7549:         * First try raising to infinity; if that fails, try bringing
        -: 7550:         * the soft limit to the hard.
        -: 7551:         */
    #####: 7552:        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
    #####: 7553:            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
    #####: 7554:            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {
        -: 7555:                /* failed. try raising just to the old max */
    #####: 7556:                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
    #####: 7557:                (void)setrlimit(RLIMIT_CORE, &rlim_new);
        -: 7558:            }
        -: 7559:        }
        -: 7560:        /*
        -: 7561:         * getrlimit again to see what we ended up with. Only fail if
        -: 7562:         * the soft limit ends up 0, because then no core files will be
        -: 7563:         * created at all.
        -: 7564:         */
        -: 7565:
    #####: 7566:        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {
    #####: 7567:            fprintf(stderr, "failed to ensure corefile creation\n");
    #####: 7568:            exit(EX_OSERR);
        -: 7569:        }
        -: 7570:    }
        -: 7571:
        -: 7572:    /*
        -: 7573:     * If needed, increase rlimits to allow as many connections
        -: 7574:     * as needed.
        -: 7575:     */
        -: 7576:
       96: 7577:    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 7578:        fprintf(stderr, "failed to getrlimit number of files\n");
    #####: 7579:        exit(EX_OSERR);
        -: 7580:    } else {
       96: 7581:        rlim.rlim_cur = settings.maxconns;
       96: 7582:        rlim.rlim_max = settings.maxconns;
       96: 7583:        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 7584:            fprintf(stderr, "failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n");
    #####: 7585:            exit(EX_OSERR);
        -: 7586:        }
        -: 7587:    }
        -: 7588:
        -: 7589:    /* lose root privileges if we have them */
       96: 7590:    if (getuid() == 0 || geteuid() == 0) {
    #####: 7591:        if (username == 0 || *username == '\0') {
    #####: 7592:            fprintf(stderr, "can't run as root without the -u switch\n");
    #####: 7593:            exit(EX_USAGE);
        -: 7594:        }
    #####: 7595:        if ((pw = getpwnam(username)) == 0) {
    #####: 7596:            fprintf(stderr, "can't find the user %s to switch to\n", username);
    #####: 7597:            exit(EX_NOUSER);
        -: 7598:        }
    #####: 7599:        if (setgroups(0, NULL) < 0) {
    #####: 7600:            fprintf(stderr, "failed to drop supplementary groups\n");
    #####: 7601:            exit(EX_OSERR);
        -: 7602:        }
    #####: 7603:        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {
    #####: 7604:            fprintf(stderr, "failed to assume identity of user %s\n", username);
    #####: 7605:            exit(EX_OSERR);
        -: 7606:        }
        -: 7607:    }
        -: 7608:
        -: 7609:    /* Initialize Sasl if -S was specified */
        -: 7610:    if (settings.sasl) {
        -: 7611:        init_sasl();
        -: 7612:    }
        -: 7613:
        -: 7614:    /* daemonize if requested */
        -: 7615:    /* if we want to ensure our ability to dump core, don't chdir to / */
       96: 7616:    if (do_daemonize) {
        2: 7617:        if (sigignore(SIGHUP) == -1) {
    #####: 7618:            perror("Failed to ignore SIGHUP");
        -: 7619:        }
        2: 7620:        if (daemonize(maxcore, settings.verbose) == -1) {
    #####: 7621:            fprintf(stderr, "failed to daemon() in order to daemonize\n");
    #####: 7622:            exit(EXIT_FAILURE);
        -: 7623:        }
        -: 7624:    }
        -: 7625:
        -: 7626:    /* lock paged memory if needed */
       95: 7627:    if (lock_memory) {
        -: 7628:#ifdef HAVE_MLOCKALL
    #####: 7629:        int res = mlockall(MCL_CURRENT | MCL_FUTURE);
    #####: 7630:        if (res != 0) {
    #####: 7631:            fprintf(stderr, "warning: -k invalid, mlockall() failed: %s\n",
    #####: 7632:                    strerror(errno));
        -: 7633:        }
        -: 7634:#else
        -: 7635:        fprintf(stderr, "warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\n");
        -: 7636:#endif
        -: 7637:    }
        -: 7638:
        -: 7639:    /* initialize main thread libevent instance */
        -: 7640:#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
        -: 7641:    /* If libevent version is larger/equal to 2.0.2-alpha, use newer version */
        -: 7642:    struct event_config *ev_config;
       95: 7643:    ev_config = event_config_new();
       95: 7644:    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
       95: 7645:    main_base = event_base_new_with_config(ev_config);
       95: 7646:    event_config_free(ev_config);
        -: 7647:#else
        -: 7648:    /* Otherwise, use older API */
        -: 7649:    main_base = event_init();
        -: 7650:#endif
        -: 7651:
        -: 7652:    /* initialize other stuff */
       95: 7653:    logger_init();
       95: 7654:    stats_init();
       95: 7655:    assoc_init(settings.hashpower_init);
       95: 7656:    conn_init();
       95: 7657:    slabs_init(settings.maxbytes, settings.factor, preallocate,
        -: 7658:            use_slab_sizes ? slab_sizes : NULL);
        -: 7659:#ifdef EXTSTORE
        -: 7660:    if (storage_file) {
        -: 7661:        enum extstore_res eres;
        -: 7662:        if (settings.ext_compact_under == 0) {
        -: 7663:            settings.ext_compact_under = storage_file->page_count / 4;
        -: 7664:            /* Only rescues non-COLD items if below this threshold */
        -: 7665:            settings.ext_drop_under = storage_file->page_count / 4;
        -: 7666:        }
        -: 7667:        crc32c_init();
        -: 7668:        /* Init free chunks to zero. */
        -: 7669:        for (int x = 0; x < MAX_NUMBER_OF_SLAB_CLASSES; x++) {
        -: 7670:            settings.ext_free_memchunks[x] = 0;
        -: 7671:        }
        -: 7672:        storage = extstore_init(storage_file, &ext_cf, &eres);
        -: 7673:        if (storage == NULL) {
        -: 7674:            fprintf(stderr, "Failed to initialize external storage: %s\n",
        -: 7675:                    extstore_err(eres));
        -: 7676:            if (eres == EXTSTORE_INIT_OPEN_FAIL) {
        -: 7677:                perror("extstore open");
        -: 7678:            }
        -: 7679:            exit(EXIT_FAILURE);
        -: 7680:        }
        -: 7681:        ext_storage = storage;
        -: 7682:        /* page mover algorithm for extstore needs memory prefilled */
        -: 7683:        slabs_prefill_global();
        -: 7684:    }
        -: 7685:#endif
        -: 7686:    /*
        -: 7687:     * ignore SIGPIPE signals; we can use errno == EPIPE if we
        -: 7688:     * need that information
        -: 7689:     */
       95: 7690:    if (sigignore(SIGPIPE) == -1) {
    #####: 7691:        perror("failed to ignore SIGPIPE; sigaction");
    #####: 7692:        exit(EX_OSERR);
        -: 7693:    }
        -: 7694:    /* start up worker threads if MT mode */
        -: 7695:#ifdef EXTSTORE
        -: 7696:    slabs_set_storage(storage);
        -: 7697:    memcached_thread_init(settings.num_threads, storage);
        -: 7698:    init_lru_crawler(storage);
        -: 7699:#else
       95: 7700:    memcached_thread_init(settings.num_threads, NULL);
       95: 7701:    init_lru_crawler(NULL);
        -: 7702:#endif
        -: 7703:
       95: 7704:    if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {
    #####: 7705:        exit(EXIT_FAILURE);
        -: 7706:    }
       95: 7707:    if (start_lru_crawler && start_item_crawler_thread() != 0) {
    #####: 7708:        fprintf(stderr, "Failed to enable LRU crawler thread\n");
    #####: 7709:        exit(EXIT_FAILURE);
        -: 7710:    }
        -: 7711:#ifdef EXTSTORE
        -: 7712:    if (storage && start_storage_compact_thread(storage) != 0) {
        -: 7713:        fprintf(stderr, "Failed to start storage compaction thread\n");
        -: 7714:        exit(EXIT_FAILURE);
        -: 7715:    }
        -: 7716:    if (storage && start_storage_write_thread(storage) != 0) {
        -: 7717:        fprintf(stderr, "Failed to start storage writer thread\n");
        -: 7718:        exit(EXIT_FAILURE);
        -: 7719:    }
        -: 7720:
        -: 7721:    if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {
        -: 7722:#else
       95: 7723:    if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {
        -: 7724:#endif
    #####: 7725:        fprintf(stderr, "Failed to enable LRU maintainer thread\n");
    #####: 7726:        return 1;
        -: 7727:    }
        -: 7728:
      183: 7729:    if (settings.slab_reassign &&
       88: 7730:        start_slab_maintenance_thread() == -1) {
    #####: 7731:        exit(EXIT_FAILURE);
        -: 7732:    }
        -: 7733:
       95: 7734:    if (settings.idle_timeout && start_conn_timeout_thread() == -1) {
    #####: 7735:        exit(EXIT_FAILURE);
        -: 7736:    }
        -: 7737:
        -: 7738:    /* initialise clock event */
       95: 7739:    clock_handler(0, 0, 0);
        -: 7740:
        -: 7741:    /* create unix mode sockets after dropping privileges */
       95: 7742:    if (settings.socketpath != NULL) {
       73: 7743:        errno = 0;
       73: 7744:        if (server_socket_unix(settings.socketpath,settings.access)) {
    #####: 7745:            vperror("failed to listen on UNIX socket: %s", settings.socketpath);
    #####: 7746:            exit(EX_OSERR);
        -: 7747:        }
        -: 7748:    }
        -: 7749:
        -: 7750:    /* create the listening socket, bind it, and init */
       95: 7751:    if (settings.socketpath == NULL) {
       22: 7752:        const char *portnumber_filename = getenv("MEMCACHED_PORT_FILENAME");
       22: 7753:        char *temp_portnumber_filename = NULL;
        -: 7754:        size_t len;
       22: 7755:        FILE *portnumber_file = NULL;
        -: 7756:
       22: 7757:        if (portnumber_filename != NULL) {
       15: 7758:            len = strlen(portnumber_filename)+4+1;
       15: 7759:            temp_portnumber_filename = malloc(len);
       15: 7760:            snprintf(temp_portnumber_filename,
        -: 7761:                     len,
        -: 7762:                     "%s.lck", portnumber_filename);
        -: 7763:
       15: 7764:            portnumber_file = fopen(temp_portnumber_filename, "a");
       15: 7765:            if (portnumber_file == NULL) {
    #####: 7766:                fprintf(stderr, "Failed to open \"%s\": %s\n",
    #####: 7767:                        temp_portnumber_filename, strerror(errno));
        -: 7768:            }
        -: 7769:        }
        -: 7770:
       22: 7771:        errno = 0;
       22: 7772:        if (settings.port && server_sockets(settings.port, tcp_transport,
        -: 7773:                                           portnumber_file)) {
        1: 7774:            vperror("failed to listen on TCP port %d", settings.port);
        1: 7775:            exit(EX_OSERR);
        -: 7776:        }
        -: 7777:
        -: 7778:        /*
        -: 7779:         * initialization order: first create the listening sockets
        -: 7780:         * (may need root on low ports), then drop root if needed,
        -: 7781:         * then daemonize if needed, then init libevent (in some cases
        -: 7782:         * descriptors created by libevent wouldn't survive forking).
        -: 7783:         */
        -: 7784:
        -: 7785:        /* create the UDP listening socket and bind it */
       21: 7786:        errno = 0;
       21: 7787:        if (settings.udpport && server_sockets(settings.udpport, udp_transport,
        -: 7788:                                              portnumber_file)) {
    #####: 7789:            vperror("failed to listen on UDP port %d", settings.udpport);
    #####: 7790:            exit(EX_OSERR);
        -: 7791:        }
        -: 7792:
       21: 7793:        if (portnumber_file) {
       15: 7794:            fclose(portnumber_file);
       15: 7795:            rename(temp_portnumber_filename, portnumber_filename);
        -: 7796:        }
       21: 7797:        if (temp_portnumber_filename)
       15: 7798:            free(temp_portnumber_filename);
        -: 7799:    }
        -: 7800:
        -: 7801:    /* Give the sockets a moment to open. I know this is dumb, but the error
        -: 7802:     * is only an advisory.
        -: 7803:     */
       94: 7804:    usleep(1000);
       94: 7805:    if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 7806:        fprintf(stderr, "Maxconns setting is too low, use -c to increase.\n");
    #####: 7807:        exit(EXIT_FAILURE);
        -: 7808:    }
        -: 7809:
       94: 7810:    if (pid_file != NULL) {
        1: 7811:        save_pid(pid_file);
        -: 7812:    }
        -: 7813:
        -: 7814:    /* Drop privileges no longer needed */
        -: 7815:    if (settings.drop_privileges) {
        -: 7816:        drop_privileges();
        -: 7817:    }
        -: 7818:
        -: 7819:    /* Initialize the uriencode lookup table. */
       94: 7820:    uriencode_init();
        -: 7821:
        -: 7822:    /* enter the event loop */
       94: 7823:    if (event_base_loop(main_base, 0) != 0) {
    #####: 7824:        retval = EXIT_FAILURE;
        -: 7825:    }
        -: 7826:
    #####: 7827:    stop_assoc_maintenance_thread();
        -: 7828:
        -: 7829:    /* remove the PID file if we're a daemon */
    #####: 7830:    if (do_daemonize)
    #####: 7831:        remove_pidfile(pid_file);
        -: 7832:    /* Clean up strdup() call for bind() address */
    #####: 7833:    if (settings.inter)
    #####: 7834:      free(settings.inter);
    #####: 7835:    if (l_socket)
    #####: 7836:      free(l_socket);
    #####: 7837:    if (u_socket)
    #####: 7838:      free(u_socket);
        -: 7839:
        -: 7840:    /* cleanup base */
    #####: 7841:    event_base_free(main_base);
        -: 7842:
    #####: 7843:    return retval;
        -: 7844:}
